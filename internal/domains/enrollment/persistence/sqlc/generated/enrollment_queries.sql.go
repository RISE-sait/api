// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: enrollment_queries.sql

package db_event

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
)

const checkEventCapacityExists = `-- name: CheckEventCapacityExists :one
SELECT (coalesce(t.capacity, p.capacity) IS NOT NULL)::boolean
FROM events.events e
         LEFT JOIN athletic.teams t ON e.team_id = t.id
         LEFT JOIN program.programs p ON e.program_id = p.id
WHERE e.id = $1
`

func (q *Queries) CheckEventCapacityExists(ctx context.Context, id uuid.UUID) (bool, error) {
	row := q.db.QueryRowContext(ctx, checkEventCapacityExists, id)
	var column_1 bool
	err := row.Scan(&column_1)
	return column_1, err
}

const checkEventIsFull = `-- name: CheckEventIsFull :one
SELECT COUNT(ce.id) FILTER (
    WHERE ce.payment_status = 'paid'
        OR (ce.payment_status = 'pending' AND ce.payment_expired_at > NOW())
    ) >= COALESCE(p.capacity, t.capacity) AS is_full
FROM events.events e
         LEFT JOIN program.programs p ON e.program_id = p.id
         LEFT JOIN athletic.teams t ON e.team_id = t.id
         LEFT JOIN events.customer_enrollment ce ON e.id = ce.event_id
WHERE e.id = $1
GROUP BY p.capacity, t.capacity
`

func (q *Queries) CheckEventIsFull(ctx context.Context, id uuid.UUID) (bool, error) {
	row := q.db.QueryRowContext(ctx, checkEventIsFull, id)
	var is_full bool
	err := row.Scan(&is_full)
	return is_full, err
}

const checkProgramCapacityExists = `-- name: CheckProgramCapacityExists :one
SELECT (capacity IS NOT NULL)::boolean
FROM program.programs p
WHERE p.id = $1
`

func (q *Queries) CheckProgramCapacityExists(ctx context.Context, id uuid.UUID) (bool, error) {
	row := q.db.QueryRowContext(ctx, checkProgramCapacityExists, id)
	var column_1 bool
	err := row.Scan(&column_1)
	return column_1, err
}

const checkProgramIsFull = `-- name: CheckProgramIsFull :one
SELECT COUNT(ce.id) FILTER (
    WHERE ce.payment_status = 'paid'
        OR (ce.payment_status = 'pending' AND ce.payment_expired_at > CURRENT_TIMESTAMP))
           >= p.capacity
FROM program.programs p
         LEFT JOIN program.customer_enrollment ce ON p.id = ce.program_id
WHERE p.id = $1
GROUP BY p.capacity
`

func (q *Queries) CheckProgramIsFull(ctx context.Context, id uuid.UUID) (bool, error) {
	row := q.db.QueryRowContext(ctx, checkProgramIsFull, id)
	var column_1 bool
	err := row.Scan(&column_1)
	return column_1, err
}

const enrollCustomerInEvent = `-- name: EnrollCustomerInEvent :exec
INSERT INTO events.customer_enrollment (customer_id, event_id, payment_status)
VALUES ($1, $2, 'paid')
`

type EnrollCustomerInEventParams struct {
	CustomerID uuid.UUID `json:"customer_id"`
	EventID    uuid.UUID `json:"event_id"`
}

func (q *Queries) EnrollCustomerInEvent(ctx context.Context, arg EnrollCustomerInEventParams) error {
	_, err := q.db.ExecContext(ctx, enrollCustomerInEvent, arg.CustomerID, arg.EventID)
	return err
}

const enrollCustomerInMembershipPlan = `-- name: EnrollCustomerInMembershipPlan :exec
INSERT INTO users.customer_membership_plans (customer_id, membership_plan_id, status, start_date, renewal_date, next_billing_date, subscription_source, stripe_subscription_id)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
ON CONFLICT (customer_id, membership_plan_id)
DO UPDATE SET
    status = EXCLUDED.status,
    start_date = EXCLUDED.start_date,
    renewal_date = EXCLUDED.renewal_date,
    next_billing_date = EXCLUDED.next_billing_date,
    subscription_source = EXCLUDED.subscription_source,
    stripe_subscription_id = EXCLUDED.stripe_subscription_id,
    updated_at = CURRENT_TIMESTAMP
`

type EnrollCustomerInMembershipPlanParams struct {
	CustomerID           uuid.UUID                  `json:"customer_id"`
	MembershipPlanID     uuid.UUID                  `json:"membership_plan_id"`
	Status               MembershipMembershipStatus `json:"status"`
	StartDate            time.Time                  `json:"start_date"`
	RenewalDate          sql.NullTime               `json:"renewal_date"`
	NextBillingDate      sql.NullTime               `json:"next_billing_date"`
	SubscriptionSource   sql.NullString             `json:"subscription_source"`
	StripeSubscriptionID sql.NullString             `json:"stripe_subscription_id"`
}

func (q *Queries) EnrollCustomerInMembershipPlan(ctx context.Context, arg EnrollCustomerInMembershipPlanParams) error {
	_, err := q.db.ExecContext(ctx, enrollCustomerInMembershipPlan,
		arg.CustomerID,
		arg.MembershipPlanID,
		arg.Status,
		arg.StartDate,
		arg.RenewalDate,
		arg.NextBillingDate,
		arg.SubscriptionSource,
		arg.StripeSubscriptionID,
	)
	return err
}

const enrollCustomerInProgram = `-- name: EnrollCustomerInProgram :exec
WITH events AS (SELECT e.id
                         FROM events.events e
                         WHERE e.program_id = $1
                           AND e.start_at >= current_timestamp),
     event_inserts as (
         INSERT INTO events.customer_enrollment (customer_id, event_id, payment_status)
             SELECT $2, id, 'paid' FROM events)
INSERT
INTO program.customer_enrollment(customer_id, program_id, is_cancelled, payment_status)
VALUES ($2, $1, false, 'paid')
`

type EnrollCustomerInProgramParams struct {
	ProgramID  uuid.UUID `json:"program_id"`
	CustomerID uuid.UUID `json:"customer_id"`
}

func (q *Queries) EnrollCustomerInProgram(ctx context.Context, arg EnrollCustomerInProgramParams) error {
	_, err := q.db.ExecContext(ctx, enrollCustomerInProgram, arg.ProgramID, arg.CustomerID)
	return err
}

const getCustomerActiveMembershipPlans = `-- name: GetCustomerActiveMembershipPlans :many
SELECT customer_id, membership_plan_id, status, start_date, renewal_date, next_billing_date, stripe_subscription_id
FROM users.customer_membership_plans
WHERE customer_id = $1 AND status = 'active'
ORDER BY created_at DESC
`

type GetCustomerActiveMembershipPlansRow struct {
	CustomerID           uuid.UUID                  `json:"customer_id"`
	MembershipPlanID     uuid.UUID                  `json:"membership_plan_id"`
	Status               MembershipMembershipStatus `json:"status"`
	StartDate            time.Time                  `json:"start_date"`
	RenewalDate          sql.NullTime               `json:"renewal_date"`
	NextBillingDate      sql.NullTime               `json:"next_billing_date"`
	StripeSubscriptionID sql.NullString             `json:"stripe_subscription_id"`
}

func (q *Queries) GetCustomerActiveMembershipPlans(ctx context.Context, customerID uuid.UUID) ([]GetCustomerActiveMembershipPlansRow, error) {
	rows, err := q.db.QueryContext(ctx, getCustomerActiveMembershipPlans, customerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCustomerActiveMembershipPlansRow
	for rows.Next() {
		var i GetCustomerActiveMembershipPlansRow
		if err := rows.Scan(
			&i.CustomerID,
			&i.MembershipPlanID,
			&i.Status,
			&i.StartDate,
			&i.RenewalDate,
			&i.NextBillingDate,
			&i.StripeSubscriptionID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCustomerIsEnrolledInProgram = `-- name: GetCustomerIsEnrolledInProgram :one
SELECT (EXISTS (SELECT 1
                FROM program.customer_enrollment
                WHERE customer_id = $1
                  AND program_id = $2
                  AND payment_status = 'paid'))
`

type GetCustomerIsEnrolledInProgramParams struct {
	CustomerID uuid.UUID `json:"customer_id"`
	ProgramID  uuid.UUID `json:"program_id"`
}

func (q *Queries) GetCustomerIsEnrolledInProgram(ctx context.Context, arg GetCustomerIsEnrolledInProgramParams) (bool, error) {
	row := q.db.QueryRowContext(ctx, getCustomerIsEnrolledInProgram, arg.CustomerID, arg.ProgramID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const getMembershipPlanByCustomerId = `-- name: GetMembershipPlanByCustomerId :one
SELECT customer_id, membership_plan_id, status
FROM users.customer_membership_plans
WHERE customer_id = $1 AND subscription_source = 'stripe'
ORDER BY created_at DESC
LIMIT 1
`

type GetMembershipPlanByCustomerIdRow struct {
	CustomerID       uuid.UUID                  `json:"customer_id"`
	MembershipPlanID uuid.UUID                  `json:"membership_plan_id"`
	Status           MembershipMembershipStatus `json:"status"`
}

func (q *Queries) GetMembershipPlanByCustomerId(ctx context.Context, customerID uuid.UUID) (GetMembershipPlanByCustomerIdRow, error) {
	row := q.db.QueryRowContext(ctx, getMembershipPlanByCustomerId, customerID)
	var i GetMembershipPlanByCustomerIdRow
	err := row.Scan(&i.CustomerID, &i.MembershipPlanID, &i.Status)
	return i, err
}

const getTeamOfEvent = `-- name: GetTeamOfEvent :one
SELECT t.id
FROM events.events e
         LEFT JOIN athletic.teams t ON e.team_id = t.id
WHERE e.id = $1
`

func (q *Queries) GetTeamOfEvent(ctx context.Context, eventID uuid.UUID) (uuid.NullUUID, error) {
	row := q.db.QueryRowContext(ctx, getTeamOfEvent, eventID)
	var id uuid.NullUUID
	err := row.Scan(&id)
	return id, err
}

const removeCustomerFromEvent = `-- name: RemoveCustomerFromEvent :execrows
DELETE FROM events.customer_enrollment
WHERE customer_id = $1
  AND event_id = $2
`

type RemoveCustomerFromEventParams struct {
	CustomerID uuid.UUID `json:"customer_id"`
	EventID    uuid.UUID `json:"event_id"`
}

func (q *Queries) RemoveCustomerFromEvent(ctx context.Context, arg RemoveCustomerFromEventParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, removeCustomerFromEvent, arg.CustomerID, arg.EventID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const reserveSeatInEvent = `-- name: ReserveSeatInEvent :execrows
INSERT INTO events.customer_enrollment
    (customer_id, event_id, payment_expired_at, payment_status)
VALUES ($1, $2, CURRENT_TIMESTAMP + interval '10 minute', 'pending')
ON CONFLICT (customer_id, event_id)
    DO UPDATE SET payment_expired_at = EXCLUDED.payment_expired_at,
                  payment_status     = EXCLUDED.payment_status
WHERE events.customer_enrollment.payment_status != 'paid'
`

type ReserveSeatInEventParams struct {
	CustomerID uuid.UUID `json:"customer_id"`
	EventID    uuid.UUID `json:"event_id"`
}

func (q *Queries) ReserveSeatInEvent(ctx context.Context, arg ReserveSeatInEventParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, reserveSeatInEvent, arg.CustomerID, arg.EventID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const reserveSeatInProgram = `-- name: ReserveSeatInProgram :execrows
INSERT INTO program.customer_enrollment
    (customer_id, program_id, payment_expired_at, payment_status)
VALUES ($1, $2, CURRENT_TIMESTAMP + interval '10 minute', 'pending')
ON CONFLICT (customer_id, program_id)
    DO UPDATE SET payment_expired_at = EXCLUDED.payment_expired_at,
                  payment_status     = EXCLUDED.payment_status
WHERE program.customer_enrollment.payment_status != 'paid'
`

type ReserveSeatInProgramParams struct {
	CustomerID uuid.UUID `json:"customer_id"`
	ProgramID  uuid.UUID `json:"program_id"`
}

func (q *Queries) ReserveSeatInProgram(ctx context.Context, arg ReserveSeatInProgramParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, reserveSeatInProgram, arg.CustomerID, arg.ProgramID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const unEnrollCustomerFromEvent = `-- name: UnEnrollCustomerFromEvent :execrows
UPDATE events.customer_enrollment
SET is_cancelled = true
WHERE customer_id = $1
  AND event_id = $2
`

type UnEnrollCustomerFromEventParams struct {
	CustomerID uuid.UUID `json:"customer_id"`
	EventID    uuid.UUID `json:"event_id"`
}

func (q *Queries) UnEnrollCustomerFromEvent(ctx context.Context, arg UnEnrollCustomerFromEventParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, unEnrollCustomerFromEvent, arg.CustomerID, arg.EventID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const updateMembershipPlanByCustomerId = `-- name: UpdateMembershipPlanByCustomerId :execrows
UPDATE users.customer_membership_plans
SET status = $1, updated_at = CURRENT_TIMESTAMP
WHERE customer_id = $2 AND subscription_source = 'stripe'
`

type UpdateMembershipPlanByCustomerIdParams struct {
	Status     MembershipMembershipStatus `json:"status"`
	CustomerID uuid.UUID                  `json:"customer_id"`
}

func (q *Queries) UpdateMembershipPlanByCustomerId(ctx context.Context, arg UpdateMembershipPlanByCustomerIdParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, updateMembershipPlanByCustomerId, arg.Status, arg.CustomerID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const updateMembershipPlanStatus = `-- name: UpdateMembershipPlanStatus :execrows
UPDATE users.customer_membership_plans 
SET status = $1, updated_at = CURRENT_TIMESTAMP
WHERE customer_id = $2 AND membership_plan_id = $3
`

type UpdateMembershipPlanStatusParams struct {
	Status           MembershipMembershipStatus `json:"status"`
	CustomerID       uuid.UUID                  `json:"customer_id"`
	MembershipPlanID uuid.UUID                  `json:"membership_plan_id"`
}

func (q *Queries) UpdateMembershipPlanStatus(ctx context.Context, arg UpdateMembershipPlanStatusParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, updateMembershipPlanStatus, arg.Status, arg.CustomerID, arg.MembershipPlanID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const updateMembershipPlanStatusByStripeSubscription = `-- name: UpdateMembershipPlanStatusByStripeSubscription :execrows
UPDATE users.customer_membership_plans 
SET status = $1, updated_at = CURRENT_TIMESTAMP
WHERE customer_id = $2 AND subscription_source = 'stripe'
`

type UpdateMembershipPlanStatusByStripeSubscriptionParams struct {
	Status     MembershipMembershipStatus `json:"status"`
	CustomerID uuid.UUID                  `json:"customer_id"`
}

func (q *Queries) UpdateMembershipPlanStatusByStripeSubscription(ctx context.Context, arg UpdateMembershipPlanStatusByStripeSubscriptionParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, updateMembershipPlanStatusByStripeSubscription, arg.Status, arg.CustomerID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const updateMembershipStatusAndNextBilling = `-- name: UpdateMembershipStatusAndNextBilling :execrows
UPDATE users.customer_membership_plans
SET status = $1, next_billing_date = $2, updated_at = CURRENT_TIMESTAMP
WHERE customer_id = $3 AND subscription_source = 'stripe'
`

type UpdateMembershipStatusAndNextBillingParams struct {
	Status          MembershipMembershipStatus `json:"status"`
	NextBillingDate sql.NullTime               `json:"next_billing_date"`
	CustomerID      uuid.UUID                  `json:"customer_id"`
}

func (q *Queries) UpdateMembershipStatusAndNextBilling(ctx context.Context, arg UpdateMembershipStatusAndNextBillingParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, updateMembershipStatusAndNextBilling, arg.Status, arg.NextBillingDate, arg.CustomerID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const updateSeatReservationStatusInEvent = `-- name: UpdateSeatReservationStatusInEvent :execrows
UPDATE events.customer_enrollment
SET payment_status = $1
WHERE customer_id = $2
  AND event_id = $3
`

type UpdateSeatReservationStatusInEventParams struct {
	PaymentStatus PaymentStatus `json:"payment_status"`
	CustomerID    uuid.UUID     `json:"customer_id"`
	EventID       uuid.UUID     `json:"event_id"`
}

func (q *Queries) UpdateSeatReservationStatusInEvent(ctx context.Context, arg UpdateSeatReservationStatusInEventParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, updateSeatReservationStatusInEvent, arg.PaymentStatus, arg.CustomerID, arg.EventID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const updateSeatReservationStatusInProgram = `-- name: UpdateSeatReservationStatusInProgram :execrows
UPDATE program.customer_enrollment
SET payment_status = $1
WHERE customer_id = $2
  AND program_id = $3
`

type UpdateSeatReservationStatusInProgramParams struct {
	PaymentStatus PaymentStatus `json:"payment_status"`
	CustomerID    uuid.UUID     `json:"customer_id"`
	ProgramID     uuid.UUID     `json:"program_id"`
}

func (q *Queries) UpdateSeatReservationStatusInProgram(ctx context.Context, arg UpdateSeatReservationStatusInProgramParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, updateSeatReservationStatusInProgram, arg.PaymentStatus, arg.CustomerID, arg.ProgramID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}
