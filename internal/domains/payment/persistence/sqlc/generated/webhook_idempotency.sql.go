// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: webhook_idempotency.sql

package db_payment

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
	"github.com/sqlc-dev/pqtype"
)

const checkWebhookProcessed = `-- name: CheckWebhookProcessed :one
SELECT EXISTS(
    SELECT 1 FROM payment.webhook_events
    WHERE event_id = $1
    AND processed_at > NOW() - INTERVAL '24 hours'
) AS is_processed
`

func (q *Queries) CheckWebhookProcessed(ctx context.Context, eventID string) (bool, error) {
	row := q.db.QueryRowContext(ctx, checkWebhookProcessed, eventID)
	var is_processed bool
	err := row.Scan(&is_processed)
	return is_processed, err
}

const cleanupOldWebhookEvents = `-- name: CleanupOldWebhookEvents :exec
DELETE FROM payment.webhook_events
WHERE processed_at < NOW() - INTERVAL '7 days'
`

func (q *Queries) CleanupOldWebhookEvents(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, cleanupOldWebhookEvents)
	return err
}

const getFailedWebhooks = `-- name: GetFailedWebhooks :many
SELECT id, event_id, event_type, payload, error_message, attempts, status, created_at, resolved_at FROM payment.failed_webhooks
WHERE status = 'failed'
ORDER BY created_at DESC
LIMIT $1 OFFSET $2
`

type GetFailedWebhooksParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) GetFailedWebhooks(ctx context.Context, arg GetFailedWebhooksParams) ([]PaymentFailedWebhook, error) {
	rows, err := q.db.QueryContext(ctx, getFailedWebhooks, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PaymentFailedWebhook
	for rows.Next() {
		var i PaymentFailedWebhook
		if err := rows.Scan(
			&i.ID,
			&i.EventID,
			&i.EventType,
			&i.Payload,
			&i.ErrorMessage,
			&i.Attempts,
			&i.Status,
			&i.CreatedAt,
			&i.ResolvedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPendingFailedRefunds = `-- name: GetPendingFailedRefunds :many
SELECT id, customer_id, event_id, credit_amount, error_message, retry_count, status, created_at, updated_at, resolved_at FROM payment.failed_refunds
WHERE status = 'pending' AND retry_count < 5
ORDER BY created_at ASC
LIMIT $1
`

func (q *Queries) GetPendingFailedRefunds(ctx context.Context, limit int32) ([]PaymentFailedRefund, error) {
	rows, err := q.db.QueryContext(ctx, getPendingFailedRefunds, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PaymentFailedRefund
	for rows.Next() {
		var i PaymentFailedRefund
		if err := rows.Scan(
			&i.ID,
			&i.CustomerID,
			&i.EventID,
			&i.CreditAmount,
			&i.ErrorMessage,
			&i.RetryCount,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ResolvedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ignoreFailedWebhook = `-- name: IgnoreFailedWebhook :exec
UPDATE payment.failed_webhooks
SET status = 'ignored', resolved_at = NOW()
WHERE id = $1
`

func (q *Queries) IgnoreFailedWebhook(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, ignoreFailedWebhook, id)
	return err
}

const insertFailedRefund = `-- name: InsertFailedRefund :one
INSERT INTO payment.failed_refunds (customer_id, event_id, credit_amount, error_message, status)
VALUES ($1, $2, $3, $4, 'pending')
RETURNING id, customer_id, event_id, credit_amount, error_message, retry_count, status, created_at, updated_at, resolved_at
`

type InsertFailedRefundParams struct {
	CustomerID   uuid.UUID      `json:"customer_id"`
	EventID      uuid.NullUUID  `json:"event_id"`
	CreditAmount int32          `json:"credit_amount"`
	ErrorMessage sql.NullString `json:"error_message"`
}

func (q *Queries) InsertFailedRefund(ctx context.Context, arg InsertFailedRefundParams) (PaymentFailedRefund, error) {
	row := q.db.QueryRowContext(ctx, insertFailedRefund,
		arg.CustomerID,
		arg.EventID,
		arg.CreditAmount,
		arg.ErrorMessage,
	)
	var i PaymentFailedRefund
	err := row.Scan(
		&i.ID,
		&i.CustomerID,
		&i.EventID,
		&i.CreditAmount,
		&i.ErrorMessage,
		&i.RetryCount,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ResolvedAt,
	)
	return i, err
}

const insertFailedWebhook = `-- name: InsertFailedWebhook :one
INSERT INTO payment.failed_webhooks (event_id, event_type, payload, error_message, attempts)
VALUES ($1, $2, $3, $4, $5)
RETURNING id, event_id, event_type, payload, error_message, attempts, status, created_at, resolved_at
`

type InsertFailedWebhookParams struct {
	EventID      string                `json:"event_id"`
	EventType    string                `json:"event_type"`
	Payload      pqtype.NullRawMessage `json:"payload"`
	ErrorMessage sql.NullString        `json:"error_message"`
	Attempts     sql.NullInt32         `json:"attempts"`
}

func (q *Queries) InsertFailedWebhook(ctx context.Context, arg InsertFailedWebhookParams) (PaymentFailedWebhook, error) {
	row := q.db.QueryRowContext(ctx, insertFailedWebhook,
		arg.EventID,
		arg.EventType,
		arg.Payload,
		arg.ErrorMessage,
		arg.Attempts,
	)
	var i PaymentFailedWebhook
	err := row.Scan(
		&i.ID,
		&i.EventID,
		&i.EventType,
		&i.Payload,
		&i.ErrorMessage,
		&i.Attempts,
		&i.Status,
		&i.CreatedAt,
		&i.ResolvedAt,
	)
	return i, err
}

const markFailedRefundFailed = `-- name: MarkFailedRefundFailed :exec
UPDATE payment.failed_refunds
SET status = 'failed', updated_at = NOW()
WHERE id = $1
`

func (q *Queries) MarkFailedRefundFailed(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, markFailedRefundFailed, id)
	return err
}

const markWebhookProcessed = `-- name: MarkWebhookProcessed :exec
INSERT INTO payment.webhook_events (event_id, event_type, processed_at, status)
VALUES ($1, $2, NOW(), 'processed')
ON CONFLICT (event_id) DO NOTHING
`

type MarkWebhookProcessedParams struct {
	EventID   string `json:"event_id"`
	EventType string `json:"event_type"`
}

func (q *Queries) MarkWebhookProcessed(ctx context.Context, arg MarkWebhookProcessedParams) error {
	_, err := q.db.ExecContext(ctx, markWebhookProcessed, arg.EventID, arg.EventType)
	return err
}

const resolveFailedRefund = `-- name: ResolveFailedRefund :exec
UPDATE payment.failed_refunds
SET status = 'resolved', resolved_at = NOW(), updated_at = NOW()
WHERE id = $1
`

func (q *Queries) ResolveFailedRefund(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, resolveFailedRefund, id)
	return err
}

const resolveFailedWebhook = `-- name: ResolveFailedWebhook :exec
UPDATE payment.failed_webhooks
SET status = 'resolved', resolved_at = NOW()
WHERE id = $1
`

func (q *Queries) ResolveFailedWebhook(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, resolveFailedWebhook, id)
	return err
}

const updateFailedRefundRetry = `-- name: UpdateFailedRefundRetry :exec
UPDATE payment.failed_refunds
SET retry_count = retry_count + 1, updated_at = NOW()
WHERE id = $1
`

func (q *Queries) UpdateFailedRefundRetry(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, updateFailedRefundRetry, id)
	return err
}
