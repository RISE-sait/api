// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: payment_tracking.sql

package db_payment

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
	"github.com/shopspring/decimal"
	"github.com/sqlc-dev/pqtype"
)

const countPaymentTransactions = `-- name: CountPaymentTransactions :one
SELECT COUNT(*) FROM payments.payment_transactions
WHERE
    ($1::uuid IS NULL OR customer_id = $1) AND
    ($2::text IS NULL OR transaction_type = $2) AND
    ($3::text IS NULL OR payment_status = $3) AND
    ($4::timestamptz IS NULL OR transaction_date >= $4) AND
    ($5::timestamptz IS NULL OR transaction_date <= $5) AND
    ($6::uuid IS NULL OR subsidy_id = $6)
`

type CountPaymentTransactionsParams struct {
	CustomerID      uuid.NullUUID  `json:"customer_id"`
	TransactionType sql.NullString `json:"transaction_type"`
	PaymentStatus   sql.NullString `json:"payment_status"`
	StartDate       sql.NullTime   `json:"start_date"`
	EndDate         sql.NullTime   `json:"end_date"`
	SubsidyID       uuid.NullUUID  `json:"subsidy_id"`
}

func (q *Queries) CountPaymentTransactions(ctx context.Context, arg CountPaymentTransactionsParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, countPaymentTransactions,
		arg.CustomerID,
		arg.TransactionType,
		arg.PaymentStatus,
		arg.StartDate,
		arg.EndDate,
		arg.SubsidyID,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countPaymentTransactionsByCustomer = `-- name: CountPaymentTransactionsByCustomer :one
SELECT COUNT(*) FROM payments.payment_transactions
WHERE customer_id = $1
`

func (q *Queries) CountPaymentTransactionsByCustomer(ctx context.Context, customerID uuid.UUID) (int64, error) {
	row := q.db.QueryRowContext(ctx, countPaymentTransactionsByCustomer, customerID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createPaymentTransaction = `-- name: CreatePaymentTransaction :one
INSERT INTO payments.payment_transactions (
    customer_id,
    customer_email,
    customer_name,
    transaction_type,
    transaction_date,
    original_amount,
    discount_amount,
    subsidy_amount,
    customer_paid,
    membership_plan_id,
    program_id,
    event_id,
    credit_package_id,
    subsidy_id,
    discount_code_id,
    stripe_customer_id,
    stripe_subscription_id,
    stripe_invoice_id,
    stripe_payment_intent_id,
    stripe_checkout_session_id,
    payment_status,
    payment_method,
    currency,
    description,
    metadata,
    receipt_url,
    invoice_url,
    invoice_pdf_url
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10,
    $11, $12, $13, $14, $15, $16, $17, $18, $19, $20,
    $21, $22, $23, $24, $25, $26, $27, $28
) RETURNING id, customer_id, customer_email, customer_name, transaction_type, transaction_date, original_amount, discount_amount, subsidy_amount, customer_paid, membership_plan_id, program_id, event_id, credit_package_id, subsidy_id, discount_code_id, stripe_customer_id, stripe_subscription_id, stripe_invoice_id, stripe_payment_intent_id, stripe_checkout_session_id, payment_status, payment_method, currency, description, metadata, refunded_amount, refund_reason, refunded_at, created_at, updated_at, receipt_url, invoice_url, invoice_pdf_url
`

type CreatePaymentTransactionParams struct {
	CustomerID              uuid.UUID             `json:"customer_id"`
	CustomerEmail           string                `json:"customer_email"`
	CustomerName            string                `json:"customer_name"`
	TransactionType         string                `json:"transaction_type"`
	TransactionDate         time.Time             `json:"transaction_date"`
	OriginalAmount          decimal.Decimal       `json:"original_amount"`
	DiscountAmount          decimal.Decimal       `json:"discount_amount"`
	SubsidyAmount           decimal.Decimal       `json:"subsidy_amount"`
	CustomerPaid            decimal.Decimal       `json:"customer_paid"`
	MembershipPlanID        uuid.NullUUID         `json:"membership_plan_id"`
	ProgramID               uuid.NullUUID         `json:"program_id"`
	EventID                 uuid.NullUUID         `json:"event_id"`
	CreditPackageID         uuid.NullUUID         `json:"credit_package_id"`
	SubsidyID               uuid.NullUUID         `json:"subsidy_id"`
	DiscountCodeID          uuid.NullUUID         `json:"discount_code_id"`
	StripeCustomerID        sql.NullString        `json:"stripe_customer_id"`
	StripeSubscriptionID    sql.NullString        `json:"stripe_subscription_id"`
	StripeInvoiceID         sql.NullString        `json:"stripe_invoice_id"`
	StripePaymentIntentID   sql.NullString        `json:"stripe_payment_intent_id"`
	StripeCheckoutSessionID sql.NullString        `json:"stripe_checkout_session_id"`
	PaymentStatus           string                `json:"payment_status"`
	PaymentMethod           sql.NullString        `json:"payment_method"`
	Currency                sql.NullString        `json:"currency"`
	Description             sql.NullString        `json:"description"`
	Metadata                pqtype.NullRawMessage `json:"metadata"`
	ReceiptUrl              sql.NullString        `json:"receipt_url"`
	InvoiceUrl              sql.NullString        `json:"invoice_url"`
	InvoicePdfUrl           sql.NullString        `json:"invoice_pdf_url"`
}

func (q *Queries) CreatePaymentTransaction(ctx context.Context, arg CreatePaymentTransactionParams) (PaymentsPaymentTransaction, error) {
	row := q.db.QueryRowContext(ctx, createPaymentTransaction,
		arg.CustomerID,
		arg.CustomerEmail,
		arg.CustomerName,
		arg.TransactionType,
		arg.TransactionDate,
		arg.OriginalAmount,
		arg.DiscountAmount,
		arg.SubsidyAmount,
		arg.CustomerPaid,
		arg.MembershipPlanID,
		arg.ProgramID,
		arg.EventID,
		arg.CreditPackageID,
		arg.SubsidyID,
		arg.DiscountCodeID,
		arg.StripeCustomerID,
		arg.StripeSubscriptionID,
		arg.StripeInvoiceID,
		arg.StripePaymentIntentID,
		arg.StripeCheckoutSessionID,
		arg.PaymentStatus,
		arg.PaymentMethod,
		arg.Currency,
		arg.Description,
		arg.Metadata,
		arg.ReceiptUrl,
		arg.InvoiceUrl,
		arg.InvoicePdfUrl,
	)
	var i PaymentsPaymentTransaction
	err := row.Scan(
		&i.ID,
		&i.CustomerID,
		&i.CustomerEmail,
		&i.CustomerName,
		&i.TransactionType,
		&i.TransactionDate,
		&i.OriginalAmount,
		&i.DiscountAmount,
		&i.SubsidyAmount,
		&i.CustomerPaid,
		&i.MembershipPlanID,
		&i.ProgramID,
		&i.EventID,
		&i.CreditPackageID,
		&i.SubsidyID,
		&i.DiscountCodeID,
		&i.StripeCustomerID,
		&i.StripeSubscriptionID,
		&i.StripeInvoiceID,
		&i.StripePaymentIntentID,
		&i.StripeCheckoutSessionID,
		&i.PaymentStatus,
		&i.PaymentMethod,
		&i.Currency,
		&i.Description,
		&i.Metadata,
		&i.RefundedAmount,
		&i.RefundReason,
		&i.RefundedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ReceiptUrl,
		&i.InvoiceUrl,
		&i.InvoicePdfUrl,
	)
	return i, err
}

const exportPaymentTransactions = `-- name: ExportPaymentTransactions :many
SELECT
    id,
    customer_id,
    customer_email,
    customer_name,
    transaction_type,
    transaction_date,
    original_amount,
    discount_amount,
    subsidy_amount,
    customer_paid,
    stripe_invoice_id,
    payment_status,
    payment_method,
    currency,
    description,
    receipt_url,
    invoice_url,
    invoice_pdf_url,
    created_at
FROM payments.payment_transactions
WHERE
    ($1::timestamptz IS NULL OR transaction_date >= $1) AND
    ($2::timestamptz IS NULL OR transaction_date <= $2) AND
    ($3::text IS NULL OR transaction_type = $3) AND
    ($4::text IS NULL OR payment_status = $4)
ORDER BY transaction_date DESC
`

type ExportPaymentTransactionsParams struct {
	StartDate       sql.NullTime   `json:"start_date"`
	EndDate         sql.NullTime   `json:"end_date"`
	TransactionType sql.NullString `json:"transaction_type"`
	PaymentStatus   sql.NullString `json:"payment_status"`
}

type ExportPaymentTransactionsRow struct {
	ID              uuid.UUID       `json:"id"`
	CustomerID      uuid.UUID       `json:"customer_id"`
	CustomerEmail   string          `json:"customer_email"`
	CustomerName    string          `json:"customer_name"`
	TransactionType string          `json:"transaction_type"`
	TransactionDate time.Time       `json:"transaction_date"`
	OriginalAmount  decimal.Decimal `json:"original_amount"`
	DiscountAmount  decimal.Decimal `json:"discount_amount"`
	SubsidyAmount   decimal.Decimal `json:"subsidy_amount"`
	CustomerPaid    decimal.Decimal `json:"customer_paid"`
	StripeInvoiceID sql.NullString  `json:"stripe_invoice_id"`
	PaymentStatus   string          `json:"payment_status"`
	PaymentMethod   sql.NullString  `json:"payment_method"`
	Currency        sql.NullString  `json:"currency"`
	Description     sql.NullString  `json:"description"`
	ReceiptUrl      sql.NullString  `json:"receipt_url"`
	InvoiceUrl      sql.NullString  `json:"invoice_url"`
	InvoicePdfUrl   sql.NullString  `json:"invoice_pdf_url"`
	CreatedAt       time.Time       `json:"created_at"`
}

func (q *Queries) ExportPaymentTransactions(ctx context.Context, arg ExportPaymentTransactionsParams) ([]ExportPaymentTransactionsRow, error) {
	rows, err := q.db.QueryContext(ctx, exportPaymentTransactions,
		arg.StartDate,
		arg.EndDate,
		arg.TransactionType,
		arg.PaymentStatus,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ExportPaymentTransactionsRow
	for rows.Next() {
		var i ExportPaymentTransactionsRow
		if err := rows.Scan(
			&i.ID,
			&i.CustomerID,
			&i.CustomerEmail,
			&i.CustomerName,
			&i.TransactionType,
			&i.TransactionDate,
			&i.OriginalAmount,
			&i.DiscountAmount,
			&i.SubsidyAmount,
			&i.CustomerPaid,
			&i.StripeInvoiceID,
			&i.PaymentStatus,
			&i.PaymentMethod,
			&i.Currency,
			&i.Description,
			&i.ReceiptUrl,
			&i.InvoiceUrl,
			&i.InvoicePdfUrl,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPaymentSummary = `-- name: GetPaymentSummary :one
SELECT
    COUNT(*) as total_transactions,
    COALESCE(SUM(original_amount), 0) as total_original_amount,
    COALESCE(SUM(discount_amount), 0) as total_discount_amount,
    COALESCE(SUM(subsidy_amount), 0) as total_subsidy_amount,
    COALESCE(SUM(customer_paid), 0) as total_customer_paid,
    COALESCE(SUM(refunded_amount), 0) as total_refunded_amount
FROM payments.payment_transactions
WHERE
    ($1::timestamptz IS NULL OR transaction_date >= $1) AND
    ($2::timestamptz IS NULL OR transaction_date <= $2) AND
    ($3::text IS NULL OR transaction_type = $3) AND
    ($4::text IS NULL OR payment_status = $4)
`

type GetPaymentSummaryParams struct {
	StartDate       sql.NullTime   `json:"start_date"`
	EndDate         sql.NullTime   `json:"end_date"`
	TransactionType sql.NullString `json:"transaction_type"`
	PaymentStatus   sql.NullString `json:"payment_status"`
}

type GetPaymentSummaryRow struct {
	TotalTransactions   int64       `json:"total_transactions"`
	TotalOriginalAmount interface{} `json:"total_original_amount"`
	TotalDiscountAmount interface{} `json:"total_discount_amount"`
	TotalSubsidyAmount  interface{} `json:"total_subsidy_amount"`
	TotalCustomerPaid   interface{} `json:"total_customer_paid"`
	TotalRefundedAmount interface{} `json:"total_refunded_amount"`
}

func (q *Queries) GetPaymentSummary(ctx context.Context, arg GetPaymentSummaryParams) (GetPaymentSummaryRow, error) {
	row := q.db.QueryRowContext(ctx, getPaymentSummary,
		arg.StartDate,
		arg.EndDate,
		arg.TransactionType,
		arg.PaymentStatus,
	)
	var i GetPaymentSummaryRow
	err := row.Scan(
		&i.TotalTransactions,
		&i.TotalOriginalAmount,
		&i.TotalDiscountAmount,
		&i.TotalSubsidyAmount,
		&i.TotalCustomerPaid,
		&i.TotalRefundedAmount,
	)
	return i, err
}

const getPaymentSummaryByType = `-- name: GetPaymentSummaryByType :many
SELECT
    transaction_type,
    COUNT(*) as transaction_count,
    COALESCE(SUM(original_amount), 0) as total_original_amount,
    COALESCE(SUM(discount_amount), 0) as total_discount_amount,
    COALESCE(SUM(subsidy_amount), 0) as total_subsidy_amount,
    COALESCE(SUM(customer_paid), 0) as total_customer_paid
FROM payments.payment_transactions
WHERE
    ($1::timestamptz IS NULL OR transaction_date >= $1) AND
    ($2::timestamptz IS NULL OR transaction_date <= $2) AND
    payment_status = 'completed'
GROUP BY transaction_type
ORDER BY total_customer_paid DESC
`

type GetPaymentSummaryByTypeParams struct {
	StartDate sql.NullTime `json:"start_date"`
	EndDate   sql.NullTime `json:"end_date"`
}

type GetPaymentSummaryByTypeRow struct {
	TransactionType     string      `json:"transaction_type"`
	TransactionCount    int64       `json:"transaction_count"`
	TotalOriginalAmount interface{} `json:"total_original_amount"`
	TotalDiscountAmount interface{} `json:"total_discount_amount"`
	TotalSubsidyAmount  interface{} `json:"total_subsidy_amount"`
	TotalCustomerPaid   interface{} `json:"total_customer_paid"`
}

func (q *Queries) GetPaymentSummaryByType(ctx context.Context, arg GetPaymentSummaryByTypeParams) ([]GetPaymentSummaryByTypeRow, error) {
	rows, err := q.db.QueryContext(ctx, getPaymentSummaryByType, arg.StartDate, arg.EndDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPaymentSummaryByTypeRow
	for rows.Next() {
		var i GetPaymentSummaryByTypeRow
		if err := rows.Scan(
			&i.TransactionType,
			&i.TransactionCount,
			&i.TotalOriginalAmount,
			&i.TotalDiscountAmount,
			&i.TotalSubsidyAmount,
			&i.TotalCustomerPaid,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPaymentTransaction = `-- name: GetPaymentTransaction :one
SELECT id, customer_id, customer_email, customer_name, transaction_type, transaction_date, original_amount, discount_amount, subsidy_amount, customer_paid, membership_plan_id, program_id, event_id, credit_package_id, subsidy_id, discount_code_id, stripe_customer_id, stripe_subscription_id, stripe_invoice_id, stripe_payment_intent_id, stripe_checkout_session_id, payment_status, payment_method, currency, description, metadata, refunded_amount, refund_reason, refunded_at, created_at, updated_at, receipt_url, invoice_url, invoice_pdf_url FROM payments.payment_transactions
WHERE id = $1
`

func (q *Queries) GetPaymentTransaction(ctx context.Context, id uuid.UUID) (PaymentsPaymentTransaction, error) {
	row := q.db.QueryRowContext(ctx, getPaymentTransaction, id)
	var i PaymentsPaymentTransaction
	err := row.Scan(
		&i.ID,
		&i.CustomerID,
		&i.CustomerEmail,
		&i.CustomerName,
		&i.TransactionType,
		&i.TransactionDate,
		&i.OriginalAmount,
		&i.DiscountAmount,
		&i.SubsidyAmount,
		&i.CustomerPaid,
		&i.MembershipPlanID,
		&i.ProgramID,
		&i.EventID,
		&i.CreditPackageID,
		&i.SubsidyID,
		&i.DiscountCodeID,
		&i.StripeCustomerID,
		&i.StripeSubscriptionID,
		&i.StripeInvoiceID,
		&i.StripePaymentIntentID,
		&i.StripeCheckoutSessionID,
		&i.PaymentStatus,
		&i.PaymentMethod,
		&i.Currency,
		&i.Description,
		&i.Metadata,
		&i.RefundedAmount,
		&i.RefundReason,
		&i.RefundedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ReceiptUrl,
		&i.InvoiceUrl,
		&i.InvoicePdfUrl,
	)
	return i, err
}

const getPaymentTransactionByStripeCheckoutSession = `-- name: GetPaymentTransactionByStripeCheckoutSession :one
SELECT id, customer_id, customer_email, customer_name, transaction_type, transaction_date, original_amount, discount_amount, subsidy_amount, customer_paid, membership_plan_id, program_id, event_id, credit_package_id, subsidy_id, discount_code_id, stripe_customer_id, stripe_subscription_id, stripe_invoice_id, stripe_payment_intent_id, stripe_checkout_session_id, payment_status, payment_method, currency, description, metadata, refunded_amount, refund_reason, refunded_at, created_at, updated_at, receipt_url, invoice_url, invoice_pdf_url FROM payments.payment_transactions
WHERE stripe_checkout_session_id = $1
LIMIT 1
`

func (q *Queries) GetPaymentTransactionByStripeCheckoutSession(ctx context.Context, stripeCheckoutSessionID sql.NullString) (PaymentsPaymentTransaction, error) {
	row := q.db.QueryRowContext(ctx, getPaymentTransactionByStripeCheckoutSession, stripeCheckoutSessionID)
	var i PaymentsPaymentTransaction
	err := row.Scan(
		&i.ID,
		&i.CustomerID,
		&i.CustomerEmail,
		&i.CustomerName,
		&i.TransactionType,
		&i.TransactionDate,
		&i.OriginalAmount,
		&i.DiscountAmount,
		&i.SubsidyAmount,
		&i.CustomerPaid,
		&i.MembershipPlanID,
		&i.ProgramID,
		&i.EventID,
		&i.CreditPackageID,
		&i.SubsidyID,
		&i.DiscountCodeID,
		&i.StripeCustomerID,
		&i.StripeSubscriptionID,
		&i.StripeInvoiceID,
		&i.StripePaymentIntentID,
		&i.StripeCheckoutSessionID,
		&i.PaymentStatus,
		&i.PaymentMethod,
		&i.Currency,
		&i.Description,
		&i.Metadata,
		&i.RefundedAmount,
		&i.RefundReason,
		&i.RefundedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ReceiptUrl,
		&i.InvoiceUrl,
		&i.InvoicePdfUrl,
	)
	return i, err
}

const getPaymentTransactionByStripeInvoice = `-- name: GetPaymentTransactionByStripeInvoice :one
SELECT id, customer_id, customer_email, customer_name, transaction_type, transaction_date, original_amount, discount_amount, subsidy_amount, customer_paid, membership_plan_id, program_id, event_id, credit_package_id, subsidy_id, discount_code_id, stripe_customer_id, stripe_subscription_id, stripe_invoice_id, stripe_payment_intent_id, stripe_checkout_session_id, payment_status, payment_method, currency, description, metadata, refunded_amount, refund_reason, refunded_at, created_at, updated_at, receipt_url, invoice_url, invoice_pdf_url FROM payments.payment_transactions
WHERE stripe_invoice_id = $1
LIMIT 1
`

func (q *Queries) GetPaymentTransactionByStripeInvoice(ctx context.Context, stripeInvoiceID sql.NullString) (PaymentsPaymentTransaction, error) {
	row := q.db.QueryRowContext(ctx, getPaymentTransactionByStripeInvoice, stripeInvoiceID)
	var i PaymentsPaymentTransaction
	err := row.Scan(
		&i.ID,
		&i.CustomerID,
		&i.CustomerEmail,
		&i.CustomerName,
		&i.TransactionType,
		&i.TransactionDate,
		&i.OriginalAmount,
		&i.DiscountAmount,
		&i.SubsidyAmount,
		&i.CustomerPaid,
		&i.MembershipPlanID,
		&i.ProgramID,
		&i.EventID,
		&i.CreditPackageID,
		&i.SubsidyID,
		&i.DiscountCodeID,
		&i.StripeCustomerID,
		&i.StripeSubscriptionID,
		&i.StripeInvoiceID,
		&i.StripePaymentIntentID,
		&i.StripeCheckoutSessionID,
		&i.PaymentStatus,
		&i.PaymentMethod,
		&i.Currency,
		&i.Description,
		&i.Metadata,
		&i.RefundedAmount,
		&i.RefundReason,
		&i.RefundedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ReceiptUrl,
		&i.InvoiceUrl,
		&i.InvoicePdfUrl,
	)
	return i, err
}

const getPaymentTransactionByStripeSubscription = `-- name: GetPaymentTransactionByStripeSubscription :one
SELECT id, customer_id, customer_email, customer_name, transaction_type, transaction_date, original_amount, discount_amount, subsidy_amount, customer_paid, membership_plan_id, program_id, event_id, credit_package_id, subsidy_id, discount_code_id, stripe_customer_id, stripe_subscription_id, stripe_invoice_id, stripe_payment_intent_id, stripe_checkout_session_id, payment_status, payment_method, currency, description, metadata, refunded_amount, refund_reason, refunded_at, created_at, updated_at, receipt_url, invoice_url, invoice_pdf_url FROM payments.payment_transactions
WHERE stripe_subscription_id = $1
ORDER BY transaction_date DESC
LIMIT 1
`

func (q *Queries) GetPaymentTransactionByStripeSubscription(ctx context.Context, stripeSubscriptionID sql.NullString) (PaymentsPaymentTransaction, error) {
	row := q.db.QueryRowContext(ctx, getPaymentTransactionByStripeSubscription, stripeSubscriptionID)
	var i PaymentsPaymentTransaction
	err := row.Scan(
		&i.ID,
		&i.CustomerID,
		&i.CustomerEmail,
		&i.CustomerName,
		&i.TransactionType,
		&i.TransactionDate,
		&i.OriginalAmount,
		&i.DiscountAmount,
		&i.SubsidyAmount,
		&i.CustomerPaid,
		&i.MembershipPlanID,
		&i.ProgramID,
		&i.EventID,
		&i.CreditPackageID,
		&i.SubsidyID,
		&i.DiscountCodeID,
		&i.StripeCustomerID,
		&i.StripeSubscriptionID,
		&i.StripeInvoiceID,
		&i.StripePaymentIntentID,
		&i.StripeCheckoutSessionID,
		&i.PaymentStatus,
		&i.PaymentMethod,
		&i.Currency,
		&i.Description,
		&i.Metadata,
		&i.RefundedAmount,
		&i.RefundReason,
		&i.RefundedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ReceiptUrl,
		&i.InvoiceUrl,
		&i.InvoicePdfUrl,
	)
	return i, err
}

const getSubsidyUsageSummary = `-- name: GetSubsidyUsageSummary :one
SELECT
    COUNT(*) as transactions_with_subsidy,
    COALESCE(SUM(subsidy_amount), 0) as total_subsidy_used
FROM payments.payment_transactions
WHERE
    subsidy_amount > 0 AND
    payment_status = 'completed' AND
    ($1::timestamptz IS NULL OR transaction_date >= $1) AND
    ($2::timestamptz IS NULL OR transaction_date <= $2)
`

type GetSubsidyUsageSummaryParams struct {
	StartDate sql.NullTime `json:"start_date"`
	EndDate   sql.NullTime `json:"end_date"`
}

type GetSubsidyUsageSummaryRow struct {
	TransactionsWithSubsidy int64       `json:"transactions_with_subsidy"`
	TotalSubsidyUsed        interface{} `json:"total_subsidy_used"`
}

func (q *Queries) GetSubsidyUsageSummary(ctx context.Context, arg GetSubsidyUsageSummaryParams) (GetSubsidyUsageSummaryRow, error) {
	row := q.db.QueryRowContext(ctx, getSubsidyUsageSummary, arg.StartDate, arg.EndDate)
	var i GetSubsidyUsageSummaryRow
	err := row.Scan(&i.TransactionsWithSubsidy, &i.TotalSubsidyUsed)
	return i, err
}

const getTransactionsForBackfill = `-- name: GetTransactionsForBackfill :many
SELECT id, stripe_checkout_session_id, stripe_payment_intent_id, stripe_invoice_id
FROM payments.payment_transactions
WHERE (stripe_checkout_session_id IS NOT NULL OR stripe_payment_intent_id IS NOT NULL OR stripe_invoice_id IS NOT NULL)
  AND receipt_url IS NULL
  AND invoice_url IS NULL
`

type GetTransactionsForBackfillRow struct {
	ID                      uuid.UUID      `json:"id"`
	StripeCheckoutSessionID sql.NullString `json:"stripe_checkout_session_id"`
	StripePaymentIntentID   sql.NullString `json:"stripe_payment_intent_id"`
	StripeInvoiceID         sql.NullString `json:"stripe_invoice_id"`
}

func (q *Queries) GetTransactionsForBackfill(ctx context.Context) ([]GetTransactionsForBackfillRow, error) {
	rows, err := q.db.QueryContext(ctx, getTransactionsForBackfill)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTransactionsForBackfillRow
	for rows.Next() {
		var i GetTransactionsForBackfillRow
		if err := rows.Scan(
			&i.ID,
			&i.StripeCheckoutSessionID,
			&i.StripePaymentIntentID,
			&i.StripeInvoiceID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPaymentTransactions = `-- name: ListPaymentTransactions :many
SELECT id, customer_id, customer_email, customer_name, transaction_type, transaction_date, original_amount, discount_amount, subsidy_amount, customer_paid, membership_plan_id, program_id, event_id, credit_package_id, subsidy_id, discount_code_id, stripe_customer_id, stripe_subscription_id, stripe_invoice_id, stripe_payment_intent_id, stripe_checkout_session_id, payment_status, payment_method, currency, description, metadata, refunded_amount, refund_reason, refunded_at, created_at, updated_at, receipt_url, invoice_url, invoice_pdf_url FROM payments.payment_transactions
WHERE
    ($1::uuid IS NULL OR customer_id = $1) AND
    ($2::text IS NULL OR transaction_type = $2) AND
    ($3::text IS NULL OR payment_status = $3) AND
    ($4::timestamptz IS NULL OR transaction_date >= $4) AND
    ($5::timestamptz IS NULL OR transaction_date <= $5) AND
    ($6::uuid IS NULL OR subsidy_id = $6)
ORDER BY transaction_date DESC
LIMIT $8 OFFSET $7
`

type ListPaymentTransactionsParams struct {
	CustomerID      uuid.NullUUID  `json:"customer_id"`
	TransactionType sql.NullString `json:"transaction_type"`
	PaymentStatus   sql.NullString `json:"payment_status"`
	StartDate       sql.NullTime   `json:"start_date"`
	EndDate         sql.NullTime   `json:"end_date"`
	SubsidyID       uuid.NullUUID  `json:"subsidy_id"`
	Offset          int32          `json:"offset"`
	Limit           int32          `json:"limit"`
}

func (q *Queries) ListPaymentTransactions(ctx context.Context, arg ListPaymentTransactionsParams) ([]PaymentsPaymentTransaction, error) {
	rows, err := q.db.QueryContext(ctx, listPaymentTransactions,
		arg.CustomerID,
		arg.TransactionType,
		arg.PaymentStatus,
		arg.StartDate,
		arg.EndDate,
		arg.SubsidyID,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PaymentsPaymentTransaction
	for rows.Next() {
		var i PaymentsPaymentTransaction
		if err := rows.Scan(
			&i.ID,
			&i.CustomerID,
			&i.CustomerEmail,
			&i.CustomerName,
			&i.TransactionType,
			&i.TransactionDate,
			&i.OriginalAmount,
			&i.DiscountAmount,
			&i.SubsidyAmount,
			&i.CustomerPaid,
			&i.MembershipPlanID,
			&i.ProgramID,
			&i.EventID,
			&i.CreditPackageID,
			&i.SubsidyID,
			&i.DiscountCodeID,
			&i.StripeCustomerID,
			&i.StripeSubscriptionID,
			&i.StripeInvoiceID,
			&i.StripePaymentIntentID,
			&i.StripeCheckoutSessionID,
			&i.PaymentStatus,
			&i.PaymentMethod,
			&i.Currency,
			&i.Description,
			&i.Metadata,
			&i.RefundedAmount,
			&i.RefundReason,
			&i.RefundedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ReceiptUrl,
			&i.InvoiceUrl,
			&i.InvoicePdfUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPaymentTransactionsByCustomer = `-- name: ListPaymentTransactionsByCustomer :many
SELECT id, customer_id, customer_email, customer_name, transaction_type, transaction_date, original_amount, discount_amount, subsidy_amount, customer_paid, membership_plan_id, program_id, event_id, credit_package_id, subsidy_id, discount_code_id, stripe_customer_id, stripe_subscription_id, stripe_invoice_id, stripe_payment_intent_id, stripe_checkout_session_id, payment_status, payment_method, currency, description, metadata, refunded_amount, refund_reason, refunded_at, created_at, updated_at, receipt_url, invoice_url, invoice_pdf_url FROM payments.payment_transactions
WHERE customer_id = $1
ORDER BY transaction_date DESC
LIMIT $3 OFFSET $2
`

type ListPaymentTransactionsByCustomerParams struct {
	CustomerID uuid.UUID `json:"customer_id"`
	Offset     int32     `json:"offset"`
	Limit      int32     `json:"limit"`
}

func (q *Queries) ListPaymentTransactionsByCustomer(ctx context.Context, arg ListPaymentTransactionsByCustomerParams) ([]PaymentsPaymentTransaction, error) {
	rows, err := q.db.QueryContext(ctx, listPaymentTransactionsByCustomer, arg.CustomerID, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PaymentsPaymentTransaction
	for rows.Next() {
		var i PaymentsPaymentTransaction
		if err := rows.Scan(
			&i.ID,
			&i.CustomerID,
			&i.CustomerEmail,
			&i.CustomerName,
			&i.TransactionType,
			&i.TransactionDate,
			&i.OriginalAmount,
			&i.DiscountAmount,
			&i.SubsidyAmount,
			&i.CustomerPaid,
			&i.MembershipPlanID,
			&i.ProgramID,
			&i.EventID,
			&i.CreditPackageID,
			&i.SubsidyID,
			&i.DiscountCodeID,
			&i.StripeCustomerID,
			&i.StripeSubscriptionID,
			&i.StripeInvoiceID,
			&i.StripePaymentIntentID,
			&i.StripeCheckoutSessionID,
			&i.PaymentStatus,
			&i.PaymentMethod,
			&i.Currency,
			&i.Description,
			&i.Metadata,
			&i.RefundedAmount,
			&i.RefundReason,
			&i.RefundedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ReceiptUrl,
			&i.InvoiceUrl,
			&i.InvoicePdfUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const recordRefund = `-- name: RecordRefund :one
UPDATE payments.payment_transactions
SET payment_status = $2,
    refunded_amount = $3,
    refund_reason = $4,
    refunded_at = CURRENT_TIMESTAMP,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1
RETURNING id, customer_id, customer_email, customer_name, transaction_type, transaction_date, original_amount, discount_amount, subsidy_amount, customer_paid, membership_plan_id, program_id, event_id, credit_package_id, subsidy_id, discount_code_id, stripe_customer_id, stripe_subscription_id, stripe_invoice_id, stripe_payment_intent_id, stripe_checkout_session_id, payment_status, payment_method, currency, description, metadata, refunded_amount, refund_reason, refunded_at, created_at, updated_at, receipt_url, invoice_url, invoice_pdf_url
`

type RecordRefundParams struct {
	ID             uuid.UUID       `json:"id"`
	PaymentStatus  string          `json:"payment_status"`
	RefundedAmount decimal.Decimal `json:"refunded_amount"`
	RefundReason   sql.NullString  `json:"refund_reason"`
}

func (q *Queries) RecordRefund(ctx context.Context, arg RecordRefundParams) (PaymentsPaymentTransaction, error) {
	row := q.db.QueryRowContext(ctx, recordRefund,
		arg.ID,
		arg.PaymentStatus,
		arg.RefundedAmount,
		arg.RefundReason,
	)
	var i PaymentsPaymentTransaction
	err := row.Scan(
		&i.ID,
		&i.CustomerID,
		&i.CustomerEmail,
		&i.CustomerName,
		&i.TransactionType,
		&i.TransactionDate,
		&i.OriginalAmount,
		&i.DiscountAmount,
		&i.SubsidyAmount,
		&i.CustomerPaid,
		&i.MembershipPlanID,
		&i.ProgramID,
		&i.EventID,
		&i.CreditPackageID,
		&i.SubsidyID,
		&i.DiscountCodeID,
		&i.StripeCustomerID,
		&i.StripeSubscriptionID,
		&i.StripeInvoiceID,
		&i.StripePaymentIntentID,
		&i.StripeCheckoutSessionID,
		&i.PaymentStatus,
		&i.PaymentMethod,
		&i.Currency,
		&i.Description,
		&i.Metadata,
		&i.RefundedAmount,
		&i.RefundReason,
		&i.RefundedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ReceiptUrl,
		&i.InvoiceUrl,
		&i.InvoicePdfUrl,
	)
	return i, err
}

const updatePaymentStatus = `-- name: UpdatePaymentStatus :one
UPDATE payments.payment_transactions
SET payment_status = $2,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1
RETURNING id, customer_id, customer_email, customer_name, transaction_type, transaction_date, original_amount, discount_amount, subsidy_amount, customer_paid, membership_plan_id, program_id, event_id, credit_package_id, subsidy_id, discount_code_id, stripe_customer_id, stripe_subscription_id, stripe_invoice_id, stripe_payment_intent_id, stripe_checkout_session_id, payment_status, payment_method, currency, description, metadata, refunded_amount, refund_reason, refunded_at, created_at, updated_at, receipt_url, invoice_url, invoice_pdf_url
`

type UpdatePaymentStatusParams struct {
	ID            uuid.UUID `json:"id"`
	PaymentStatus string    `json:"payment_status"`
}

func (q *Queries) UpdatePaymentStatus(ctx context.Context, arg UpdatePaymentStatusParams) (PaymentsPaymentTransaction, error) {
	row := q.db.QueryRowContext(ctx, updatePaymentStatus, arg.ID, arg.PaymentStatus)
	var i PaymentsPaymentTransaction
	err := row.Scan(
		&i.ID,
		&i.CustomerID,
		&i.CustomerEmail,
		&i.CustomerName,
		&i.TransactionType,
		&i.TransactionDate,
		&i.OriginalAmount,
		&i.DiscountAmount,
		&i.SubsidyAmount,
		&i.CustomerPaid,
		&i.MembershipPlanID,
		&i.ProgramID,
		&i.EventID,
		&i.CreditPackageID,
		&i.SubsidyID,
		&i.DiscountCodeID,
		&i.StripeCustomerID,
		&i.StripeSubscriptionID,
		&i.StripeInvoiceID,
		&i.StripePaymentIntentID,
		&i.StripeCheckoutSessionID,
		&i.PaymentStatus,
		&i.PaymentMethod,
		&i.Currency,
		&i.Description,
		&i.Metadata,
		&i.RefundedAmount,
		&i.RefundReason,
		&i.RefundedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ReceiptUrl,
		&i.InvoiceUrl,
		&i.InvoicePdfUrl,
	)
	return i, err
}

const updatePaymentUrls = `-- name: UpdatePaymentUrls :exec
UPDATE payments.payment_transactions
SET receipt_url = COALESCE($2, receipt_url),
    invoice_url = COALESCE($3, invoice_url),
    invoice_pdf_url = COALESCE($4, invoice_pdf_url),
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1
`

type UpdatePaymentUrlsParams struct {
	ID            uuid.UUID      `json:"id"`
	ReceiptUrl    sql.NullString `json:"receipt_url"`
	InvoiceUrl    sql.NullString `json:"invoice_url"`
	InvoicePdfUrl sql.NullString `json:"invoice_pdf_url"`
}

func (q *Queries) UpdatePaymentUrls(ctx context.Context, arg UpdatePaymentUrlsParams) error {
	_, err := q.db.ExecContext(ctx, updatePaymentUrls,
		arg.ID,
		arg.ReceiptUrl,
		arg.InvoiceUrl,
		arg.InvoicePdfUrl,
	)
	return err
}
