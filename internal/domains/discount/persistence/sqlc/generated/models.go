// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0

package db_discount

import (
	"database/sql"
	"database/sql/driver"
	"fmt"
	"time"

	"github.com/google/uuid"
)

type AuditAuditStatus string

const (
	AuditAuditStatusPENDING   AuditAuditStatus = "PENDING"
	AuditAuditStatusCOMPLETED AuditAuditStatus = "COMPLETED"
	AuditAuditStatusFAILED    AuditAuditStatus = "FAILED"
)

func (e *AuditAuditStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = AuditAuditStatus(s)
	case string:
		*e = AuditAuditStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for AuditAuditStatus: %T", src)
	}
	return nil
}

type NullAuditAuditStatus struct {
	AuditAuditStatus AuditAuditStatus `json:"audit_audit_status"`
	Valid            bool             `json:"valid"` // Valid is true if AuditAuditStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullAuditAuditStatus) Scan(value interface{}) error {
	if value == nil {
		ns.AuditAuditStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.AuditAuditStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullAuditAuditStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.AuditAuditStatus), nil
}

func (e AuditAuditStatus) Valid() bool {
	switch e {
	case AuditAuditStatusPENDING,
		AuditAuditStatusCOMPLETED,
		AuditAuditStatusFAILED:
		return true
	}
	return false
}

func AllAuditAuditStatusValues() []AuditAuditStatus {
	return []AuditAuditStatus{
		AuditAuditStatusPENDING,
		AuditAuditStatusCOMPLETED,
		AuditAuditStatusFAILED,
	}
}

type CreditTransactionType string

const (
	CreditTransactionTypeEnrollment      CreditTransactionType = "enrollment"
	CreditTransactionTypeRefund          CreditTransactionType = "refund"
	CreditTransactionTypePurchase        CreditTransactionType = "purchase"
	CreditTransactionTypeAdminAdjustment CreditTransactionType = "admin_adjustment"
)

func (e *CreditTransactionType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = CreditTransactionType(s)
	case string:
		*e = CreditTransactionType(s)
	default:
		return fmt.Errorf("unsupported scan type for CreditTransactionType: %T", src)
	}
	return nil
}

type NullCreditTransactionType struct {
	CreditTransactionType CreditTransactionType `json:"credit_transaction_type"`
	Valid                 bool                  `json:"valid"` // Valid is true if CreditTransactionType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullCreditTransactionType) Scan(value interface{}) error {
	if value == nil {
		ns.CreditTransactionType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.CreditTransactionType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullCreditTransactionType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.CreditTransactionType), nil
}

func (e CreditTransactionType) Valid() bool {
	switch e {
	case CreditTransactionTypeEnrollment,
		CreditTransactionTypeRefund,
		CreditTransactionTypePurchase,
		CreditTransactionTypeAdminAdjustment:
		return true
	}
	return false
}

func AllCreditTransactionTypeValues() []CreditTransactionType {
	return []CreditTransactionType{
		CreditTransactionTypeEnrollment,
		CreditTransactionTypeRefund,
		CreditTransactionTypePurchase,
		CreditTransactionTypeAdminAdjustment,
	}
}

type DiscountAppliesTo string

const (
	DiscountAppliesToSubscription DiscountAppliesTo = "subscription"
	DiscountAppliesToOneTime      DiscountAppliesTo = "one_time"
	DiscountAppliesToBoth         DiscountAppliesTo = "both"
)

func (e *DiscountAppliesTo) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = DiscountAppliesTo(s)
	case string:
		*e = DiscountAppliesTo(s)
	default:
		return fmt.Errorf("unsupported scan type for DiscountAppliesTo: %T", src)
	}
	return nil
}

type NullDiscountAppliesTo struct {
	DiscountAppliesTo DiscountAppliesTo `json:"discount_applies_to"`
	Valid             bool              `json:"valid"` // Valid is true if DiscountAppliesTo is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullDiscountAppliesTo) Scan(value interface{}) error {
	if value == nil {
		ns.DiscountAppliesTo, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.DiscountAppliesTo.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullDiscountAppliesTo) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.DiscountAppliesTo), nil
}

func (e DiscountAppliesTo) Valid() bool {
	switch e {
	case DiscountAppliesToSubscription,
		DiscountAppliesToOneTime,
		DiscountAppliesToBoth:
		return true
	}
	return false
}

func AllDiscountAppliesToValues() []DiscountAppliesTo {
	return []DiscountAppliesTo{
		DiscountAppliesToSubscription,
		DiscountAppliesToOneTime,
		DiscountAppliesToBoth,
	}
}

type DiscountDurationType string

const (
	DiscountDurationTypeOnce      DiscountDurationType = "once"
	DiscountDurationTypeRepeating DiscountDurationType = "repeating"
	DiscountDurationTypeForever   DiscountDurationType = "forever"
)

func (e *DiscountDurationType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = DiscountDurationType(s)
	case string:
		*e = DiscountDurationType(s)
	default:
		return fmt.Errorf("unsupported scan type for DiscountDurationType: %T", src)
	}
	return nil
}

type NullDiscountDurationType struct {
	DiscountDurationType DiscountDurationType `json:"discount_duration_type"`
	Valid                bool                 `json:"valid"` // Valid is true if DiscountDurationType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullDiscountDurationType) Scan(value interface{}) error {
	if value == nil {
		ns.DiscountDurationType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.DiscountDurationType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullDiscountDurationType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.DiscountDurationType), nil
}

func (e DiscountDurationType) Valid() bool {
	switch e {
	case DiscountDurationTypeOnce,
		DiscountDurationTypeRepeating,
		DiscountDurationTypeForever:
		return true
	}
	return false
}

func AllDiscountDurationTypeValues() []DiscountDurationType {
	return []DiscountDurationType{
		DiscountDurationTypeOnce,
		DiscountDurationTypeRepeating,
		DiscountDurationTypeForever,
	}
}

type DiscountType string

const (
	DiscountTypePercentage  DiscountType = "percentage"
	DiscountTypeFixedAmount DiscountType = "fixed_amount"
)

func (e *DiscountType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = DiscountType(s)
	case string:
		*e = DiscountType(s)
	default:
		return fmt.Errorf("unsupported scan type for DiscountType: %T", src)
	}
	return nil
}

type NullDiscountType struct {
	DiscountType DiscountType `json:"discount_type"`
	Valid        bool         `json:"valid"` // Valid is true if DiscountType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullDiscountType) Scan(value interface{}) error {
	if value == nil {
		ns.DiscountType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.DiscountType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullDiscountType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.DiscountType), nil
}

func (e DiscountType) Valid() bool {
	switch e {
	case DiscountTypePercentage,
		DiscountTypeFixedAmount:
		return true
	}
	return false
}

func AllDiscountTypeValues() []DiscountType {
	return []DiscountType{
		DiscountTypePercentage,
		DiscountTypeFixedAmount,
	}
}

type MembershipMembershipStatus string

const (
	MembershipMembershipStatusActive   MembershipMembershipStatus = "active"
	MembershipMembershipStatusInactive MembershipMembershipStatus = "inactive"
	MembershipMembershipStatusCanceled MembershipMembershipStatus = "canceled"
	MembershipMembershipStatusExpired  MembershipMembershipStatus = "expired"
)

func (e *MembershipMembershipStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = MembershipMembershipStatus(s)
	case string:
		*e = MembershipMembershipStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for MembershipMembershipStatus: %T", src)
	}
	return nil
}

type NullMembershipMembershipStatus struct {
	MembershipMembershipStatus MembershipMembershipStatus `json:"membership_membership_status"`
	Valid                      bool                       `json:"valid"` // Valid is true if MembershipMembershipStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullMembershipMembershipStatus) Scan(value interface{}) error {
	if value == nil {
		ns.MembershipMembershipStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.MembershipMembershipStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullMembershipMembershipStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.MembershipMembershipStatus), nil
}

func (e MembershipMembershipStatus) Valid() bool {
	switch e {
	case MembershipMembershipStatusActive,
		MembershipMembershipStatusInactive,
		MembershipMembershipStatusCanceled,
		MembershipMembershipStatusExpired:
		return true
	}
	return false
}

func AllMembershipMembershipStatusValues() []MembershipMembershipStatus {
	return []MembershipMembershipStatus{
		MembershipMembershipStatusActive,
		MembershipMembershipStatusInactive,
		MembershipMembershipStatusCanceled,
		MembershipMembershipStatusExpired,
	}
}

type PaymentStatus string

const (
	PaymentStatusPending PaymentStatus = "pending"
	PaymentStatusPaid    PaymentStatus = "paid"
	PaymentStatusFailed  PaymentStatus = "failed"
)

func (e *PaymentStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = PaymentStatus(s)
	case string:
		*e = PaymentStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for PaymentStatus: %T", src)
	}
	return nil
}

type NullPaymentStatus struct {
	PaymentStatus PaymentStatus `json:"payment_status"`
	Valid         bool          `json:"valid"` // Valid is true if PaymentStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullPaymentStatus) Scan(value interface{}) error {
	if value == nil {
		ns.PaymentStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.PaymentStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullPaymentStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.PaymentStatus), nil
}

func (e PaymentStatus) Valid() bool {
	switch e {
	case PaymentStatusPending,
		PaymentStatusPaid,
		PaymentStatusFailed:
		return true
	}
	return false
}

func AllPaymentStatusValues() []PaymentStatus {
	return []PaymentStatus{
		PaymentStatusPending,
		PaymentStatusPaid,
		PaymentStatusFailed,
	}
}

type ProgramProgramLevel string

const (
	ProgramProgramLevelBeginner     ProgramProgramLevel = "beginner"
	ProgramProgramLevelIntermediate ProgramProgramLevel = "intermediate"
	ProgramProgramLevelAdvanced     ProgramProgramLevel = "advanced"
	ProgramProgramLevelAll          ProgramProgramLevel = "all"
)

func (e *ProgramProgramLevel) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = ProgramProgramLevel(s)
	case string:
		*e = ProgramProgramLevel(s)
	default:
		return fmt.Errorf("unsupported scan type for ProgramProgramLevel: %T", src)
	}
	return nil
}

type NullProgramProgramLevel struct {
	ProgramProgramLevel ProgramProgramLevel `json:"program_program_level"`
	Valid               bool                `json:"valid"` // Valid is true if ProgramProgramLevel is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullProgramProgramLevel) Scan(value interface{}) error {
	if value == nil {
		ns.ProgramProgramLevel, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.ProgramProgramLevel.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullProgramProgramLevel) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.ProgramProgramLevel), nil
}

func (e ProgramProgramLevel) Valid() bool {
	switch e {
	case ProgramProgramLevelBeginner,
		ProgramProgramLevelIntermediate,
		ProgramProgramLevelAdvanced,
		ProgramProgramLevelAll:
		return true
	}
	return false
}

func AllProgramProgramLevelValues() []ProgramProgramLevel {
	return []ProgramProgramLevel{
		ProgramProgramLevelBeginner,
		ProgramProgramLevelIntermediate,
		ProgramProgramLevelAdvanced,
		ProgramProgramLevelAll,
	}
}

type ProgramProgramType string

const (
	ProgramProgramTypePractice   ProgramProgramType = "practice"
	ProgramProgramTypeCourse     ProgramProgramType = "course"
	ProgramProgramTypeOther      ProgramProgramType = "other"
	ProgramProgramTypeTournament ProgramProgramType = "tournament"
	ProgramProgramTypeTryouts    ProgramProgramType = "tryouts"
	ProgramProgramTypeEvent      ProgramProgramType = "event"
)

func (e *ProgramProgramType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = ProgramProgramType(s)
	case string:
		*e = ProgramProgramType(s)
	default:
		return fmt.Errorf("unsupported scan type for ProgramProgramType: %T", src)
	}
	return nil
}

type NullProgramProgramType struct {
	ProgramProgramType ProgramProgramType `json:"program_program_type"`
	Valid              bool               `json:"valid"` // Valid is true if ProgramProgramType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullProgramProgramType) Scan(value interface{}) error {
	if value == nil {
		ns.ProgramProgramType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.ProgramProgramType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullProgramProgramType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.ProgramProgramType), nil
}

func (e ProgramProgramType) Valid() bool {
	switch e {
	case ProgramProgramTypePractice,
		ProgramProgramTypeCourse,
		ProgramProgramTypeOther,
		ProgramProgramTypeTournament,
		ProgramProgramTypeTryouts,
		ProgramProgramTypeEvent:
		return true
	}
	return false
}

func AllProgramProgramTypeValues() []ProgramProgramType {
	return []ProgramProgramType{
		ProgramProgramTypePractice,
		ProgramProgramTypeCourse,
		ProgramProgramTypeOther,
		ProgramProgramTypeTournament,
		ProgramProgramTypeTryouts,
		ProgramProgramTypeEvent,
	}
}

type AthleticAthlete struct {
	ID        uuid.UUID      `json:"id"`
	Wins      int32          `json:"wins"`
	Losses    int32          `json:"losses"`
	Points    int32          `json:"points"`
	Steals    int32          `json:"steals"`
	Assists   int32          `json:"assists"`
	Rebounds  int32          `json:"rebounds"`
	CreatedAt time.Time      `json:"created_at"`
	UpdatedAt time.Time      `json:"updated_at"`
	TeamID    uuid.NullUUID  `json:"team_id"`
	PhotoUrl  sql.NullString `json:"photo_url"`
}

type AthleticCoachStat struct {
	ID        uuid.UUID `json:"id"`
	Wins      int32     `json:"wins"`
	Losses    int32     `json:"losses"`
	CoachID   uuid.UUID `json:"coach_id"`
	CreatedAt time.Time `json:"created_at"`
	UpdatedAt time.Time `json:"updated_at"`
}

type AthleticTeam struct {
	ID        uuid.UUID      `json:"id"`
	Name      string         `json:"name"`
	Capacity  int32          `json:"capacity"`
	CreatedAt time.Time      `json:"created_at"`
	UpdatedAt time.Time      `json:"updated_at"`
	CoachID   uuid.NullUUID  `json:"coach_id"`
	LogoUrl   sql.NullString `json:"logo_url"`
	// TRUE for external/opponent teams (not RISE teams). External teams are shared across all coaches and do not require a coach_id. FALSE for internal RISE teams that must have a coach_id.
	IsExternal bool `json:"is_external"`
}

type AuditOutbox struct {
	ID           uuid.UUID        `json:"id"`
	SqlStatement string           `json:"sql_statement"`
	Status       AuditAuditStatus `json:"status"`
	CreatedAt    time.Time        `json:"created_at"`
}

type AuditStaffActivityLog struct {
	ID                  uuid.UUID `json:"id"`
	StaffID             uuid.UUID `json:"staff_id"`
	ActivityDescription string    `json:"activity_description"`
	CreatedAt           time.Time `json:"created_at"`
}

type Discount struct {
	ID              uuid.UUID            `json:"id"`
	Name            string               `json:"name"`
	Description     sql.NullString       `json:"description"`
	DiscountPercent int32                `json:"discount_percent"`
	IsUseUnlimited  bool                 `json:"is_use_unlimited"`
	UsePerClient    sql.NullInt32        `json:"use_per_client"`
	IsActive        bool                 `json:"is_active"`
	ValidFrom       time.Time            `json:"valid_from"`
	ValidTo         sql.NullTime         `json:"valid_to"`
	CreatedAt       time.Time            `json:"created_at"`
	UpdatedAt       time.Time            `json:"updated_at"`
	StripeCouponID  sql.NullString       `json:"stripe_coupon_id"`
	DurationType    DiscountDurationType `json:"duration_type"`
	DurationMonths  sql.NullInt32        `json:"duration_months"`
	DiscountType    DiscountType         `json:"discount_type"`
	DiscountAmount  sql.NullString       `json:"discount_amount"`
	AppliesTo       DiscountAppliesTo    `json:"applies_to"`
	MaxRedemptions  sql.NullInt32        `json:"max_redemptions"`
	TimesRedeemed   int32                `json:"times_redeemed"`
}

type EventsAttendance struct {
	ID          uuid.UUID    `json:"id"`
	EventID     uuid.UUID    `json:"event_id"`
	UserID      uuid.UUID    `json:"user_id"`
	CheckInTime sql.NullTime `json:"check_in_time"`
}

type EventsCustomerEnrollment struct {
	ID               uuid.UUID     `json:"id"`
	CustomerID       uuid.UUID     `json:"customer_id"`
	EventID          uuid.UUID     `json:"event_id"`
	CreatedAt        time.Time     `json:"created_at"`
	UpdatedAt        time.Time     `json:"updated_at"`
	CheckedInAt      sql.NullTime  `json:"checked_in_at"`
	IsCancelled      bool          `json:"is_cancelled"`
	PaymentStatus    PaymentStatus `json:"payment_status"`
	PaymentExpiredAt sql.NullTime  `json:"payment_expired_at"`
}

type EventsEvent struct {
	ID                 uuid.UUID      `json:"id"`
	LocationID         uuid.UUID      `json:"location_id"`
	ProgramID          uuid.UUID      `json:"program_id"`
	TeamID             uuid.NullUUID  `json:"team_id"`
	StartAt            time.Time      `json:"start_at"`
	EndAt              time.Time      `json:"end_at"`
	CreatedBy          uuid.UUID      `json:"created_by"`
	UpdatedBy          uuid.UUID      `json:"updated_by"`
	IsCancelled        bool           `json:"is_cancelled"`
	CancellationReason sql.NullString `json:"cancellation_reason"`
	CreatedAt          time.Time      `json:"created_at"`
	UpdatedAt          time.Time      `json:"updated_at"`
	IsDateTimeModified bool           `json:"is_date_time_modified"`
	RecurrenceID       uuid.NullUUID  `json:"recurrence_id"`
	CourtID            uuid.NullUUID  `json:"court_id"`
	PriceID            sql.NullString `json:"price_id"`
	CreditCost         sql.NullInt32  `json:"credit_cost"`
}

type EventsEventMembershipAccess struct {
	ID               uuid.UUID    `json:"id"`
	EventID          uuid.UUID    `json:"event_id"`
	MembershipPlanID uuid.UUID    `json:"membership_plan_id"`
	CreatedAt        sql.NullTime `json:"created_at"`
}

type EventsStaff struct {
	EventID uuid.UUID `json:"event_id"`
	StaffID uuid.UUID `json:"staff_id"`
}

type GameGame struct {
	ID         uuid.UUID      `json:"id"`
	HomeTeamID uuid.UUID      `json:"home_team_id"`
	AwayTeamID uuid.UUID      `json:"away_team_id"`
	HomeScore  sql.NullInt32  `json:"home_score"`
	AwayScore  sql.NullInt32  `json:"away_score"`
	StartTime  time.Time      `json:"start_time"`
	EndTime    sql.NullTime   `json:"end_time"`
	LocationID uuid.UUID      `json:"location_id"`
	Status     sql.NullString `json:"status"`
	CreatedAt  sql.NullTime   `json:"created_at"`
	UpdatedAt  sql.NullTime   `json:"updated_at"`
	CourtID    uuid.NullUUID  `json:"court_id"`
	// User (coach/admin) who created/scheduled this game
	CreatedBy uuid.NullUUID `json:"created_by"`
}

type HaircutBarberAvailability struct {
	ID        uuid.UUID `json:"id"`
	BarberID  uuid.UUID `json:"barber_id"`
	DayOfWeek int32     `json:"day_of_week"`
	StartTime time.Time `json:"start_time"`
	EndTime   time.Time `json:"end_time"`
	IsActive  bool      `json:"is_active"`
	CreatedAt time.Time `json:"created_at"`
	UpdatedAt time.Time `json:"updated_at"`
}

type HaircutBarberService struct {
	ID        uuid.UUID `json:"id"`
	BarberID  uuid.UUID `json:"barber_id"`
	ServiceID uuid.UUID `json:"service_id"`
	CreatedAt time.Time `json:"created_at"`
	UpdatedAt time.Time `json:"updated_at"`
}

type HaircutEvent struct {
	ID            uuid.UUID `json:"id"`
	BeginDateTime time.Time `json:"begin_date_time"`
	EndDateTime   time.Time `json:"end_date_time"`
	CustomerID    uuid.UUID `json:"customer_id"`
	BarberID      uuid.UUID `json:"barber_id"`
	ServiceTypeID uuid.UUID `json:"service_type_id"`
	CreatedAt     time.Time `json:"created_at"`
	UpdatedAt     time.Time `json:"updated_at"`
}

type HaircutHaircutService struct {
	ID            uuid.UUID      `json:"id"`
	Name          string         `json:"name"`
	Description   sql.NullString `json:"description"`
	Price         string         `json:"price"`
	DurationInMin int32          `json:"duration_in_min"`
	CreatedAt     time.Time      `json:"created_at"`
	UpdatedAt     time.Time      `json:"updated_at"`
}

type LocationCourt struct {
	ID         uuid.UUID `json:"id"`
	LocationID uuid.UUID `json:"location_id"`
	Name       string    `json:"name"`
	CreatedAt  time.Time `json:"created_at"`
	UpdatedAt  time.Time `json:"updated_at"`
}

type LocationLocation struct {
	ID        uuid.UUID `json:"id"`
	Name      string    `json:"name"`
	Address   string    `json:"address"`
	CreatedAt time.Time `json:"created_at"`
	UpdatedAt time.Time `json:"updated_at"`
}

type MembershipDiscountRestrictedMembershipPlan struct {
	DiscountID       uuid.UUID `json:"discount_id"`
	MembershipPlanID uuid.UUID `json:"membership_plan_id"`
	CreatedAt        time.Time `json:"created_at"`
}

type MembershipMembership struct {
	ID          uuid.UUID `json:"id"`
	Name        string    `json:"name"`
	Description string    `json:"description"`
	Benefits    string    `json:"benefits"`
	CreatedAt   time.Time `json:"created_at"`
	UpdatedAt   time.Time `json:"updated_at"`
}

type MembershipMembershipPlan struct {
	ID                 uuid.UUID      `json:"id"`
	Name               string         `json:"name"`
	StripePriceID      string         `json:"stripe_price_id"`
	StripeJoiningFeeID sql.NullString `json:"stripe_joining_fee_id"`
	MembershipID       uuid.UUID      `json:"membership_id"`
	AmtPeriods         sql.NullInt32  `json:"amt_periods"`
	CreatedAt          time.Time      `json:"created_at"`
	UpdatedAt          time.Time      `json:"updated_at"`
	UnitAmount         sql.NullInt32  `json:"unit_amount"`
	Currency           sql.NullString `json:"currency"`
	Interval           sql.NullString `json:"interval"`
	// One-time joining fee in cents (e.g., 13000 = $130.00). Applied as Stripe setup fee on first payment only.
	JoiningFee int32 `json:"joining_fee"`
	// Number of credits awarded when purchasing this membership plan (NULL for non-credit memberships)
	CreditAllocation sql.NullInt32 `json:"credit_allocation"`
	// Maximum credits that can be used per week with this membership plan (NULL for non-credit memberships, 0 = unlimited credits)
	WeeklyCreditLimit sql.NullInt32 `json:"weekly_credit_limit"`
	IsVisible         bool          `json:"is_visible"`
}

type NotificationsPushToken struct {
	ID            int32          `json:"id"`
	UserID        uuid.UUID      `json:"user_id"`
	ExpoPushToken string         `json:"expo_push_token"`
	DeviceType    sql.NullString `json:"device_type"`
	CreatedAt     sql.NullTime   `json:"created_at"`
	UpdatedAt     sql.NullTime   `json:"updated_at"`
}

type PlaygroundSession struct {
	ID         uuid.UUID `json:"id"`
	SystemID   uuid.UUID `json:"system_id"`
	CustomerID uuid.UUID `json:"customer_id"`
	StartTime  time.Time `json:"start_time"`
	EndTime    time.Time `json:"end_time"`
	CreatedAt  time.Time `json:"created_at"`
	UpdatedAt  time.Time `json:"updated_at"`
}

type PlaygroundSystem struct {
	ID        uuid.UUID `json:"id"`
	Name      string    `json:"name"`
	CreatedAt time.Time `json:"created_at"`
	UpdatedAt time.Time `json:"updated_at"`
}

type PracticePractice struct {
	ID         uuid.UUID      `json:"id"`
	TeamID     uuid.UUID      `json:"team_id"`
	StartTime  time.Time      `json:"start_time"`
	EndTime    sql.NullTime   `json:"end_time"`
	LocationID uuid.UUID      `json:"location_id"`
	CourtID    uuid.NullUUID  `json:"court_id"`
	Status     sql.NullString `json:"status"`
	CreatedAt  sql.NullTime   `json:"created_at"`
	UpdatedAt  sql.NullTime   `json:"updated_at"`
	BookedBy   uuid.NullUUID  `json:"booked_by"`
}

type ProgramCustomerEnrollment struct {
	ID               uuid.UUID     `json:"id"`
	CustomerID       uuid.UUID     `json:"customer_id"`
	ProgramID        uuid.UUID     `json:"program_id"`
	CreatedAt        time.Time     `json:"created_at"`
	UpdatedAt        time.Time     `json:"updated_at"`
	IsCancelled      bool          `json:"is_cancelled"`
	PaymentStatus    PaymentStatus `json:"payment_status"`
	PaymentExpiredAt sql.NullTime  `json:"payment_expired_at"`
}

type ProgramFee struct {
	ProgramID     uuid.UUID     `json:"program_id"`
	MembershipID  uuid.NullUUID `json:"membership_id"`
	StripePriceID string        `json:"stripe_price_id"`
	CreatedAt     time.Time     `json:"created_at"`
	UpdatedAt     time.Time     `json:"updated_at"`
}

type ProgramGame struct {
	ID        uuid.UUID `json:"id"`
	WinTeam   uuid.UUID `json:"win_team"`
	LoseTeam  uuid.UUID `json:"lose_team"`
	WinScore  int32     `json:"win_score"`
	LoseScore int32     `json:"lose_score"`
}

type ProgramProgram struct {
	ID          uuid.UUID           `json:"id"`
	Name        string              `json:"name"`
	Description string              `json:"description"`
	Level       ProgramProgramLevel `json:"level"`
	Type        ProgramProgramType  `json:"type"`
	Capacity    sql.NullInt32       `json:"capacity"`
	CreatedAt   time.Time           `json:"created_at"`
	UpdatedAt   time.Time           `json:"updated_at"`
	PayPerEvent bool                `json:"pay_per_event"`
	PhotoUrl    sql.NullString      `json:"photo_url"`
}

type StaffPendingStaff struct {
	ID                uuid.UUID      `json:"id"`
	FirstName         string         `json:"first_name"`
	LastName          string         `json:"last_name"`
	Email             string         `json:"email"`
	Gender            sql.NullString `json:"gender"`
	Phone             sql.NullString `json:"phone"`
	CountryAlpha2Code string         `json:"country_alpha2_code"`
	RoleID            uuid.UUID      `json:"role_id"`
	CreatedAt         sql.NullTime   `json:"created_at"`
	UpdatedAt         sql.NullTime   `json:"updated_at"`
	Dob               time.Time      `json:"dob"`
}

type StaffStaff struct {
	ID        uuid.UUID      `json:"id"`
	IsActive  bool           `json:"is_active"`
	CreatedAt time.Time      `json:"created_at"`
	UpdatedAt time.Time      `json:"updated_at"`
	RoleID    uuid.UUID      `json:"role_id"`
	PhotoUrl  sql.NullString `json:"photo_url"`
}

type StaffStaffRole struct {
	ID        uuid.UUID `json:"id"`
	RoleName  string    `json:"role_name"`
	CreatedAt time.Time `json:"created_at"`
	UpdatedAt time.Time `json:"updated_at"`
}

// Available credit packages for one-time purchase
type UsersCreditPackage struct {
	ID          uuid.UUID      `json:"id"`
	Name        string         `json:"name"`
	Description sql.NullString `json:"description"`
	// Stripe price ID for one-time payment checkout
	StripePriceID string `json:"stripe_price_id"`
	// Number of credits awarded when purchasing this package
	CreditAllocation int32 `json:"credit_allocation"`
	// Maximum credits that can be used per week (0 = unlimited)
	WeeklyCreditLimit int32     `json:"weekly_credit_limit"`
	CreatedAt         time.Time `json:"created_at"`
	UpdatedAt         time.Time `json:"updated_at"`
}

type UsersCreditTransaction struct {
	ID              uuid.UUID             `json:"id"`
	CustomerID      uuid.UUID             `json:"customer_id"`
	Amount          int32                 `json:"amount"`
	TransactionType CreditTransactionType `json:"transaction_type"`
	EventID         uuid.NullUUID         `json:"event_id"`
	Description     sql.NullString        `json:"description"`
	CreatedAt       sql.NullTime          `json:"created_at"`
}

// Tracks each customer's currently active credit package and their weekly limit
type UsersCustomerActiveCreditPackage struct {
	// Customer who purchased the package (PRIMARY KEY ensures one package per customer)
	CustomerID uuid.UUID `json:"customer_id"`
	// The credit package they purchased
	CreditPackageID uuid.UUID `json:"credit_package_id"`
	// Weekly credit limit from the package (copied here for performance)
	WeeklyCreditLimit int32 `json:"weekly_credit_limit"`
	// When this package was purchased
	PurchasedAt time.Time `json:"purchased_at"`
	UpdatedAt   time.Time `json:"updated_at"`
}

type UsersCustomerCredit struct {
	CustomerID uuid.UUID `json:"customer_id"`
	Credits    int32     `json:"credits"`
}

type UsersCustomerDiscountUsage struct {
	CustomerID uuid.UUID `json:"customer_id"`
	DiscountID uuid.UUID `json:"discount_id"`
	UsageCount int32     `json:"usage_count"`
	LastUsedAt time.Time `json:"last_used_at"`
}

type UsersCustomerMembershipPlan struct {
	ID                    uuid.UUID                  `json:"id"`
	CustomerID            uuid.UUID                  `json:"customer_id"`
	MembershipPlanID      uuid.UUID                  `json:"membership_plan_id"`
	StartDate             time.Time                  `json:"start_date"`
	RenewalDate           sql.NullTime               `json:"renewal_date"`
	Status                MembershipMembershipStatus `json:"status"`
	CreatedAt             time.Time                  `json:"created_at"`
	UpdatedAt             time.Time                  `json:"updated_at"`
	PhotoUrl              sql.NullString             `json:"photo_url"`
	SquareSubscriptionID  sql.NullString             `json:"square_subscription_id"`
	SubscriptionStatus    sql.NullString             `json:"subscription_status"`
	NextBillingDate       sql.NullTime               `json:"next_billing_date"`
	SubscriptionCreatedAt sql.NullTime               `json:"subscription_created_at"`
	SubscriptionSource    sql.NullString             `json:"subscription_source"`
}

type UsersSubscriptionAutoCharging struct {
	ID                       uuid.UUID      `json:"id"`
	CustomerMembershipPlanID uuid.UUID      `json:"customer_membership_plan_id"`
	SquareSubscriptionID     sql.NullString `json:"square_subscription_id"`
	Enabled                  sql.NullBool   `json:"enabled"`
	CardID                   sql.NullString `json:"card_id"`
	LastPaymentID            sql.NullString `json:"last_payment_id"`
	ErrorType                sql.NullString `json:"error_type"`
	ErrorDetails             sql.NullString `json:"error_details"`
	RetryCount               sql.NullInt32  `json:"retry_count"`
	PermanentlyFailed        sql.NullBool   `json:"permanently_failed"`
	CreatedAt                sql.NullTime   `json:"created_at"`
	UpdatedAt                sql.NullTime   `json:"updated_at"`
}

type UsersUser struct {
	ID                       uuid.UUID      `json:"id"`
	HubspotID                sql.NullString `json:"hubspot_id"`
	CountryAlpha2Code        string         `json:"country_alpha2_code"`
	Gender                   sql.NullString `json:"gender"`
	FirstName                string         `json:"first_name"`
	LastName                 string         `json:"last_name"`
	ParentID                 uuid.NullUUID  `json:"parent_id"`
	Phone                    sql.NullString `json:"phone"`
	Email                    sql.NullString `json:"email"`
	HasMarketingEmailConsent bool           `json:"has_marketing_email_consent"`
	HasSmsConsent            bool           `json:"has_sms_consent"`
	CreatedAt                time.Time      `json:"created_at"`
	UpdatedAt                time.Time      `json:"updated_at"`
	Dob                      time.Time      `json:"dob"`
	IsArchived               bool           `json:"is_archived"`
	SquareCustomerID         sql.NullString `json:"square_customer_id"`
	StripeCustomerID         sql.NullString `json:"stripe_customer_id"`
	// Staff notes about the customer for internal reference
	Notes sql.NullString `json:"notes"`
	// Timestamp when account was soft deleted. NULL means account is active. Account data kept for recovery period (30-90 days)
	DeletedAt sql.NullTime `json:"deleted_at"`
	// Timestamp when account is scheduled for permanent deletion. Used for grace period recovery
	ScheduledDeletionAt sql.NullTime `json:"scheduled_deletion_at"`
	// Whether the user has verified their email address. Users must verify email before they can log in.
	EmailVerified bool `json:"email_verified"`
	// One-time token sent to user email for verification. NULL after verification.
	EmailVerificationToken sql.NullString `json:"email_verification_token"`
	// Expiration time for verification token. Tokens are valid for 24 hours.
	EmailVerificationTokenExpiresAt sql.NullTime `json:"email_verification_token_expires_at"`
	// Timestamp when the user verified their email address.
	EmailVerifiedAt sql.NullTime `json:"email_verified_at"`
}

// Tracks weekly credit consumption per customer for membership limit enforcement
type UsersWeeklyCreditUsage struct {
	ID         uuid.UUID `json:"id"`
	CustomerID uuid.UUID `json:"customer_id"`
	// Monday of the ISO week (e.g., 2024-01-15 for week starting Jan 15)
	WeekStartDate time.Time `json:"week_start_date"`
	// Total credits consumed during this week
	CreditsUsed int32        `json:"credits_used"`
	CreatedAt   sql.NullTime `json:"created_at"`
	UpdatedAt   sql.NullTime `json:"updated_at"`
}

type WaiverWaiver struct {
	ID         uuid.UUID `json:"id"`
	WaiverUrl  string    `json:"waiver_url"`
	WaiverName string    `json:"waiver_name"`
	CreatedAt  time.Time `json:"created_at"`
	UpdatedAt  time.Time `json:"updated_at"`
}

type WaiverWaiverSigning struct {
	UserID    uuid.UUID `json:"user_id"`
	WaiverID  uuid.UUID `json:"waiver_id"`
	IsSigned  bool      `json:"is_signed"`
	UpdatedAt time.Time `json:"updated_at"`
}
