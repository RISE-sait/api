// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: practice_queries.sql

package db_practice

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
)

const createPractice = `-- name: CreatePractice :exec
INSERT INTO practice.practices (
    team_id, start_time, end_time, court_id, location_id, status, booked_by
) VALUES (
    $1, $2, $3, $4, $5, $6, $7
)
`

type CreatePracticeParams struct {
	TeamID     uuid.UUID      `json:"team_id"`
	StartTime  time.Time      `json:"start_time"`
	EndTime    sql.NullTime   `json:"end_time"`
	CourtID    uuid.NullUUID  `json:"court_id"`
	LocationID uuid.UUID      `json:"location_id"`
	Status     sql.NullString `json:"status"`
	BookedBy   uuid.NullUUID  `json:"booked_by"`
}

func (q *Queries) CreatePractice(ctx context.Context, arg CreatePracticeParams) error {
	_, err := q.db.ExecContext(ctx, createPractice,
		arg.TeamID,
		arg.StartTime,
		arg.EndTime,
		arg.CourtID,
		arg.LocationID,
		arg.Status,
		arg.BookedBy,
	)
	return err
}

const deletePractice = `-- name: DeletePractice :exec
DELETE FROM practice.practices WHERE id=$1
`

func (q *Queries) DeletePractice(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deletePractice, id)
	return err
}

const getPracticeByID = `-- name: GetPracticeByID :one
SELECT p.id,
       p.team_id,
       t.name AS team_name,
       t.logo_url AS team_logo_url,
       p.start_time,
       p.end_time,
       p.location_id,
       l.name AS location_name,
       p.court_id,
       c.name AS court_name,
       p.status,
       p.booked_by,
       u.first_name || ' ' || u.last_name AS booked_by_name,
       p.created_at,
       p.updated_at
FROM practice.practices p
         JOIN athletic.teams t ON p.team_id = t.id
         JOIN location.locations l ON p.location_id = l.id
         LEFT JOIN location.courts c ON p.court_id = c.id
         LEFT JOIN users.users u ON p.booked_by = u.id
WHERE p.id = $1
`

type GetPracticeByIDRow struct {
	ID           uuid.UUID      `json:"id"`
	TeamID       uuid.UUID      `json:"team_id"`
	TeamName     string         `json:"team_name"`
	TeamLogoUrl  sql.NullString `json:"team_logo_url"`
	StartTime    time.Time      `json:"start_time"`
	EndTime      sql.NullTime   `json:"end_time"`
	LocationID   uuid.UUID      `json:"location_id"`
	LocationName string         `json:"location_name"`
	CourtID      uuid.NullUUID  `json:"court_id"`
	CourtName    sql.NullString `json:"court_name"`
	Status       sql.NullString `json:"status"`
	BookedBy     uuid.NullUUID  `json:"booked_by"`
	BookedByName interface{}    `json:"booked_by_name"`
	CreatedAt    sql.NullTime   `json:"created_at"`
	UpdatedAt    sql.NullTime   `json:"updated_at"`
}

func (q *Queries) GetPracticeByID(ctx context.Context, id uuid.UUID) (GetPracticeByIDRow, error) {
	row := q.db.QueryRowContext(ctx, getPracticeByID, id)
	var i GetPracticeByIDRow
	err := row.Scan(
		&i.ID,
		&i.TeamID,
		&i.TeamName,
		&i.TeamLogoUrl,
		&i.StartTime,
		&i.EndTime,
		&i.LocationID,
		&i.LocationName,
		&i.CourtID,
		&i.CourtName,
		&i.Status,
		&i.BookedBy,
		&i.BookedByName,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listPractices = `-- name: ListPractices :many
SELECT p.id,
       p.team_id,
       t.name AS team_name,
       t.logo_url AS team_logo_url,
       p.start_time,
       p.end_time,
       p.location_id,
       l.name AS location_name,
       p.court_id,
       c.name AS court_name,
       p.status,
       p.booked_by,
       u.first_name || ' ' || u.last_name AS booked_by_name,
       p.created_at,
       p.updated_at
FROM practice.practices p
         JOIN athletic.teams t ON p.team_id = t.id
         JOIN location.locations l ON p.location_id = l.id
         LEFT JOIN location.courts c ON p.court_id = c.id
         LEFT JOIN users.users u ON p.booked_by = u.id
WHERE (
    $1::uuid IS NULL
    OR p.team_id = $1::uuid
)
ORDER BY p.start_time ASC
LIMIT $3 OFFSET $2
`

type ListPracticesParams struct {
	TeamID uuid.NullUUID `json:"team_id"`
	Offset int32         `json:"offset"`
	Limit  int32         `json:"limit"`
}

type ListPracticesRow struct {
	ID           uuid.UUID      `json:"id"`
	TeamID       uuid.UUID      `json:"team_id"`
	TeamName     string         `json:"team_name"`
	TeamLogoUrl  sql.NullString `json:"team_logo_url"`
	StartTime    time.Time      `json:"start_time"`
	EndTime      sql.NullTime   `json:"end_time"`
	LocationID   uuid.UUID      `json:"location_id"`
	LocationName string         `json:"location_name"`
	CourtID      uuid.NullUUID  `json:"court_id"`
	CourtName    sql.NullString `json:"court_name"`
	Status       sql.NullString `json:"status"`
	BookedBy     uuid.NullUUID  `json:"booked_by"`
	BookedByName interface{}    `json:"booked_by_name"`
	CreatedAt    sql.NullTime   `json:"created_at"`
	UpdatedAt    sql.NullTime   `json:"updated_at"`
}

func (q *Queries) ListPractices(ctx context.Context, arg ListPracticesParams) ([]ListPracticesRow, error) {
	rows, err := q.db.QueryContext(ctx, listPractices, arg.TeamID, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListPracticesRow
	for rows.Next() {
		var i ListPracticesRow
		if err := rows.Scan(
			&i.ID,
			&i.TeamID,
			&i.TeamName,
			&i.TeamLogoUrl,
			&i.StartTime,
			&i.EndTime,
			&i.LocationID,
			&i.LocationName,
			&i.CourtID,
			&i.CourtName,
			&i.Status,
			&i.BookedBy,
			&i.BookedByName,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updatePractice = `-- name: UpdatePractice :exec
UPDATE practice.practices
SET team_id=$1,
    start_time=$2,
    end_time=$3,
    court_id=$4,
    location_id=$5,
    status=$6,
    booked_by=$7,
    updated_at=now()
WHERE id=$8
`

type UpdatePracticeParams struct {
	TeamID     uuid.UUID      `json:"team_id"`
	StartTime  time.Time      `json:"start_time"`
	EndTime    sql.NullTime   `json:"end_time"`
	CourtID    uuid.NullUUID  `json:"court_id"`
	LocationID uuid.UUID      `json:"location_id"`
	Status     sql.NullString `json:"status"`
	BookedBy   uuid.NullUUID  `json:"booked_by"`
	ID         uuid.UUID      `json:"id"`
}

func (q *Queries) UpdatePractice(ctx context.Context, arg UpdatePracticeParams) error {
	_, err := q.db.ExecContext(ctx, updatePractice,
		arg.TeamID,
		arg.StartTime,
		arg.EndTime,
		arg.CourtID,
		arg.LocationID,
		arg.Status,
		arg.BookedBy,
		arg.ID,
	)
	return err
}
