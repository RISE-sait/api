// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: waivers.sql

package db_identity

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
	"github.com/lib/pq"
)

const createWaiverSignedStatus = `-- name: CreateWaiverSignedStatus :execrows
WITH prepared_data as (SELECT unnest($1::uuid[])    as user_id,
                              unnest($2::text[]) as waiver_url,
                              unnest($3::bool[])  as is_signed)
INSERT INTO waiver.waiver_signing (user_id, waiver_id, is_signed)
SELECT p.user_id, w.id, p.is_signed
FROM prepared_data p
         LEFT JOIN waiver.waiver w ON w.waiver_url = p.waiver_url
`

type CreateWaiverSignedStatusParams struct {
	UserIDArray    []uuid.UUID `json:"user_id_array"`
	WaiverUrlArray []string    `json:"waiver_url_array"`
	IsSignedArray  []bool      `json:"is_signed_array"`
}

func (q *Queries) CreateWaiverSignedStatus(ctx context.Context, arg CreateWaiverSignedStatusParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, createWaiverSignedStatus, pq.Array(arg.UserIDArray), pq.Array(arg.WaiverUrlArray), pq.Array(arg.IsSignedArray))
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const createWaiverUpload = `-- name: CreateWaiverUpload :one
INSERT INTO waiver.waiver_uploads (user_id, file_url, file_name, file_type, file_size_bytes, uploaded_by, notes)
VALUES ($1, $2, $3, $4, $5, $6, $7)
RETURNING id, user_id, file_url, file_name, file_type, file_size_bytes, uploaded_by, notes, created_at, updated_at
`

type CreateWaiverUploadParams struct {
	UserID        uuid.UUID      `json:"user_id"`
	FileUrl       string         `json:"file_url"`
	FileName      string         `json:"file_name"`
	FileType      string         `json:"file_type"`
	FileSizeBytes sql.NullInt64  `json:"file_size_bytes"`
	UploadedBy    uuid.NullUUID  `json:"uploaded_by"`
	Notes         sql.NullString `json:"notes"`
}

func (q *Queries) CreateWaiverUpload(ctx context.Context, arg CreateWaiverUploadParams) (WaiverWaiverUpload, error) {
	row := q.db.QueryRowContext(ctx, createWaiverUpload,
		arg.UserID,
		arg.FileUrl,
		arg.FileName,
		arg.FileType,
		arg.FileSizeBytes,
		arg.UploadedBy,
		arg.Notes,
	)
	var i WaiverWaiverUpload
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.FileUrl,
		&i.FileName,
		&i.FileType,
		&i.FileSizeBytes,
		&i.UploadedBy,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteWaiverUpload = `-- name: DeleteWaiverUpload :execrows
DELETE FROM waiver.waiver_uploads WHERE id = $1
`

func (q *Queries) DeleteWaiverUpload(ctx context.Context, id uuid.UUID) (int64, error) {
	result, err := q.db.ExecContext(ctx, deleteWaiverUpload, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const getRequiredWaivers = `-- name: GetRequiredWaivers :many
SELECT id, waiver_url, waiver_name, created_at, updated_at
FROM waiver.waiver
`

func (q *Queries) GetRequiredWaivers(ctx context.Context) ([]WaiverWaiver, error) {
	rows, err := q.db.QueryContext(ctx, getRequiredWaivers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []WaiverWaiver
	for rows.Next() {
		var i WaiverWaiver
		if err := rows.Scan(
			&i.ID,
			&i.WaiverUrl,
			&i.WaiverName,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getWaiverUploadById = `-- name: GetWaiverUploadById :one
SELECT id, user_id, file_url, file_name, file_type, file_size_bytes, uploaded_by, notes, created_at, updated_at FROM waiver.waiver_uploads WHERE id = $1
`

func (q *Queries) GetWaiverUploadById(ctx context.Context, id uuid.UUID) (WaiverWaiverUpload, error) {
	row := q.db.QueryRowContext(ctx, getWaiverUploadById, id)
	var i WaiverWaiverUpload
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.FileUrl,
		&i.FileName,
		&i.FileType,
		&i.FileSizeBytes,
		&i.UploadedBy,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getWaiverUploadsByUserId = `-- name: GetWaiverUploadsByUserId :many
SELECT wu.id, wu.user_id, wu.file_url, wu.file_name, wu.file_type, wu.file_size_bytes, wu.uploaded_by, wu.notes, wu.created_at, wu.updated_at,
       u.first_name as uploader_first_name,
       u.last_name as uploader_last_name
FROM waiver.waiver_uploads wu
LEFT JOIN users.users u ON wu.uploaded_by = u.id
WHERE wu.user_id = $1
ORDER BY wu.created_at DESC
`

type GetWaiverUploadsByUserIdRow struct {
	ID                uuid.UUID      `json:"id"`
	UserID            uuid.UUID      `json:"user_id"`
	FileUrl           string         `json:"file_url"`
	FileName          string         `json:"file_name"`
	FileType          string         `json:"file_type"`
	FileSizeBytes     sql.NullInt64  `json:"file_size_bytes"`
	UploadedBy        uuid.NullUUID  `json:"uploaded_by"`
	Notes             sql.NullString `json:"notes"`
	CreatedAt         sql.NullTime   `json:"created_at"`
	UpdatedAt         sql.NullTime   `json:"updated_at"`
	UploaderFirstName sql.NullString `json:"uploader_first_name"`
	UploaderLastName  sql.NullString `json:"uploader_last_name"`
}

func (q *Queries) GetWaiverUploadsByUserId(ctx context.Context, userID uuid.UUID) ([]GetWaiverUploadsByUserIdRow, error) {
	rows, err := q.db.QueryContext(ctx, getWaiverUploadsByUserId, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetWaiverUploadsByUserIdRow
	for rows.Next() {
		var i GetWaiverUploadsByUserIdRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.FileUrl,
			&i.FileName,
			&i.FileType,
			&i.FileSizeBytes,
			&i.UploadedBy,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.UploaderFirstName,
			&i.UploaderLastName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
