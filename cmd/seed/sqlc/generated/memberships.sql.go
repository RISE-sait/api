// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: memberships.sql

package db_seed

import (
	"context"
	"time"

	"github.com/google/uuid"
	"github.com/lib/pq"
)

const insertClientsMembershipPlans = `-- name: InsertClientsMembershipPlans :exec
WITH prepared_data as (SELECT unnest($1::text[])    as customer_email,
                              unnest($2::text[])    as membership_plan_name,
                              unnest($3::timestamptz[]) as start_date,
                              unnest($4::timestamptz[]) as renewal_date)
INSERT
INTO users.customer_membership_plans (customer_id, membership_plan_id, start_date, renewal_date)
SELECT u.id,
       mp.id,
       p.start_date,
       NULLIF(p.renewal_date, '1970-01-01 00:00:00+00'::timestamptz)
FROM prepared_data p
         JOIN users.users u ON u.email = p.customer_email
         JOIN membership.membership_plans mp ON mp.name = membership_plan_name
`

type InsertClientsMembershipPlansParams struct {
	CustomerEmailArray []string    `json:"customer_email_array"`
	MembershipPlanName []string    `json:"membership_plan_name"`
	StartDateArray     []time.Time `json:"start_date_array"`
	RenewalDateArray   []time.Time `json:"renewal_date_array"`
}

func (q *Queries) InsertClientsMembershipPlans(ctx context.Context, arg InsertClientsMembershipPlansParams) error {
	_, err := q.db.ExecContext(ctx, insertClientsMembershipPlans,
		pq.Array(arg.CustomerEmailArray),
		pq.Array(arg.MembershipPlanName),
		pq.Array(arg.StartDateArray),
		pq.Array(arg.RenewalDateArray),
	)
	return err
}

const insertMembershipPlans = `-- name: InsertMembershipPlans :exec
INSERT INTO membership.membership_plans (name, stripe_joining_fee_id, stripe_price_id, membership_id, amt_periods)
SELECT name,
       stripe_joining_fee_id,
       stripe_price_id,
       (SELECT id FROM membership.memberships m WHERE m.name = membership_name),
       CASE WHEN ap.amt_periods = 0 THEN NULL ELSE ap.amt_periods END
FROM unnest($1::text[]) WITH ORDINALITY AS n(name, ord)
         JOIN
     unnest($2::varchar[]) WITH ORDINALITY AS f(stripe_joining_fee_id, ord) ON n.ord = f.ord
         JOIN
     unnest($3::varchar[]) WITH ORDINALITY AS p(stripe_price_id, ord) ON n.ord = p.ord
         JOIN
     unnest($4::text[]) WITH ORDINALITY AS m(membership_name, ord) ON n.ord = m.ord
         JOIN
     unnest($5::int[]) WITH ORDINALITY AS ap(amt_periods, ord) ON n.ord = ap.ord
RETURNING id
`

type InsertMembershipPlansParams struct {
	NameArray               []string `json:"name_array"`
	StripeJoiningFeeIDArray []string `json:"stripe_joining_fee_id_array"`
	StripePriceIDArray      []string `json:"stripe_price_id_array"`
	MembershipNameArray     []string `json:"membership_name_array"`
	AmtPeriodsArray         []int32  `json:"amt_periods_array"`
}

func (q *Queries) InsertMembershipPlans(ctx context.Context, arg InsertMembershipPlansParams) error {
	_, err := q.db.ExecContext(ctx, insertMembershipPlans,
		pq.Array(arg.NameArray),
		pq.Array(arg.StripeJoiningFeeIDArray),
		pq.Array(arg.StripePriceIDArray),
		pq.Array(arg.MembershipNameArray),
		pq.Array(arg.AmtPeriodsArray),
	)
	return err
}

const insertMemberships = `-- name: InsertMemberships :many
INSERT INTO membership.memberships (name, description, benefits)
VALUES (unnest($1::text[]), unnest($2::text[]), unnest($3::text[]))
RETURNING id
`

type InsertMembershipsParams struct {
	NameArray        []string `json:"name_array"`
	DescriptionArray []string `json:"description_array"`
	BenefitsArray    []string `json:"benefits_array"`
}

func (q *Queries) InsertMemberships(ctx context.Context, arg InsertMembershipsParams) ([]uuid.UUID, error) {
	rows, err := q.db.QueryContext(ctx, insertMemberships, pq.Array(arg.NameArray), pq.Array(arg.DescriptionArray), pq.Array(arg.BenefitsArray))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []uuid.UUID
	for rows.Next() {
		var id uuid.UUID
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
