// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: credit.sql

package db_user

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
)

const checkCustomerHasSufficientCredits = `-- name: CheckCustomerHasSufficientCredits :one
SELECT credits >= $2 as has_sufficient
FROM users.customer_credits
WHERE customer_id = $1
`

type CheckCustomerHasSufficientCreditsParams struct {
	CustomerID uuid.UUID `json:"customer_id"`
	Credits    int32     `json:"credits"`
}

// Check if customer has enough credits for a transaction
func (q *Queries) CheckCustomerHasSufficientCredits(ctx context.Context, arg CheckCustomerHasSufficientCreditsParams) (bool, error) {
	row := q.db.QueryRowContext(ctx, checkCustomerHasSufficientCredits, arg.CustomerID, arg.Credits)
	var has_sufficient bool
	err := row.Scan(&has_sufficient)
	return has_sufficient, err
}

const checkWeeklyCreditLimit = `-- name: CheckWeeklyCreditLimit :one
SELECT 
    COALESCE(wcu.credits_used, 0) as current_usage,
    mp.weekly_credit_limit,
    CASE 
        WHEN mp.weekly_credit_limit IS NULL THEN true  -- Non-credit membership
        WHEN mp.weekly_credit_limit = 0 THEN true      -- Unlimited credits
        WHEN COALESCE(wcu.credits_used, 0) + $3 <= mp.weekly_credit_limit THEN true
        ELSE false
    END as can_use_credits
FROM users.customer_membership_plans cmp
JOIN membership.membership_plans mp ON cmp.membership_plan_id = mp.id
LEFT JOIN users.weekly_credit_usage wcu ON (
    wcu.customer_id = $1 AND 
    wcu.week_start_date = $2
)
WHERE cmp.customer_id = $1 
  AND cmp.status = 'active'
ORDER BY cmp.created_at DESC
LIMIT 1
`

type CheckWeeklyCreditLimitParams struct {
	CustomerID    uuid.UUID `json:"customer_id"`
	WeekStartDate time.Time `json:"week_start_date"`
	CreditsUsed   int32     `json:"credits_used"`
}

type CheckWeeklyCreditLimitRow struct {
	CurrentUsage      int32         `json:"current_usage"`
	WeeklyCreditLimit sql.NullInt32 `json:"weekly_credit_limit"`
	CanUseCredits     bool          `json:"can_use_credits"`
}

// Check if customer can use specified credits without exceeding weekly limit
func (q *Queries) CheckWeeklyCreditLimit(ctx context.Context, arg CheckWeeklyCreditLimitParams) (CheckWeeklyCreditLimitRow, error) {
	row := q.db.QueryRowContext(ctx, checkWeeklyCreditLimit, arg.CustomerID, arg.WeekStartDate, arg.CreditsUsed)
	var i CheckWeeklyCreditLimitRow
	err := row.Scan(&i.CurrentUsage, &i.WeeklyCreditLimit, &i.CanUseCredits)
	return i, err
}

const createCustomerCredits = `-- name: CreateCustomerCredits :exec
INSERT INTO users.customer_credits (customer_id, credits)
VALUES ($1, $2)
ON CONFLICT (customer_id) DO NOTHING
`

type CreateCustomerCreditsParams struct {
	CustomerID uuid.UUID `json:"customer_id"`
	Credits    int32     `json:"credits"`
}

// Create customer credits record with initial balance
func (q *Queries) CreateCustomerCredits(ctx context.Context, arg CreateCustomerCreditsParams) error {
	_, err := q.db.ExecContext(ctx, createCustomerCredits, arg.CustomerID, arg.Credits)
	return err
}

const deductCredits = `-- name: DeductCredits :execrows
UPDATE users.customer_credits
SET credits = credits - $2
WHERE customer_id = $1 AND credits >= $2
`

type DeductCreditsParams struct {
	CustomerID uuid.UUID `json:"customer_id"`
	Credits    int32     `json:"credits"`
}

// Deduct credits only if customer has sufficient balance
func (q *Queries) DeductCredits(ctx context.Context, arg DeductCreditsParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, deductCredits, arg.CustomerID, arg.Credits)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const getActiveCustomerMembershipPlanID = `-- name: GetActiveCustomerMembershipPlanID :one
SELECT membership_plan_id
FROM users.customer_membership_plans
WHERE customer_id = $1 
  AND status = 'active'
ORDER BY created_at DESC
LIMIT 1
`

// Get customer's active membership plan ID
func (q *Queries) GetActiveCustomerMembershipPlanID(ctx context.Context, customerID uuid.UUID) (uuid.UUID, error) {
	row := q.db.QueryRowContext(ctx, getActiveCustomerMembershipPlanID, customerID)
	var membership_plan_id uuid.UUID
	err := row.Scan(&membership_plan_id)
	return membership_plan_id, err
}

const getCustomerCreditTransactions = `-- name: GetCustomerCreditTransactions :many
SELECT id, customer_id, amount, transaction_type, event_id, description, created_at
FROM users.credit_transactions
WHERE customer_id = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type GetCustomerCreditTransactionsParams struct {
	CustomerID uuid.UUID `json:"customer_id"`
	Limit      int32     `json:"limit"`
	Offset     int32     `json:"offset"`
}

// Get customer's credit transaction history with pagination
func (q *Queries) GetCustomerCreditTransactions(ctx context.Context, arg GetCustomerCreditTransactionsParams) ([]UsersCreditTransaction, error) {
	rows, err := q.db.QueryContext(ctx, getCustomerCreditTransactions, arg.CustomerID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UsersCreditTransaction
	for rows.Next() {
		var i UsersCreditTransaction
		if err := rows.Scan(
			&i.ID,
			&i.CustomerID,
			&i.Amount,
			&i.TransactionType,
			&i.EventID,
			&i.Description,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCustomerCredits = `-- name: GetCustomerCredits :one

SELECT credits
FROM users.customer_credits
WHERE customer_id = $1
`

// Customer Credits Queries
// Get customer's current credit balance
func (q *Queries) GetCustomerCredits(ctx context.Context, customerID uuid.UUID) (int32, error) {
	row := q.db.QueryRowContext(ctx, getCustomerCredits, customerID)
	var credits int32
	err := row.Scan(&credits)
	return credits, err
}

const getCustomerMembershipPlan = `-- name: GetCustomerMembershipPlan :one
SELECT mp.credit_allocation, mp.weekly_credit_limit
FROM users.customer_membership_plans cmp
JOIN membership.membership_plans mp ON cmp.membership_plan_id = mp.id
WHERE cmp.customer_id = $1 
  AND cmp.status = 'active'
ORDER BY cmp.created_at DESC
LIMIT 1
`

type GetCustomerMembershipPlanRow struct {
	CreditAllocation  sql.NullInt32 `json:"credit_allocation"`
	WeeklyCreditLimit sql.NullInt32 `json:"weekly_credit_limit"`
}

// Get customer's current membership plan with credit info
func (q *Queries) GetCustomerMembershipPlan(ctx context.Context, customerID uuid.UUID) (GetCustomerMembershipPlanRow, error) {
	row := q.db.QueryRowContext(ctx, getCustomerMembershipPlan, customerID)
	var i GetCustomerMembershipPlanRow
	err := row.Scan(&i.CreditAllocation, &i.WeeklyCreditLimit)
	return i, err
}

const getEventCreditCost = `-- name: GetEventCreditCost :one

SELECT credit_cost
FROM events.events
WHERE id = $1
`

// Event Credit Cost Queries
// Get the credit cost for a specific event
func (q *Queries) GetEventCreditCost(ctx context.Context, id uuid.UUID) (sql.NullInt32, error) {
	row := q.db.QueryRowContext(ctx, getEventCreditCost, id)
	var credit_cost sql.NullInt32
	err := row.Scan(&credit_cost)
	return credit_cost, err
}

const getEventCreditTransactions = `-- name: GetEventCreditTransactions :many
SELECT ct.id, ct.customer_id, ct.amount, ct.transaction_type, ct.description, ct.created_at,
       u.first_name, u.last_name, u.email
FROM users.credit_transactions ct
JOIN users.users u ON ct.customer_id = u.id
WHERE ct.event_id = $1
ORDER BY ct.created_at DESC
`

type GetEventCreditTransactionsRow struct {
	ID              uuid.UUID             `json:"id"`
	CustomerID      uuid.UUID             `json:"customer_id"`
	Amount          int32                 `json:"amount"`
	TransactionType CreditTransactionType `json:"transaction_type"`
	Description     sql.NullString        `json:"description"`
	CreatedAt       sql.NullTime          `json:"created_at"`
	FirstName       string                `json:"first_name"`
	LastName        string                `json:"last_name"`
	Email           sql.NullString        `json:"email"`
}

// Get all credit transactions for a specific event
func (q *Queries) GetEventCreditTransactions(ctx context.Context, eventID uuid.NullUUID) ([]GetEventCreditTransactionsRow, error) {
	rows, err := q.db.QueryContext(ctx, getEventCreditTransactions, eventID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetEventCreditTransactionsRow
	for rows.Next() {
		var i GetEventCreditTransactionsRow
		if err := rows.Scan(
			&i.ID,
			&i.CustomerID,
			&i.Amount,
			&i.TransactionType,
			&i.Description,
			&i.CreatedAt,
			&i.FirstName,
			&i.LastName,
			&i.Email,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getWeeklyCreditsUsed = `-- name: GetWeeklyCreditsUsed :one

SELECT COALESCE(credits_used, 0) as credits_used
FROM users.weekly_credit_usage
WHERE customer_id = $1 
  AND week_start_date = $2
`

type GetWeeklyCreditsUsedParams struct {
	CustomerID    uuid.UUID `json:"customer_id"`
	WeekStartDate time.Time `json:"week_start_date"`
}

// Weekly Credit Usage Queries
// Get customer's credit usage for the current week
func (q *Queries) GetWeeklyCreditsUsed(ctx context.Context, arg GetWeeklyCreditsUsedParams) (int32, error) {
	row := q.db.QueryRowContext(ctx, getWeeklyCreditsUsed, arg.CustomerID, arg.WeekStartDate)
	var credits_used int32
	err := row.Scan(&credits_used)
	return credits_used, err
}

const logCreditTransaction = `-- name: LogCreditTransaction :exec

INSERT INTO users.credit_transactions (customer_id, amount, transaction_type, event_id, description)
VALUES ($1, $2, $3, $4, $5)
`

type LogCreditTransactionParams struct {
	CustomerID      uuid.UUID             `json:"customer_id"`
	Amount          int32                 `json:"amount"`
	TransactionType CreditTransactionType `json:"transaction_type"`
	EventID         uuid.NullUUID         `json:"event_id"`
	Description     sql.NullString        `json:"description"`
}

// Credit Transaction Queries
// Log a credit transaction for audit trail
func (q *Queries) LogCreditTransaction(ctx context.Context, arg LogCreditTransactionParams) error {
	_, err := q.db.ExecContext(ctx, logCreditTransaction,
		arg.CustomerID,
		arg.Amount,
		arg.TransactionType,
		arg.EventID,
		arg.Description,
	)
	return err
}

const refundCredits = `-- name: RefundCredits :execrows
UPDATE users.customer_credits
SET credits = credits + $2
WHERE customer_id = $1
`

type RefundCreditsParams struct {
	CustomerID uuid.UUID `json:"customer_id"`
	Credits    int32     `json:"credits"`
}

// Add credits back to customer's account
func (q *Queries) RefundCredits(ctx context.Context, arg RefundCreditsParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, refundCredits, arg.CustomerID, arg.Credits)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const updateCustomerCredits = `-- name: UpdateCustomerCredits :execrows
UPDATE users.customer_credits
SET credits = $2
WHERE customer_id = $1
`

type UpdateCustomerCreditsParams struct {
	CustomerID uuid.UUID `json:"customer_id"`
	Credits    int32     `json:"credits"`
}

// Update customer's credit balance directly
func (q *Queries) UpdateCustomerCredits(ctx context.Context, arg UpdateCustomerCreditsParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, updateCustomerCredits, arg.CustomerID, arg.Credits)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const updateEventCreditCost = `-- name: UpdateEventCreditCost :execrows
UPDATE events.events
SET credit_cost = $2
WHERE id = $1
`

type UpdateEventCreditCostParams struct {
	ID         uuid.UUID     `json:"id"`
	CreditCost sql.NullInt32 `json:"credit_cost"`
}

// Update the credit cost for an event
func (q *Queries) UpdateEventCreditCost(ctx context.Context, arg UpdateEventCreditCostParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, updateEventCreditCost, arg.ID, arg.CreditCost)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const updateWeeklyCreditsUsed = `-- name: UpdateWeeklyCreditsUsed :exec
INSERT INTO users.weekly_credit_usage (customer_id, week_start_date, credits_used, updated_at)
VALUES ($1, $2, $3, NOW())
ON CONFLICT (customer_id, week_start_date) 
DO UPDATE SET 
    credits_used = users.weekly_credit_usage.credits_used + EXCLUDED.credits_used,
    updated_at = NOW()
`

type UpdateWeeklyCreditsUsedParams struct {
	CustomerID    uuid.UUID `json:"customer_id"`
	WeekStartDate time.Time `json:"week_start_date"`
	CreditsUsed   int32     `json:"credits_used"`
}

// Update (or insert) weekly credit usage for a customer
func (q *Queries) UpdateWeeklyCreditsUsed(ctx context.Context, arg UpdateWeeklyCreditsUsedParams) error {
	_, err := q.db.ExecContext(ctx, updateWeeklyCreditsUsed, arg.CustomerID, arg.WeekStartDate, arg.CreditsUsed)
	return err
}
