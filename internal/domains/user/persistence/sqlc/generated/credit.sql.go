// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: credit.sql

package db_user

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
)

const checkCustomerHasSufficientCredits = `-- name: CheckCustomerHasSufficientCredits :one
SELECT credits >= $2 as has_sufficient
FROM users.customer_credits
WHERE customer_id = $1
`

type CheckCustomerHasSufficientCreditsParams struct {
	CustomerID uuid.UUID `json:"customer_id"`
	Credits    int32     `json:"credits"`
}

// Check if customer has enough credits for a transaction
func (q *Queries) CheckCustomerHasSufficientCredits(ctx context.Context, arg CheckCustomerHasSufficientCreditsParams) (bool, error) {
	row := q.db.QueryRowContext(ctx, checkCustomerHasSufficientCredits, arg.CustomerID, arg.Credits)
	var has_sufficient bool
	err := row.Scan(&has_sufficient)
	return has_sufficient, err
}

const checkWeeklyCreditLimit = `-- name: CheckWeeklyCreditLimit :one
SELECT
    COALESCE(wcu.credits_used, 0) as current_usage,
    COALESCE(cacp.weekly_credit_limit, mp.weekly_credit_limit, 0) as weekly_credit_limit,
    CASE
        -- First check if they have an active credit package
        WHEN cacp.weekly_credit_limit IS NOT NULL THEN
            CASE
                WHEN cacp.weekly_credit_limit = 0 THEN true  -- Unlimited credits
                WHEN COALESCE(wcu.credits_used, 0) + $3 <= cacp.weekly_credit_limit THEN true
                ELSE false
            END
        -- Otherwise check membership plan
        WHEN mp.weekly_credit_limit IS NOT NULL THEN
            CASE
                WHEN mp.weekly_credit_limit = 0 THEN true  -- Unlimited credits
                WHEN COALESCE(wcu.credits_used, 0) + $3 <= mp.weekly_credit_limit THEN true
                ELSE false
            END
        -- No active package or plan - allow usage (no limit)
        ELSE true
    END as can_use_credits
FROM (SELECT 1) AS dummy  -- Dummy table to ensure we always get a row
LEFT JOIN users.customer_active_credit_package cacp ON cacp.customer_id = $1
LEFT JOIN users.customer_membership_plans cmp ON (cmp.customer_id = $1 AND cmp.status = 'active')
LEFT JOIN membership.membership_plans mp ON cmp.membership_plan_id = mp.id
LEFT JOIN users.weekly_credit_usage wcu ON (
    wcu.customer_id = $1 AND
    wcu.week_start_date = $2
)
ORDER BY cmp.created_at DESC
LIMIT 1
`

type CheckWeeklyCreditLimitParams struct {
	CustomerID    uuid.UUID `json:"customer_id"`
	WeekStartDate time.Time `json:"week_start_date"`
	CreditsUsed   int32     `json:"credits_used"`
}

type CheckWeeklyCreditLimitRow struct {
	CurrentUsage      int32 `json:"current_usage"`
	WeeklyCreditLimit int32 `json:"weekly_credit_limit"`
	CanUseCredits     bool  `json:"can_use_credits"`
}

// Check if customer can use specified credits without exceeding weekly limit
// Prioritizes active credit package over membership plan
func (q *Queries) CheckWeeklyCreditLimit(ctx context.Context, arg CheckWeeklyCreditLimitParams) (CheckWeeklyCreditLimitRow, error) {
	row := q.db.QueryRowContext(ctx, checkWeeklyCreditLimit, arg.CustomerID, arg.WeekStartDate, arg.CreditsUsed)
	var i CheckWeeklyCreditLimitRow
	err := row.Scan(&i.CurrentUsage, &i.WeeklyCreditLimit, &i.CanUseCredits)
	return i, err
}

const createCustomerCredits = `-- name: CreateCustomerCredits :exec
INSERT INTO users.customer_credits (customer_id, credits)
VALUES ($1, $2)
ON CONFLICT (customer_id) DO NOTHING
`

type CreateCustomerCreditsParams struct {
	CustomerID uuid.UUID `json:"customer_id"`
	Credits    int32     `json:"credits"`
}

// Create customer credits record with initial balance
func (q *Queries) CreateCustomerCredits(ctx context.Context, arg CreateCustomerCreditsParams) error {
	_, err := q.db.ExecContext(ctx, createCustomerCredits, arg.CustomerID, arg.Credits)
	return err
}

const deductCredits = `-- name: DeductCredits :execrows
UPDATE users.customer_credits
SET credits = credits - $2
WHERE customer_id = $1 AND credits >= $2
`

type DeductCreditsParams struct {
	CustomerID uuid.UUID `json:"customer_id"`
	Credits    int32     `json:"credits"`
}

// Deduct credits only if customer has sufficient balance
func (q *Queries) DeductCredits(ctx context.Context, arg DeductCreditsParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, deductCredits, arg.CustomerID, arg.Credits)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const getActiveCustomerMembershipPlanID = `-- name: GetActiveCustomerMembershipPlanID :one
SELECT membership_plan_id
FROM users.customer_membership_plans
WHERE customer_id = $1 
  AND status = 'active'
ORDER BY created_at DESC
LIMIT 1
`

// Get customer's active membership plan ID
func (q *Queries) GetActiveCustomerMembershipPlanID(ctx context.Context, customerID uuid.UUID) (uuid.UUID, error) {
	row := q.db.QueryRowContext(ctx, getActiveCustomerMembershipPlanID, customerID)
	var membership_plan_id uuid.UUID
	err := row.Scan(&membership_plan_id)
	return membership_plan_id, err
}

const getCreditRefundLogs = `-- name: GetCreditRefundLogs :many
SELECT
    crl.id,
    crl.customer_id,
    crl.event_id,
    crl.performed_by,
    crl.credits_refunded,
    crl.event_name,
    crl.event_start_at,
    crl.program_name,
    crl.location_name,
    crl.staff_role,
    crl.reason,
    crl.ip_address,
    crl.created_at,
    cu.first_name as customer_first_name,
    cu.last_name as customer_last_name,
    su.first_name as staff_first_name,
    su.last_name as staff_last_name
FROM audit.credit_refund_logs crl
JOIN users.users cu ON crl.customer_id = cu.id
JOIN users.users su ON crl.performed_by = su.id
WHERE ($3::uuid IS NULL OR crl.customer_id = $3)
  AND ($4::uuid IS NULL OR crl.event_id = $4)
ORDER BY crl.created_at DESC
LIMIT $1 OFFSET $2
`

type GetCreditRefundLogsParams struct {
	Limit      int32         `json:"limit"`
	Offset     int32         `json:"offset"`
	CustomerID uuid.NullUUID `json:"customer_id"`
	EventID    uuid.NullUUID `json:"event_id"`
}

type GetCreditRefundLogsRow struct {
	ID                uuid.UUID      `json:"id"`
	CustomerID        uuid.UUID      `json:"customer_id"`
	EventID           uuid.NullUUID  `json:"event_id"`
	PerformedBy       uuid.UUID      `json:"performed_by"`
	CreditsRefunded   int32          `json:"credits_refunded"`
	EventName         sql.NullString `json:"event_name"`
	EventStartAt      sql.NullTime   `json:"event_start_at"`
	ProgramName       sql.NullString `json:"program_name"`
	LocationName      sql.NullString `json:"location_name"`
	StaffRole         sql.NullString `json:"staff_role"`
	Reason            sql.NullString `json:"reason"`
	IpAddress         sql.NullString `json:"ip_address"`
	CreatedAt         sql.NullTime   `json:"created_at"`
	CustomerFirstName string         `json:"customer_first_name"`
	CustomerLastName  string         `json:"customer_last_name"`
	StaffFirstName    string         `json:"staff_first_name"`
	StaffLastName     string         `json:"staff_last_name"`
}

// Get credit refund audit logs with customer and staff names
func (q *Queries) GetCreditRefundLogs(ctx context.Context, arg GetCreditRefundLogsParams) ([]GetCreditRefundLogsRow, error) {
	rows, err := q.db.QueryContext(ctx, getCreditRefundLogs,
		arg.Limit,
		arg.Offset,
		arg.CustomerID,
		arg.EventID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCreditRefundLogsRow
	for rows.Next() {
		var i GetCreditRefundLogsRow
		if err := rows.Scan(
			&i.ID,
			&i.CustomerID,
			&i.EventID,
			&i.PerformedBy,
			&i.CreditsRefunded,
			&i.EventName,
			&i.EventStartAt,
			&i.ProgramName,
			&i.LocationName,
			&i.StaffRole,
			&i.Reason,
			&i.IpAddress,
			&i.CreatedAt,
			&i.CustomerFirstName,
			&i.CustomerLastName,
			&i.StaffFirstName,
			&i.StaffLastName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCustomerCreditTransactions = `-- name: GetCustomerCreditTransactions :many
SELECT id, customer_id, amount, transaction_type, event_id, description, created_at
FROM users.credit_transactions
WHERE customer_id = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type GetCustomerCreditTransactionsParams struct {
	CustomerID uuid.UUID `json:"customer_id"`
	Limit      int32     `json:"limit"`
	Offset     int32     `json:"offset"`
}

// Get customer's credit transaction history with pagination
func (q *Queries) GetCustomerCreditTransactions(ctx context.Context, arg GetCustomerCreditTransactionsParams) ([]UsersCreditTransaction, error) {
	rows, err := q.db.QueryContext(ctx, getCustomerCreditTransactions, arg.CustomerID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UsersCreditTransaction
	for rows.Next() {
		var i UsersCreditTransaction
		if err := rows.Scan(
			&i.ID,
			&i.CustomerID,
			&i.Amount,
			&i.TransactionType,
			&i.EventID,
			&i.Description,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCustomerCredits = `-- name: GetCustomerCredits :one

SELECT credits
FROM users.customer_credits
WHERE customer_id = $1
`

// Customer Credits Queries
// Get customer's current credit balance
func (q *Queries) GetCustomerCredits(ctx context.Context, customerID uuid.UUID) (int32, error) {
	row := q.db.QueryRowContext(ctx, getCustomerCredits, customerID)
	var credits int32
	err := row.Scan(&credits)
	return credits, err
}

const getCustomerMembershipPlan = `-- name: GetCustomerMembershipPlan :one
SELECT mp.credit_allocation, mp.weekly_credit_limit
FROM users.customer_membership_plans cmp
JOIN membership.membership_plans mp ON cmp.membership_plan_id = mp.id
WHERE cmp.customer_id = $1 
  AND cmp.status = 'active'
ORDER BY cmp.created_at DESC
LIMIT 1
`

type GetCustomerMembershipPlanRow struct {
	CreditAllocation  sql.NullInt32 `json:"credit_allocation"`
	WeeklyCreditLimit sql.NullInt32 `json:"weekly_credit_limit"`
}

// Get customer's current membership plan with credit info
func (q *Queries) GetCustomerMembershipPlan(ctx context.Context, customerID uuid.UUID) (GetCustomerMembershipPlanRow, error) {
	row := q.db.QueryRowContext(ctx, getCustomerMembershipPlan, customerID)
	var i GetCustomerMembershipPlanRow
	err := row.Scan(&i.CreditAllocation, &i.WeeklyCreditLimit)
	return i, err
}

const getEnrollmentCreditTransaction = `-- name: GetEnrollmentCreditTransaction :one

SELECT id, amount, created_at
FROM users.credit_transactions
WHERE customer_id = $1
  AND event_id = $2
  AND transaction_type = 'enrollment'
ORDER BY created_at DESC
LIMIT 1
`

type GetEnrollmentCreditTransactionParams struct {
	CustomerID uuid.UUID     `json:"customer_id"`
	EventID    uuid.NullUUID `json:"event_id"`
}

type GetEnrollmentCreditTransactionRow struct {
	ID        uuid.UUID    `json:"id"`
	Amount    int32        `json:"amount"`
	CreatedAt sql.NullTime `json:"created_at"`
}

// Credit Refund Queries
// Get the credit transaction for a customer's event enrollment (to determine refund amount)
func (q *Queries) GetEnrollmentCreditTransaction(ctx context.Context, arg GetEnrollmentCreditTransactionParams) (GetEnrollmentCreditTransactionRow, error) {
	row := q.db.QueryRowContext(ctx, getEnrollmentCreditTransaction, arg.CustomerID, arg.EventID)
	var i GetEnrollmentCreditTransactionRow
	err := row.Scan(&i.ID, &i.Amount, &i.CreatedAt)
	return i, err
}

const getEventCreditCost = `-- name: GetEventCreditCost :one

SELECT credit_cost
FROM events.events
WHERE id = $1
`

// Event Credit Cost Queries
// Get the credit cost for a specific event
func (q *Queries) GetEventCreditCost(ctx context.Context, id uuid.UUID) (sql.NullInt32, error) {
	row := q.db.QueryRowContext(ctx, getEventCreditCost, id)
	var credit_cost sql.NullInt32
	err := row.Scan(&credit_cost)
	return credit_cost, err
}

const getEventCreditTransactions = `-- name: GetEventCreditTransactions :many
SELECT ct.id, ct.customer_id, ct.amount, ct.transaction_type, ct.description, ct.created_at,
       u.first_name, u.last_name, u.email
FROM users.credit_transactions ct
JOIN users.users u ON ct.customer_id = u.id
WHERE ct.event_id = $1
ORDER BY ct.created_at DESC
`

type GetEventCreditTransactionsRow struct {
	ID              uuid.UUID             `json:"id"`
	CustomerID      uuid.UUID             `json:"customer_id"`
	Amount          int32                 `json:"amount"`
	TransactionType CreditTransactionType `json:"transaction_type"`
	Description     sql.NullString        `json:"description"`
	CreatedAt       sql.NullTime          `json:"created_at"`
	FirstName       string                `json:"first_name"`
	LastName        string                `json:"last_name"`
	Email           sql.NullString        `json:"email"`
}

// Get all credit transactions for a specific event
func (q *Queries) GetEventCreditTransactions(ctx context.Context, eventID uuid.NullUUID) ([]GetEventCreditTransactionsRow, error) {
	rows, err := q.db.QueryContext(ctx, getEventCreditTransactions, eventID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetEventCreditTransactionsRow
	for rows.Next() {
		var i GetEventCreditTransactionsRow
		if err := rows.Scan(
			&i.ID,
			&i.CustomerID,
			&i.Amount,
			&i.TransactionType,
			&i.Description,
			&i.CreatedAt,
			&i.FirstName,
			&i.LastName,
			&i.Email,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getWeeklyCreditsUsed = `-- name: GetWeeklyCreditsUsed :one

SELECT COALESCE(credits_used, 0) as credits_used
FROM users.weekly_credit_usage
WHERE customer_id = $1 
  AND week_start_date = $2
`

type GetWeeklyCreditsUsedParams struct {
	CustomerID    uuid.UUID `json:"customer_id"`
	WeekStartDate time.Time `json:"week_start_date"`
}

// Weekly Credit Usage Queries
// Get customer's credit usage for the current week
func (q *Queries) GetWeeklyCreditsUsed(ctx context.Context, arg GetWeeklyCreditsUsedParams) (int32, error) {
	row := q.db.QueryRowContext(ctx, getWeeklyCreditsUsed, arg.CustomerID, arg.WeekStartDate)
	var credits_used int32
	err := row.Scan(&credits_used)
	return credits_used, err
}

const isCustomerEnrolledInEvent = `-- name: IsCustomerEnrolledInEvent :one
SELECT EXISTS(
    SELECT 1 FROM events.customer_enrollment
    WHERE event_id = $1
    AND customer_id = $2
    AND payment_status IN ('pending', 'paid')
) as is_enrolled
`

type IsCustomerEnrolledInEventParams struct {
	EventID    uuid.UUID `json:"event_id"`
	CustomerID uuid.UUID `json:"customer_id"`
}

// Check if customer is already enrolled in an event (to prevent duplicate credit payments)
func (q *Queries) IsCustomerEnrolledInEvent(ctx context.Context, arg IsCustomerEnrolledInEventParams) (bool, error) {
	row := q.db.QueryRowContext(ctx, isCustomerEnrolledInEvent, arg.EventID, arg.CustomerID)
	var is_enrolled bool
	err := row.Scan(&is_enrolled)
	return is_enrolled, err
}

const logCreditRefundAudit = `-- name: LogCreditRefundAudit :exec
INSERT INTO audit.credit_refund_logs (
    customer_id, event_id, performed_by, credits_refunded,
    event_name, event_start_at, program_name, location_name,
    staff_role, reason, ip_address
) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11)
`

type LogCreditRefundAuditParams struct {
	CustomerID      uuid.UUID      `json:"customer_id"`
	EventID         uuid.NullUUID  `json:"event_id"`
	PerformedBy     uuid.UUID      `json:"performed_by"`
	CreditsRefunded int32          `json:"credits_refunded"`
	EventName       sql.NullString `json:"event_name"`
	EventStartAt    sql.NullTime   `json:"event_start_at"`
	ProgramName     sql.NullString `json:"program_name"`
	LocationName    sql.NullString `json:"location_name"`
	StaffRole       sql.NullString `json:"staff_role"`
	Reason          sql.NullString `json:"reason"`
	IpAddress       sql.NullString `json:"ip_address"`
}

// Log a credit refund to the audit table with full event context
func (q *Queries) LogCreditRefundAudit(ctx context.Context, arg LogCreditRefundAuditParams) error {
	_, err := q.db.ExecContext(ctx, logCreditRefundAudit,
		arg.CustomerID,
		arg.EventID,
		arg.PerformedBy,
		arg.CreditsRefunded,
		arg.EventName,
		arg.EventStartAt,
		arg.ProgramName,
		arg.LocationName,
		arg.StaffRole,
		arg.Reason,
		arg.IpAddress,
	)
	return err
}

const logCreditTransaction = `-- name: LogCreditTransaction :exec

INSERT INTO users.credit_transactions (customer_id, amount, transaction_type, event_id, description)
VALUES ($1, $2, $3, $4, $5)
`

type LogCreditTransactionParams struct {
	CustomerID      uuid.UUID             `json:"customer_id"`
	Amount          int32                 `json:"amount"`
	TransactionType CreditTransactionType `json:"transaction_type"`
	EventID         uuid.NullUUID         `json:"event_id"`
	Description     sql.NullString        `json:"description"`
}

// Credit Transaction Queries
// Log a credit transaction for audit trail
func (q *Queries) LogCreditTransaction(ctx context.Context, arg LogCreditTransactionParams) error {
	_, err := q.db.ExecContext(ctx, logCreditTransaction,
		arg.CustomerID,
		arg.Amount,
		arg.TransactionType,
		arg.EventID,
		arg.Description,
	)
	return err
}

const reduceWeeklyCreditsUsed = `-- name: ReduceWeeklyCreditsUsed :exec
UPDATE users.weekly_credit_usage
SET credits_used = GREATEST(credits_used - $3, 0),
    updated_at = NOW()
WHERE customer_id = $1 AND week_start_date = $2
`

type ReduceWeeklyCreditsUsedParams struct {
	CustomerID    uuid.UUID `json:"customer_id"`
	WeekStartDate time.Time `json:"week_start_date"`
	CreditsUsed   int32     `json:"credits_used"`
}

// Reduce weekly credit usage when credits are refunded (ensures it doesn't go below 0)
func (q *Queries) ReduceWeeklyCreditsUsed(ctx context.Context, arg ReduceWeeklyCreditsUsedParams) error {
	_, err := q.db.ExecContext(ctx, reduceWeeklyCreditsUsed, arg.CustomerID, arg.WeekStartDate, arg.CreditsUsed)
	return err
}

const refundCredits = `-- name: RefundCredits :execrows
UPDATE users.customer_credits
SET credits = credits + $2
WHERE customer_id = $1
`

type RefundCreditsParams struct {
	CustomerID uuid.UUID `json:"customer_id"`
	Credits    int32     `json:"credits"`
}

// Add credits back to customer's account
func (q *Queries) RefundCredits(ctx context.Context, arg RefundCreditsParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, refundCredits, arg.CustomerID, arg.Credits)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const updateCustomerCredits = `-- name: UpdateCustomerCredits :execrows
UPDATE users.customer_credits
SET credits = $2
WHERE customer_id = $1
`

type UpdateCustomerCreditsParams struct {
	CustomerID uuid.UUID `json:"customer_id"`
	Credits    int32     `json:"credits"`
}

// Update customer's credit balance directly
func (q *Queries) UpdateCustomerCredits(ctx context.Context, arg UpdateCustomerCreditsParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, updateCustomerCredits, arg.CustomerID, arg.Credits)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const updateEventCreditCost = `-- name: UpdateEventCreditCost :execrows
UPDATE events.events
SET credit_cost = $2
WHERE id = $1
`

type UpdateEventCreditCostParams struct {
	ID         uuid.UUID     `json:"id"`
	CreditCost sql.NullInt32 `json:"credit_cost"`
}

// Update the credit cost for an event
func (q *Queries) UpdateEventCreditCost(ctx context.Context, arg UpdateEventCreditCostParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, updateEventCreditCost, arg.ID, arg.CreditCost)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const updateWeeklyCreditsUsed = `-- name: UpdateWeeklyCreditsUsed :exec
INSERT INTO users.weekly_credit_usage (customer_id, week_start_date, credits_used, updated_at)
VALUES ($1, $2, $3, NOW())
ON CONFLICT (customer_id, week_start_date)
DO UPDATE SET
    credits_used = users.weekly_credit_usage.credits_used + EXCLUDED.credits_used,
    updated_at = NOW()
`

type UpdateWeeklyCreditsUsedParams struct {
	CustomerID    uuid.UUID `json:"customer_id"`
	WeekStartDate time.Time `json:"week_start_date"`
	CreditsUsed   int32     `json:"credits_used"`
}

// Update (or insert) weekly credit usage for a customer
func (q *Queries) UpdateWeeklyCreditsUsed(ctx context.Context, arg UpdateWeeklyCreditsUsedParams) error {
	_, err := q.db.ExecContext(ctx, updateWeeklyCreditsUsed, arg.CustomerID, arg.WeekStartDate, arg.CreditsUsed)
	return err
}
