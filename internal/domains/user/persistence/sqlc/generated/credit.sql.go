// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: credit.sql

package db_user

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
)

const checkCustomerHasSufficientCredits = `-- name: CheckCustomerHasSufficientCredits :one
SELECT credits >= $2 as has_sufficient
FROM users.customer_credits
WHERE customer_id = $1
`

type CheckCustomerHasSufficientCreditsParams struct {
	CustomerID uuid.UUID `json:"customer_id"`
	Credits    int32     `json:"credits"`
}

// Check if customer has enough credits for a transaction
func (q *Queries) CheckCustomerHasSufficientCredits(ctx context.Context, arg CheckCustomerHasSufficientCreditsParams) (bool, error) {
	row := q.db.QueryRowContext(ctx, checkCustomerHasSufficientCredits, arg.CustomerID, arg.Credits)
	var has_sufficient bool
	err := row.Scan(&has_sufficient)
	return has_sufficient, err
}

const createCustomerCredits = `-- name: CreateCustomerCredits :exec
INSERT INTO users.customer_credits (customer_id, credits)
VALUES ($1, $2)
ON CONFLICT (customer_id) DO NOTHING
`

type CreateCustomerCreditsParams struct {
	CustomerID uuid.UUID `json:"customer_id"`
	Credits    int32     `json:"credits"`
}

// Create customer credits record with initial balance
func (q *Queries) CreateCustomerCredits(ctx context.Context, arg CreateCustomerCreditsParams) error {
	_, err := q.db.ExecContext(ctx, createCustomerCredits, arg.CustomerID, arg.Credits)
	return err
}

const deductCredits = `-- name: DeductCredits :execrows
UPDATE users.customer_credits
SET credits = credits - $2
WHERE customer_id = $1 AND credits >= $2
`

type DeductCreditsParams struct {
	CustomerID uuid.UUID `json:"customer_id"`
	Credits    int32     `json:"credits"`
}

// Deduct credits only if customer has sufficient balance
func (q *Queries) DeductCredits(ctx context.Context, arg DeductCreditsParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, deductCredits, arg.CustomerID, arg.Credits)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const getCustomerCreditTransactions = `-- name: GetCustomerCreditTransactions :many
SELECT id, customer_id, amount, transaction_type, event_id, description, created_at
FROM users.credit_transactions
WHERE customer_id = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type GetCustomerCreditTransactionsParams struct {
	CustomerID uuid.UUID `json:"customer_id"`
	Limit      int32     `json:"limit"`
	Offset     int32     `json:"offset"`
}

// Get customer's credit transaction history with pagination
func (q *Queries) GetCustomerCreditTransactions(ctx context.Context, arg GetCustomerCreditTransactionsParams) ([]UsersCreditTransaction, error) {
	rows, err := q.db.QueryContext(ctx, getCustomerCreditTransactions, arg.CustomerID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UsersCreditTransaction
	for rows.Next() {
		var i UsersCreditTransaction
		if err := rows.Scan(
			&i.ID,
			&i.CustomerID,
			&i.Amount,
			&i.TransactionType,
			&i.EventID,
			&i.Description,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCustomerCredits = `-- name: GetCustomerCredits :one

SELECT credits
FROM users.customer_credits
WHERE customer_id = $1
`

// Customer Credits Queries
// Get customer's current credit balance
func (q *Queries) GetCustomerCredits(ctx context.Context, customerID uuid.UUID) (int32, error) {
	row := q.db.QueryRowContext(ctx, getCustomerCredits, customerID)
	var credits int32
	err := row.Scan(&credits)
	return credits, err
}

const getEventCreditCost = `-- name: GetEventCreditCost :one

SELECT credit_cost
FROM events.events
WHERE id = $1
`

// Event Credit Cost Queries
// Get the credit cost for a specific event
func (q *Queries) GetEventCreditCost(ctx context.Context, id uuid.UUID) (sql.NullInt32, error) {
	row := q.db.QueryRowContext(ctx, getEventCreditCost, id)
	var credit_cost sql.NullInt32
	err := row.Scan(&credit_cost)
	return credit_cost, err
}

const getEventCreditTransactions = `-- name: GetEventCreditTransactions :many
SELECT ct.id, ct.customer_id, ct.amount, ct.transaction_type, ct.description, ct.created_at,
       u.first_name, u.last_name, u.email
FROM users.credit_transactions ct
JOIN users.users u ON ct.customer_id = u.id
WHERE ct.event_id = $1
ORDER BY ct.created_at DESC
`

type GetEventCreditTransactionsRow struct {
	ID              uuid.UUID             `json:"id"`
	CustomerID      uuid.UUID             `json:"customer_id"`
	Amount          int32                 `json:"amount"`
	TransactionType CreditTransactionType `json:"transaction_type"`
	Description     sql.NullString        `json:"description"`
	CreatedAt       sql.NullTime          `json:"created_at"`
	FirstName       string                `json:"first_name"`
	LastName        string                `json:"last_name"`
	Email           sql.NullString        `json:"email"`
}

// Get all credit transactions for a specific event
func (q *Queries) GetEventCreditTransactions(ctx context.Context, eventID uuid.NullUUID) ([]GetEventCreditTransactionsRow, error) {
	rows, err := q.db.QueryContext(ctx, getEventCreditTransactions, eventID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetEventCreditTransactionsRow
	for rows.Next() {
		var i GetEventCreditTransactionsRow
		if err := rows.Scan(
			&i.ID,
			&i.CustomerID,
			&i.Amount,
			&i.TransactionType,
			&i.Description,
			&i.CreatedAt,
			&i.FirstName,
			&i.LastName,
			&i.Email,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const logCreditTransaction = `-- name: LogCreditTransaction :exec

INSERT INTO users.credit_transactions (customer_id, amount, transaction_type, event_id, description)
VALUES ($1, $2, $3, $4, $5)
`

type LogCreditTransactionParams struct {
	CustomerID      uuid.UUID             `json:"customer_id"`
	Amount          int32                 `json:"amount"`
	TransactionType CreditTransactionType `json:"transaction_type"`
	EventID         uuid.NullUUID         `json:"event_id"`
	Description     sql.NullString        `json:"description"`
}

// Credit Transaction Queries
// Log a credit transaction for audit trail
func (q *Queries) LogCreditTransaction(ctx context.Context, arg LogCreditTransactionParams) error {
	_, err := q.db.ExecContext(ctx, logCreditTransaction,
		arg.CustomerID,
		arg.Amount,
		arg.TransactionType,
		arg.EventID,
		arg.Description,
	)
	return err
}

const refundCredits = `-- name: RefundCredits :execrows
UPDATE users.customer_credits
SET credits = credits + $2
WHERE customer_id = $1
`

type RefundCreditsParams struct {
	CustomerID uuid.UUID `json:"customer_id"`
	Credits    int32     `json:"credits"`
}

// Add credits back to customer's account
func (q *Queries) RefundCredits(ctx context.Context, arg RefundCreditsParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, refundCredits, arg.CustomerID, arg.Credits)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const updateCustomerCredits = `-- name: UpdateCustomerCredits :execrows
UPDATE users.customer_credits
SET credits = $2
WHERE customer_id = $1
`

type UpdateCustomerCreditsParams struct {
	CustomerID uuid.UUID `json:"customer_id"`
	Credits    int32     `json:"credits"`
}

// Update customer's credit balance directly
func (q *Queries) UpdateCustomerCredits(ctx context.Context, arg UpdateCustomerCreditsParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, updateCustomerCredits, arg.CustomerID, arg.Credits)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const updateEventCreditCost = `-- name: UpdateEventCreditCost :execrows
UPDATE events.events
SET credit_cost = $2
WHERE id = $1
`

type UpdateEventCreditCostParams struct {
	ID         uuid.UUID     `json:"id"`
	CreditCost sql.NullInt32 `json:"credit_cost"`
}

// Update the credit cost for an event
func (q *Queries) UpdateEventCreditCost(ctx context.Context, arg UpdateEventCreditCostParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, updateEventCreditCost, arg.ID, arg.CreditCost)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}
