// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: customer.sql

package db_user

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
)

const archiveCustomer = `-- name: ArchiveCustomer :execrows
UPDATE users.users
SET is_archived = TRUE,
    updated_at = current_timestamp
WHERE id = $1
`

func (q *Queries) ArchiveCustomer(ctx context.Context, id uuid.UUID) (int64, error) {
	result, err := q.db.ExecContext(ctx, archiveCustomer, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const countCustomers = `-- name: CountCustomers :one
SELECT COUNT(*)
FROM users.users u
         LEFT JOIN users.customer_membership_plans cmp ON (
    cmp.customer_id = u.id AND
    cmp.start_date = (SELECT MAX(start_date)
                      FROM users.customer_membership_plans
                      WHERE customer_id = u.id)
    )
         LEFT JOIN membership.membership_plans mp ON mp.id = cmp.membership_plan_id
         LEFT JOIN membership.memberships m ON m.id = mp.membership_id
         LEFT JOIN athletic.athletes a ON u.id = a.id
WHERE u.is_archived = FALSE
  AND (u.parent_id = $1 OR $1 IS NULL)
  AND ($2::varchar IS NULL
  OR u.first_name ILIKE $2 || '%'
  OR u.last_name ILIKE $2 || '%'
  OR u.email ILIKE $2 || '%'
  OR u.phone ILIKE $2 || '%')
  AND NOT EXISTS (SELECT 1 FROM staff.staff s WHERE s.id = u.id)
`

type CountCustomersParams struct {
	ParentID uuid.NullUUID  `json:"parent_id"`
	Search   sql.NullString `json:"search"`
}

func (q *Queries) CountCustomers(ctx context.Context, arg CountCustomersParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, countCustomers, arg.ParentID, arg.Search)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createAthleteInfo = `-- name: CreateAthleteInfo :execrows
INSERT INTO athletic.athletes (id, rebounds, assists, losses, wins, points)
VALUES ($1, $2, $3, $4, $5, $6)
`

type CreateAthleteInfoParams struct {
	ID       uuid.UUID `json:"id"`
	Rebounds int32     `json:"rebounds"`
	Assists  int32     `json:"assists"`
	Losses   int32     `json:"losses"`
	Wins     int32     `json:"wins"`
	Points   int32     `json:"points"`
}

func (q *Queries) CreateAthleteInfo(ctx context.Context, arg CreateAthleteInfoParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, createAthleteInfo,
		arg.ID,
		arg.Rebounds,
		arg.Assists,
		arg.Losses,
		arg.Wins,
		arg.Points,
	)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const getActiveMembershipInfo = `-- name: GetActiveMembershipInfo :one
SELECT
    cmp.id,
    cmp.customer_id,
    cmp.start_date,
    cmp.renewal_date,
    cmp.status,
    cmp.created_at,
    cmp.updated_at,
    cmp.photo_url,
    mp.membership_id,
    cmp.membership_plan_id,
    m.name AS membership_name,
    mp.name AS membership_plan_name
FROM users.customer_membership_plans cmp
    JOIN membership.membership_plans mp ON mp.id = cmp.membership_plan_id
    JOIN membership.memberships m ON m.id = mp.membership_id
WHERE cmp.customer_id = $1
  AND cmp.status = 'active'
ORDER BY cmp.start_date DESC
LIMIT 1
`

type GetActiveMembershipInfoRow struct {
	ID                 uuid.UUID                  `json:"id"`
	CustomerID         uuid.UUID                  `json:"customer_id"`
	StartDate          time.Time                  `json:"start_date"`
	RenewalDate        sql.NullTime               `json:"renewal_date"`
	Status             MembershipMembershipStatus `json:"status"`
	CreatedAt          time.Time                  `json:"created_at"`
	UpdatedAt          time.Time                  `json:"updated_at"`
	PhotoUrl           sql.NullString             `json:"photo_url"`
	MembershipID       uuid.UUID                  `json:"membership_id"`
	MembershipPlanID   uuid.UUID                  `json:"membership_plan_id"`
	MembershipName     string                     `json:"membership_name"`
	MembershipPlanName string                     `json:"membership_plan_name"`
}

func (q *Queries) GetActiveMembershipInfo(ctx context.Context, customerID uuid.UUID) (GetActiveMembershipInfoRow, error) {
	row := q.db.QueryRowContext(ctx, getActiveMembershipInfo, customerID)
	var i GetActiveMembershipInfoRow
	err := row.Scan(
		&i.ID,
		&i.CustomerID,
		&i.StartDate,
		&i.RenewalDate,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.PhotoUrl,
		&i.MembershipID,
		&i.MembershipPlanID,
		&i.MembershipName,
		&i.MembershipPlanName,
	)
	return i, err
}

const getAthletes = `-- name: GetAthletes :many
SELECT
  u.id,
  u.first_name,
  u.last_name,
  a.points,
  a.wins,
  a.losses,
  a.assists,
  a.rebounds,
  a.steals,
  a.photo_url,
  a.team_id
FROM athletic.athletes a
JOIN users.users u ON u.id = a.id
ORDER BY a.points DESC
LIMIT $2 OFFSET $1
`

type GetAthletesParams struct {
	Offset int32 `json:"offset"`
	Limit  int32 `json:"limit"`
}

type GetAthletesRow struct {
	ID        uuid.UUID      `json:"id"`
	FirstName string         `json:"first_name"`
	LastName  string         `json:"last_name"`
	Points    int32          `json:"points"`
	Wins      int32          `json:"wins"`
	Losses    int32          `json:"losses"`
	Assists   int32          `json:"assists"`
	Rebounds  int32          `json:"rebounds"`
	Steals    int32          `json:"steals"`
	PhotoUrl  sql.NullString `json:"photo_url"`
	TeamID    uuid.NullUUID  `json:"team_id"`
}

func (q *Queries) GetAthletes(ctx context.Context, arg GetAthletesParams) ([]GetAthletesRow, error) {
	rows, err := q.db.QueryContext(ctx, getAthletes, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAthletesRow
	for rows.Next() {
		var i GetAthletesRow
		if err := rows.Scan(
			&i.ID,
			&i.FirstName,
			&i.LastName,
			&i.Points,
			&i.Wins,
			&i.Losses,
			&i.Assists,
			&i.Rebounds,
			&i.Steals,
			&i.PhotoUrl,
			&i.TeamID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCustomer = `-- name: GetCustomer :one
SELECT u.id, u.hubspot_id, u.country_alpha2_code, u.gender, u.first_name, u.last_name, u.parent_id, u.phone, u.email, u.has_marketing_email_consent, u.has_sms_consent, u.created_at, u.updated_at, u.dob, u.is_archived,
       m.name           AS membership_name,
       mp.id            AS membership_plan_id,
       mp.name          AS membership_plan_name,
       cmp.start_date   AS membership_start_date,
       cmp.renewal_date AS membership_plan_renewal_date,
       a.points,
       a.wins,
       a.losses,
       a.assists,
       a.rebounds,
       a.steals,
       a.photo_url
FROM users.users u
         LEFT JOIN users.customer_membership_plans cmp ON (
    cmp.customer_id = u.id AND
    cmp.start_date = (SELECT MAX(start_date)
                      FROM users.customer_membership_plans
                      WHERE customer_id = u.id)
    )
         LEFT JOIN membership.membership_plans mp ON mp.id = cmp.membership_plan_id
         LEFT JOIN membership.memberships m ON m.id = mp.membership_id
         LEFT JOIN athletic.athletes a ON u.id = a.id
WHERE u.is_archived = FALSE
  AND (u.id = $1 OR $1 IS NULL)
  AND (u.email = $2 OR $2 IS NULL)
  AND NOT EXISTS (SELECT 1
                  FROM staff.staff s
                  WHERE s.id = u.id)
`

type GetCustomerParams struct {
	ID    uuid.NullUUID  `json:"id"`
	Email sql.NullString `json:"email"`
}

type GetCustomerRow struct {
	ID                        uuid.UUID      `json:"id"`
	HubspotID                 sql.NullString `json:"hubspot_id"`
	CountryAlpha2Code         string         `json:"country_alpha2_code"`
	Gender                    sql.NullString `json:"gender"`
	FirstName                 string         `json:"first_name"`
	LastName                  string         `json:"last_name"`
	ParentID                  uuid.NullUUID  `json:"parent_id"`
	Phone                     sql.NullString `json:"phone"`
	Email                     sql.NullString `json:"email"`
	HasMarketingEmailConsent  bool           `json:"has_marketing_email_consent"`
	HasSmsConsent             bool           `json:"has_sms_consent"`
	CreatedAt                 time.Time      `json:"created_at"`
	UpdatedAt                 time.Time      `json:"updated_at"`
	Dob                       time.Time      `json:"dob"`
	IsArchived                bool           `json:"is_archived"`
	MembershipName            sql.NullString `json:"membership_name"`
	MembershipPlanID          uuid.NullUUID  `json:"membership_plan_id"`
	MembershipPlanName        sql.NullString `json:"membership_plan_name"`
	MembershipStartDate       sql.NullTime   `json:"membership_start_date"`
	MembershipPlanRenewalDate sql.NullTime   `json:"membership_plan_renewal_date"`
	Points                    sql.NullInt32  `json:"points"`
	Wins                      sql.NullInt32  `json:"wins"`
	Losses                    sql.NullInt32  `json:"losses"`
	Assists                   sql.NullInt32  `json:"assists"`
	Rebounds                  sql.NullInt32  `json:"rebounds"`
	Steals                    sql.NullInt32  `json:"steals"`
	PhotoUrl                  sql.NullString `json:"photo_url"`
}

func (q *Queries) GetCustomer(ctx context.Context, arg GetCustomerParams) (GetCustomerRow, error) {
	row := q.db.QueryRowContext(ctx, getCustomer, arg.ID, arg.Email)
	var i GetCustomerRow
	err := row.Scan(
		&i.ID,
		&i.HubspotID,
		&i.CountryAlpha2Code,
		&i.Gender,
		&i.FirstName,
		&i.LastName,
		&i.ParentID,
		&i.Phone,
		&i.Email,
		&i.HasMarketingEmailConsent,
		&i.HasSmsConsent,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Dob,
		&i.IsArchived,
		&i.MembershipName,
		&i.MembershipPlanID,
		&i.MembershipPlanName,
		&i.MembershipStartDate,
		&i.MembershipPlanRenewalDate,
		&i.Points,
		&i.Wins,
		&i.Losses,
		&i.Assists,
		&i.Rebounds,
		&i.Steals,
		&i.PhotoUrl,
	)
	return i, err
}

const getCustomers = `-- name: GetCustomers :many
SELECT u.id, u.hubspot_id, u.country_alpha2_code, u.gender, u.first_name, u.last_name, u.parent_id, u.phone, u.email, u.has_marketing_email_consent, u.has_sms_consent, u.created_at, u.updated_at, u.dob, u.is_archived,
       m.name           AS membership_name,
       mp.id            AS membership_plan_id,
       mp.name          AS membership_plan_name,
       cmp.start_date   AS membership_start_date,
       cmp.renewal_date AS membership_plan_renewal_date,
       a.points,
       a.wins,
       a.losses,
       a.assists,
       a.rebounds,
       a.steals,
       a.photo_url
FROM users.users u
         LEFT JOIN users.customer_membership_plans cmp ON (
    cmp.customer_id = u.id AND
    cmp.start_date = (SELECT MAX(start_date)
                      FROM users.customer_membership_plans
                      WHERE customer_id = u.id)
    )
         LEFT JOIN membership.membership_plans mp ON mp.id = cmp.membership_plan_id
         LEFT JOIN membership.memberships m ON m.id = mp.membership_id
         LEFT JOIN athletic.athletes a ON u.id = a.id
WHERE u.is_archived = FALSE
  AND (u.parent_id = $1 OR $1 IS NULL)
  AND ($2::varchar IS NULL
  OR u.first_name ILIKE $2 || '%'
  OR u.last_name ILIKE $2 || '%' 
  OR u.email ILIKE $2 || '%' 
  OR u.phone ILIKE $2 || '%')
  AND NOT EXISTS (SELECT 1
                  FROM staff.staff s
                  WHERE s.id = u.id)
LIMIT $4 OFFSET $3
`

type GetCustomersParams struct {
	ParentID uuid.NullUUID  `json:"parent_id"`
	Search   sql.NullString `json:"search"`
	Offset   int32          `json:"offset"`
	Limit    int32          `json:"limit"`
}

type GetCustomersRow struct {
	ID                        uuid.UUID      `json:"id"`
	HubspotID                 sql.NullString `json:"hubspot_id"`
	CountryAlpha2Code         string         `json:"country_alpha2_code"`
	Gender                    sql.NullString `json:"gender"`
	FirstName                 string         `json:"first_name"`
	LastName                  string         `json:"last_name"`
	ParentID                  uuid.NullUUID  `json:"parent_id"`
	Phone                     sql.NullString `json:"phone"`
	Email                     sql.NullString `json:"email"`
	HasMarketingEmailConsent  bool           `json:"has_marketing_email_consent"`
	HasSmsConsent             bool           `json:"has_sms_consent"`
	CreatedAt                 time.Time      `json:"created_at"`
	UpdatedAt                 time.Time      `json:"updated_at"`
	Dob                       time.Time      `json:"dob"`
	IsArchived                bool           `json:"is_archived"`
	MembershipName            sql.NullString `json:"membership_name"`
	MembershipPlanID          uuid.NullUUID  `json:"membership_plan_id"`
	MembershipPlanName        sql.NullString `json:"membership_plan_name"`
	MembershipStartDate       sql.NullTime   `json:"membership_start_date"`
	MembershipPlanRenewalDate sql.NullTime   `json:"membership_plan_renewal_date"`
	Points                    sql.NullInt32  `json:"points"`
	Wins                      sql.NullInt32  `json:"wins"`
	Losses                    sql.NullInt32  `json:"losses"`
	Assists                   sql.NullInt32  `json:"assists"`
	Rebounds                  sql.NullInt32  `json:"rebounds"`
	Steals                    sql.NullInt32  `json:"steals"`
	PhotoUrl                  sql.NullString `json:"photo_url"`
}

func (q *Queries) GetCustomers(ctx context.Context, arg GetCustomersParams) ([]GetCustomersRow, error) {
	rows, err := q.db.QueryContext(ctx, getCustomers,
		arg.ParentID,
		arg.Search,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCustomersRow
	for rows.Next() {
		var i GetCustomersRow
		if err := rows.Scan(
			&i.ID,
			&i.HubspotID,
			&i.CountryAlpha2Code,
			&i.Gender,
			&i.FirstName,
			&i.LastName,
			&i.ParentID,
			&i.Phone,
			&i.Email,
			&i.HasMarketingEmailConsent,
			&i.HasSmsConsent,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Dob,
			&i.IsArchived,
			&i.MembershipName,
			&i.MembershipPlanID,
			&i.MembershipPlanName,
			&i.MembershipStartDate,
			&i.MembershipPlanRenewalDate,
			&i.Points,
			&i.Wins,
			&i.Losses,
			&i.Assists,
			&i.Rebounds,
			&i.Steals,
			&i.PhotoUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listArchivedCustomers = `-- name: ListArchivedCustomers :many
SELECT u.id, u.hubspot_id, u.country_alpha2_code, u.gender, u.first_name, u.last_name, u.parent_id, u.phone, u.email, u.has_marketing_email_consent, u.has_sms_consent, u.created_at, u.updated_at, u.dob, u.is_archived
FROM users.users u
WHERE u.is_archived = TRUE
LIMIT $2 OFFSET $1
`

type ListArchivedCustomersParams struct {
	Offset int32 `json:"offset"`
	Limit  int32 `json:"limit"`
}

func (q *Queries) ListArchivedCustomers(ctx context.Context, arg ListArchivedCustomersParams) ([]UsersUser, error) {
	rows, err := q.db.QueryContext(ctx, listArchivedCustomers, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UsersUser
	for rows.Next() {
		var i UsersUser
		if err := rows.Scan(
			&i.ID,
			&i.HubspotID,
			&i.CountryAlpha2Code,
			&i.Gender,
			&i.FirstName,
			&i.LastName,
			&i.ParentID,
			&i.Phone,
			&i.Email,
			&i.HasMarketingEmailConsent,
			&i.HasSmsConsent,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Dob,
			&i.IsArchived,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMembershipHistory = `-- name: ListMembershipHistory :many
SELECT
    cmp.id,
    cmp.customer_id,
    cmp.start_date,
    cmp.renewal_date,
    cmp.status,
    cmp.created_at,
    cmp.updated_at,
    mp.membership_id,
    m.name AS membership_name,
    m.description AS membership_description,
    m.benefits AS membership_benefits,
    mp.id AS membership_plan_id,
    mp.name AS membership_plan_name,
    mp.unit_amount,
    mp.currency,
    mp.interval
FROM users.customer_membership_plans cmp
    JOIN membership.membership_plans mp ON mp.id = cmp.membership_plan_id
    JOIN membership.memberships m ON m.id = mp.membership_id
WHERE cmp.customer_id = $1
ORDER BY cmp.start_date DESC
`

type ListMembershipHistoryRow struct {
	ID                    uuid.UUID                  `json:"id"`
	CustomerID            uuid.UUID                  `json:"customer_id"`
	StartDate             time.Time                  `json:"start_date"`
	RenewalDate           sql.NullTime               `json:"renewal_date"`
	Status                MembershipMembershipStatus `json:"status"`
	CreatedAt             time.Time                  `json:"created_at"`
	UpdatedAt             time.Time                  `json:"updated_at"`
	MembershipID          uuid.UUID                  `json:"membership_id"`
	MembershipName        string                     `json:"membership_name"`
	MembershipDescription string                     `json:"membership_description"`
	MembershipBenefits    string                     `json:"membership_benefits"`
	MembershipPlanID      uuid.UUID                  `json:"membership_plan_id"`
	MembershipPlanName    string                     `json:"membership_plan_name"`
	UnitAmount            sql.NullInt32              `json:"unit_amount"`
	Currency              sql.NullString             `json:"currency"`
	Interval              sql.NullString             `json:"interval"`
}

func (q *Queries) ListMembershipHistory(ctx context.Context, customerID uuid.UUID) ([]ListMembershipHistoryRow, error) {
	rows, err := q.db.QueryContext(ctx, listMembershipHistory, customerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListMembershipHistoryRow
	for rows.Next() {
		var i ListMembershipHistoryRow
		if err := rows.Scan(
			&i.ID,
			&i.CustomerID,
			&i.StartDate,
			&i.RenewalDate,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.MembershipID,
			&i.MembershipName,
			&i.MembershipDescription,
			&i.MembershipBenefits,
			&i.MembershipPlanID,
			&i.MembershipPlanName,
			&i.UnitAmount,
			&i.Currency,
			&i.Interval,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const unarchiveCustomer = `-- name: UnarchiveCustomer :execrows
UPDATE users.users
SET is_archived = FALSE,
    updated_at = current_timestamp
WHERE id = $1
`

func (q *Queries) UnarchiveCustomer(ctx context.Context, id uuid.UUID) (int64, error) {
	result, err := q.db.ExecContext(ctx, unarchiveCustomer, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const updateAthleteStats = `-- name: UpdateAthleteStats :execrows
UPDATE athletic.athletes
SET wins       = COALESCE($1, wins),
    losses     = COALESCE($2, losses),
    points     = COALESCE($3, points),
    steals     = COALESCE($4, steals),
    assists    = COALESCE($5, assists),
    rebounds   = COALESCE($6, rebounds),
    updated_at = current_timestamp
WHERE id = $7
`

type UpdateAthleteStatsParams struct {
	Wins     sql.NullInt32 `json:"wins"`
	Losses   sql.NullInt32 `json:"losses"`
	Points   sql.NullInt32 `json:"points"`
	Steals   sql.NullInt32 `json:"steals"`
	Assists  sql.NullInt32 `json:"assists"`
	Rebounds sql.NullInt32 `json:"rebounds"`
	ID       uuid.UUID     `json:"id"`
}

func (q *Queries) UpdateAthleteStats(ctx context.Context, arg UpdateAthleteStatsParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, updateAthleteStats,
		arg.Wins,
		arg.Losses,
		arg.Points,
		arg.Steals,
		arg.Assists,
		arg.Rebounds,
		arg.ID,
	)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const updateAthleteTeam = `-- name: UpdateAthleteTeam :execrows
UPDATE athletic.athletes
SET team_id = $1
WHERE id = $2
`

type UpdateAthleteTeamParams struct {
	TeamID    uuid.NullUUID `json:"team_id"`
	AthleteID uuid.UUID     `json:"athlete_id"`
}

func (q *Queries) UpdateAthleteTeam(ctx context.Context, arg UpdateAthleteTeamParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, updateAthleteTeam, arg.TeamID, arg.AthleteID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}
