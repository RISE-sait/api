// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: game.sql

package db_seed

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
	"github.com/lib/pq"
)

const createGame = `-- name: CreateGame :one
INSERT INTO game.games (
  id, home_team_id, away_team_id, home_score, away_score,
  start_time, end_time, location_id, status
)
VALUES (
  gen_random_uuid(), $1, $2, $3, $4, $5, $6, $7, $8
)
RETURNING id, home_team_id, away_team_id, home_score, away_score, start_time, end_time, location_id, status, created_at, updated_at, court_id
`

type CreateGameParams struct {
	HomeTeamID uuid.UUID      `json:"home_team_id"`
	AwayTeamID uuid.UUID      `json:"away_team_id"`
	HomeScore  sql.NullInt32  `json:"home_score"`
	AwayScore  sql.NullInt32  `json:"away_score"`
	StartTime  time.Time      `json:"start_time"`
	EndTime    sql.NullTime   `json:"end_time"`
	LocationID uuid.UUID      `json:"location_id"`
	Status     sql.NullString `json:"status"`
}

func (q *Queries) CreateGame(ctx context.Context, arg CreateGameParams) (GameGame, error) {
	row := q.db.QueryRowContext(ctx, createGame,
		arg.HomeTeamID,
		arg.AwayTeamID,
		arg.HomeScore,
		arg.AwayScore,
		arg.StartTime,
		arg.EndTime,
		arg.LocationID,
		arg.Status,
	)
	var i GameGame
	err := row.Scan(
		&i.ID,
		&i.HomeTeamID,
		&i.AwayTeamID,
		&i.HomeScore,
		&i.AwayScore,
		&i.StartTime,
		&i.EndTime,
		&i.LocationID,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CourtID,
	)
	return i, err
}

const insertGames = `-- name: InsertGames :many
WITH games_data AS (
    SELECT 
        unnest($1::timestamptz[]) AS start_time,
        unnest($2::timestamptz[])   AS end_time,
        unnest($3::uuid[])      AS home_team_id,
        unnest($4::uuid[])      AS away_team_id,
        unnest($5::text[])     AS location_name,
        unnest($6::int[])         AS home_score,
        unnest($7::int[])         AS away_score,
        unnest($8::text[])           AS status
)
INSERT INTO game.games (
    id, home_team_id, away_team_id, home_score, away_score, start_time, end_time, location_id, status
)
SELECT 
    gen_random_uuid(),
    g.home_team_id,
    g.away_team_id,
    g.home_score,
    g.away_score,
    g.start_time,
    g.end_time,
    loc.id,
    g.status
FROM games_data g
JOIN location.locations loc ON loc.name = g.location_name
RETURNING id
`

type InsertGamesParams struct {
	StartTimes    []time.Time `json:"start_times"`
	EndTimes      []time.Time `json:"end_times"`
	HomeTeamIds   []uuid.UUID `json:"home_team_ids"`
	AwayTeamIds   []uuid.UUID `json:"away_team_ids"`
	LocationNames []string    `json:"location_names"`
	HomeScores    []int32     `json:"home_scores"`
	AwayScores    []int32     `json:"away_scores"`
	Statuses      []string    `json:"statuses"`
}

func (q *Queries) InsertGames(ctx context.Context, arg InsertGamesParams) ([]uuid.UUID, error) {
	rows, err := q.db.QueryContext(ctx, insertGames,
		pq.Array(arg.StartTimes),
		pq.Array(arg.EndTimes),
		pq.Array(arg.HomeTeamIds),
		pq.Array(arg.AwayTeamIds),
		pq.Array(arg.LocationNames),
		pq.Array(arg.HomeScores),
		pq.Array(arg.AwayScores),
		pq.Array(arg.Statuses),
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []uuid.UUID
	for rows.Next() {
		var id uuid.UUID
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
