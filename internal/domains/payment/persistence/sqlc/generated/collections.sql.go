// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: collections.sql

package db_payment

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
	"github.com/lib/pq"
	"github.com/shopspring/decimal"
)

const countCollectionAttempts = `-- name: CountCollectionAttempts :one
SELECT COUNT(*) FROM payments.collection_attempts
WHERE
    ($1::uuid IS NULL OR customer_id = $1) AND
    ($2::uuid IS NULL OR admin_id = $2) AND
    ($3::text IS NULL OR status = $3) AND
    ($4::text IS NULL OR collection_method = $4) AND
    ($5::timestamptz IS NULL OR created_at >= $5) AND
    ($6::timestamptz IS NULL OR created_at <= $6)
`

type CountCollectionAttemptsParams struct {
	CustomerID       uuid.NullUUID  `json:"customer_id"`
	AdminID          uuid.NullUUID  `json:"admin_id"`
	Status           sql.NullString `json:"status"`
	CollectionMethod sql.NullString `json:"collection_method"`
	StartDate        sql.NullTime   `json:"start_date"`
	EndDate          sql.NullTime   `json:"end_date"`
}

func (q *Queries) CountCollectionAttempts(ctx context.Context, arg CountCollectionAttemptsParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, countCollectionAttempts,
		arg.CustomerID,
		arg.AdminID,
		arg.Status,
		arg.CollectionMethod,
		arg.StartDate,
		arg.EndDate,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createCollectionAttempt = `-- name: CreateCollectionAttempt :one
INSERT INTO payments.collection_attempts (
    customer_id,
    admin_id,
    amount_attempted,
    amount_collected,
    collection_method,
    payment_method_details,
    status,
    failure_reason,
    stripe_payment_intent_id,
    stripe_payment_link_id,
    stripe_customer_id,
    membership_plan_id,
    stripe_subscription_id,
    notes,
    previous_balance,
    new_balance,
    completed_at
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17
) RETURNING id, customer_id, admin_id, amount_attempted, amount_collected, collection_method, payment_method_details, status, failure_reason, stripe_payment_intent_id, stripe_payment_link_id, stripe_customer_id, membership_plan_id, stripe_subscription_id, notes, previous_balance, new_balance, created_at, updated_at, completed_at
`

type CreateCollectionAttemptParams struct {
	CustomerID            uuid.UUID       `json:"customer_id"`
	AdminID               uuid.UUID       `json:"admin_id"`
	AmountAttempted       decimal.Decimal `json:"amount_attempted"`
	AmountCollected       sql.NullString  `json:"amount_collected"`
	CollectionMethod      string          `json:"collection_method"`
	PaymentMethodDetails  sql.NullString  `json:"payment_method_details"`
	Status                string          `json:"status"`
	FailureReason         sql.NullString  `json:"failure_reason"`
	StripePaymentIntentID sql.NullString  `json:"stripe_payment_intent_id"`
	StripePaymentLinkID   sql.NullString  `json:"stripe_payment_link_id"`
	StripeCustomerID      sql.NullString  `json:"stripe_customer_id"`
	MembershipPlanID      uuid.NullUUID   `json:"membership_plan_id"`
	StripeSubscriptionID  sql.NullString  `json:"stripe_subscription_id"`
	Notes                 sql.NullString  `json:"notes"`
	PreviousBalance       sql.NullString  `json:"previous_balance"`
	NewBalance            sql.NullString  `json:"new_balance"`
	CompletedAt           sql.NullTime    `json:"completed_at"`
}

func (q *Queries) CreateCollectionAttempt(ctx context.Context, arg CreateCollectionAttemptParams) (PaymentsCollectionAttempt, error) {
	row := q.db.QueryRowContext(ctx, createCollectionAttempt,
		arg.CustomerID,
		arg.AdminID,
		arg.AmountAttempted,
		arg.AmountCollected,
		arg.CollectionMethod,
		arg.PaymentMethodDetails,
		arg.Status,
		arg.FailureReason,
		arg.StripePaymentIntentID,
		arg.StripePaymentLinkID,
		arg.StripeCustomerID,
		arg.MembershipPlanID,
		arg.StripeSubscriptionID,
		arg.Notes,
		arg.PreviousBalance,
		arg.NewBalance,
		arg.CompletedAt,
	)
	var i PaymentsCollectionAttempt
	err := row.Scan(
		&i.ID,
		&i.CustomerID,
		&i.AdminID,
		&i.AmountAttempted,
		&i.AmountCollected,
		&i.CollectionMethod,
		&i.PaymentMethodDetails,
		&i.Status,
		&i.FailureReason,
		&i.StripePaymentIntentID,
		&i.StripePaymentLinkID,
		&i.StripeCustomerID,
		&i.MembershipPlanID,
		&i.StripeSubscriptionID,
		&i.Notes,
		&i.PreviousBalance,
		&i.NewBalance,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CompletedAt,
	)
	return i, err
}

const createPaymentLink = `-- name: CreatePaymentLink :one

INSERT INTO payments.payment_links (
    customer_id,
    admin_id,
    stripe_payment_link_id,
    stripe_payment_link_url,
    amount,
    description,
    membership_plan_id,
    collection_attempt_id,
    status,
    sent_via,
    sent_to_email,
    sent_to_phone,
    expires_at
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13
) RETURNING id, customer_id, admin_id, stripe_payment_link_id, stripe_payment_link_url, amount, description, membership_plan_id, collection_attempt_id, status, sent_via, sent_to_email, sent_to_phone, created_at, sent_at, opened_at, completed_at, expires_at
`

type CreatePaymentLinkParams struct {
	CustomerID           uuid.UUID       `json:"customer_id"`
	AdminID              uuid.UUID       `json:"admin_id"`
	StripePaymentLinkID  string          `json:"stripe_payment_link_id"`
	StripePaymentLinkUrl string          `json:"stripe_payment_link_url"`
	Amount               decimal.Decimal `json:"amount"`
	Description          sql.NullString  `json:"description"`
	MembershipPlanID     uuid.NullUUID   `json:"membership_plan_id"`
	CollectionAttemptID  uuid.NullUUID   `json:"collection_attempt_id"`
	Status               string          `json:"status"`
	SentVia              []string        `json:"sent_via"`
	SentToEmail          sql.NullString  `json:"sent_to_email"`
	SentToPhone          sql.NullString  `json:"sent_to_phone"`
	ExpiresAt            sql.NullTime    `json:"expires_at"`
}

// Payment Links queries
func (q *Queries) CreatePaymentLink(ctx context.Context, arg CreatePaymentLinkParams) (PaymentsPaymentLink, error) {
	row := q.db.QueryRowContext(ctx, createPaymentLink,
		arg.CustomerID,
		arg.AdminID,
		arg.StripePaymentLinkID,
		arg.StripePaymentLinkUrl,
		arg.Amount,
		arg.Description,
		arg.MembershipPlanID,
		arg.CollectionAttemptID,
		arg.Status,
		pq.Array(arg.SentVia),
		arg.SentToEmail,
		arg.SentToPhone,
		arg.ExpiresAt,
	)
	var i PaymentsPaymentLink
	err := row.Scan(
		&i.ID,
		&i.CustomerID,
		&i.AdminID,
		&i.StripePaymentLinkID,
		&i.StripePaymentLinkUrl,
		&i.Amount,
		&i.Description,
		&i.MembershipPlanID,
		&i.CollectionAttemptID,
		&i.Status,
		pq.Array(&i.SentVia),
		&i.SentToEmail,
		&i.SentToPhone,
		&i.CreatedAt,
		&i.SentAt,
		&i.OpenedAt,
		&i.CompletedAt,
		&i.ExpiresAt,
	)
	return i, err
}

const expireOldPaymentLinks = `-- name: ExpireOldPaymentLinks :exec
UPDATE payments.payment_links
SET status = 'expired'
WHERE status IN ('pending', 'sent')
    AND expires_at IS NOT NULL
    AND expires_at <= CURRENT_TIMESTAMP
`

func (q *Queries) ExpireOldPaymentLinks(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, expireOldPaymentLinks)
	return err
}

const getCollectionAttempt = `-- name: GetCollectionAttempt :one
SELECT id, customer_id, admin_id, amount_attempted, amount_collected, collection_method, payment_method_details, status, failure_reason, stripe_payment_intent_id, stripe_payment_link_id, stripe_customer_id, membership_plan_id, stripe_subscription_id, notes, previous_balance, new_balance, created_at, updated_at, completed_at FROM payments.collection_attempts
WHERE id = $1
`

func (q *Queries) GetCollectionAttempt(ctx context.Context, id uuid.UUID) (PaymentsCollectionAttempt, error) {
	row := q.db.QueryRowContext(ctx, getCollectionAttempt, id)
	var i PaymentsCollectionAttempt
	err := row.Scan(
		&i.ID,
		&i.CustomerID,
		&i.AdminID,
		&i.AmountAttempted,
		&i.AmountCollected,
		&i.CollectionMethod,
		&i.PaymentMethodDetails,
		&i.Status,
		&i.FailureReason,
		&i.StripePaymentIntentID,
		&i.StripePaymentLinkID,
		&i.StripeCustomerID,
		&i.MembershipPlanID,
		&i.StripeSubscriptionID,
		&i.Notes,
		&i.PreviousBalance,
		&i.NewBalance,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CompletedAt,
	)
	return i, err
}

const getCollectionAttemptsByCustomer = `-- name: GetCollectionAttemptsByCustomer :many
SELECT id, customer_id, admin_id, amount_attempted, amount_collected, collection_method, payment_method_details, status, failure_reason, stripe_payment_intent_id, stripe_payment_link_id, stripe_customer_id, membership_plan_id, stripe_subscription_id, notes, previous_balance, new_balance, created_at, updated_at, completed_at FROM payments.collection_attempts
WHERE customer_id = $1
ORDER BY created_at DESC
LIMIT $3 OFFSET $2
`

type GetCollectionAttemptsByCustomerParams struct {
	CustomerID uuid.UUID `json:"customer_id"`
	Offset     int32     `json:"offset"`
	Limit      int32     `json:"limit"`
}

func (q *Queries) GetCollectionAttemptsByCustomer(ctx context.Context, arg GetCollectionAttemptsByCustomerParams) ([]PaymentsCollectionAttempt, error) {
	rows, err := q.db.QueryContext(ctx, getCollectionAttemptsByCustomer, arg.CustomerID, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PaymentsCollectionAttempt
	for rows.Next() {
		var i PaymentsCollectionAttempt
		if err := rows.Scan(
			&i.ID,
			&i.CustomerID,
			&i.AdminID,
			&i.AmountAttempted,
			&i.AmountCollected,
			&i.CollectionMethod,
			&i.PaymentMethodDetails,
			&i.Status,
			&i.FailureReason,
			&i.StripePaymentIntentID,
			&i.StripePaymentLinkID,
			&i.StripeCustomerID,
			&i.MembershipPlanID,
			&i.StripeSubscriptionID,
			&i.Notes,
			&i.PreviousBalance,
			&i.NewBalance,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CompletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCollectionSummary = `-- name: GetCollectionSummary :one
SELECT
    COUNT(*) as total_attempts,
    COUNT(*) FILTER (WHERE status = 'success') as successful_attempts,
    COUNT(*) FILTER (WHERE status = 'failed') as failed_attempts,
    COUNT(*) FILTER (WHERE status = 'pending') as pending_attempts,
    COALESCE(SUM(amount_attempted), 0) as total_amount_attempted,
    COALESCE(SUM(amount_collected), 0) as total_amount_collected
FROM payments.collection_attempts
WHERE
    ($1::timestamptz IS NULL OR created_at >= $1) AND
    ($2::timestamptz IS NULL OR created_at <= $2)
`

type GetCollectionSummaryParams struct {
	StartDate sql.NullTime `json:"start_date"`
	EndDate   sql.NullTime `json:"end_date"`
}

type GetCollectionSummaryRow struct {
	TotalAttempts        int64       `json:"total_attempts"`
	SuccessfulAttempts   int64       `json:"successful_attempts"`
	FailedAttempts       int64       `json:"failed_attempts"`
	PendingAttempts      int64       `json:"pending_attempts"`
	TotalAmountAttempted interface{} `json:"total_amount_attempted"`
	TotalAmountCollected interface{} `json:"total_amount_collected"`
}

func (q *Queries) GetCollectionSummary(ctx context.Context, arg GetCollectionSummaryParams) (GetCollectionSummaryRow, error) {
	row := q.db.QueryRowContext(ctx, getCollectionSummary, arg.StartDate, arg.EndDate)
	var i GetCollectionSummaryRow
	err := row.Scan(
		&i.TotalAttempts,
		&i.SuccessfulAttempts,
		&i.FailedAttempts,
		&i.PendingAttempts,
		&i.TotalAmountAttempted,
		&i.TotalAmountCollected,
	)
	return i, err
}

const getPaymentLink = `-- name: GetPaymentLink :one
SELECT id, customer_id, admin_id, stripe_payment_link_id, stripe_payment_link_url, amount, description, membership_plan_id, collection_attempt_id, status, sent_via, sent_to_email, sent_to_phone, created_at, sent_at, opened_at, completed_at, expires_at FROM payments.payment_links
WHERE id = $1
`

func (q *Queries) GetPaymentLink(ctx context.Context, id uuid.UUID) (PaymentsPaymentLink, error) {
	row := q.db.QueryRowContext(ctx, getPaymentLink, id)
	var i PaymentsPaymentLink
	err := row.Scan(
		&i.ID,
		&i.CustomerID,
		&i.AdminID,
		&i.StripePaymentLinkID,
		&i.StripePaymentLinkUrl,
		&i.Amount,
		&i.Description,
		&i.MembershipPlanID,
		&i.CollectionAttemptID,
		&i.Status,
		pq.Array(&i.SentVia),
		&i.SentToEmail,
		&i.SentToPhone,
		&i.CreatedAt,
		&i.SentAt,
		&i.OpenedAt,
		&i.CompletedAt,
		&i.ExpiresAt,
	)
	return i, err
}

const getPaymentLinkByStripeID = `-- name: GetPaymentLinkByStripeID :one
SELECT id, customer_id, admin_id, stripe_payment_link_id, stripe_payment_link_url, amount, description, membership_plan_id, collection_attempt_id, status, sent_via, sent_to_email, sent_to_phone, created_at, sent_at, opened_at, completed_at, expires_at FROM payments.payment_links
WHERE stripe_payment_link_id = $1
`

func (q *Queries) GetPaymentLinkByStripeID(ctx context.Context, stripePaymentLinkID string) (PaymentsPaymentLink, error) {
	row := q.db.QueryRowContext(ctx, getPaymentLinkByStripeID, stripePaymentLinkID)
	var i PaymentsPaymentLink
	err := row.Scan(
		&i.ID,
		&i.CustomerID,
		&i.AdminID,
		&i.StripePaymentLinkID,
		&i.StripePaymentLinkUrl,
		&i.Amount,
		&i.Description,
		&i.MembershipPlanID,
		&i.CollectionAttemptID,
		&i.Status,
		pq.Array(&i.SentVia),
		&i.SentToEmail,
		&i.SentToPhone,
		&i.CreatedAt,
		&i.SentAt,
		&i.OpenedAt,
		&i.CompletedAt,
		&i.ExpiresAt,
	)
	return i, err
}

const listCollectionAttempts = `-- name: ListCollectionAttempts :many
SELECT id, customer_id, admin_id, amount_attempted, amount_collected, collection_method, payment_method_details, status, failure_reason, stripe_payment_intent_id, stripe_payment_link_id, stripe_customer_id, membership_plan_id, stripe_subscription_id, notes, previous_balance, new_balance, created_at, updated_at, completed_at FROM payments.collection_attempts
WHERE
    ($1::uuid IS NULL OR customer_id = $1) AND
    ($2::uuid IS NULL OR admin_id = $2) AND
    ($3::text IS NULL OR status = $3) AND
    ($4::text IS NULL OR collection_method = $4) AND
    ($5::timestamptz IS NULL OR created_at >= $5) AND
    ($6::timestamptz IS NULL OR created_at <= $6)
ORDER BY created_at DESC
LIMIT $8 OFFSET $7
`

type ListCollectionAttemptsParams struct {
	CustomerID       uuid.NullUUID  `json:"customer_id"`
	AdminID          uuid.NullUUID  `json:"admin_id"`
	Status           sql.NullString `json:"status"`
	CollectionMethod sql.NullString `json:"collection_method"`
	StartDate        sql.NullTime   `json:"start_date"`
	EndDate          sql.NullTime   `json:"end_date"`
	Offset           int32          `json:"offset"`
	Limit            int32          `json:"limit"`
}

func (q *Queries) ListCollectionAttempts(ctx context.Context, arg ListCollectionAttemptsParams) ([]PaymentsCollectionAttempt, error) {
	rows, err := q.db.QueryContext(ctx, listCollectionAttempts,
		arg.CustomerID,
		arg.AdminID,
		arg.Status,
		arg.CollectionMethod,
		arg.StartDate,
		arg.EndDate,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PaymentsCollectionAttempt
	for rows.Next() {
		var i PaymentsCollectionAttempt
		if err := rows.Scan(
			&i.ID,
			&i.CustomerID,
			&i.AdminID,
			&i.AmountAttempted,
			&i.AmountCollected,
			&i.CollectionMethod,
			&i.PaymentMethodDetails,
			&i.Status,
			&i.FailureReason,
			&i.StripePaymentIntentID,
			&i.StripePaymentLinkID,
			&i.StripeCustomerID,
			&i.MembershipPlanID,
			&i.StripeSubscriptionID,
			&i.Notes,
			&i.PreviousBalance,
			&i.NewBalance,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CompletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPaymentLinksByCustomer = `-- name: ListPaymentLinksByCustomer :many
SELECT id, customer_id, admin_id, stripe_payment_link_id, stripe_payment_link_url, amount, description, membership_plan_id, collection_attempt_id, status, sent_via, sent_to_email, sent_to_phone, created_at, sent_at, opened_at, completed_at, expires_at FROM payments.payment_links
WHERE customer_id = $1
ORDER BY created_at DESC
LIMIT $3 OFFSET $2
`

type ListPaymentLinksByCustomerParams struct {
	CustomerID uuid.UUID `json:"customer_id"`
	Offset     int32     `json:"offset"`
	Limit      int32     `json:"limit"`
}

func (q *Queries) ListPaymentLinksByCustomer(ctx context.Context, arg ListPaymentLinksByCustomerParams) ([]PaymentsPaymentLink, error) {
	rows, err := q.db.QueryContext(ctx, listPaymentLinksByCustomer, arg.CustomerID, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PaymentsPaymentLink
	for rows.Next() {
		var i PaymentsPaymentLink
		if err := rows.Scan(
			&i.ID,
			&i.CustomerID,
			&i.AdminID,
			&i.StripePaymentLinkID,
			&i.StripePaymentLinkUrl,
			&i.Amount,
			&i.Description,
			&i.MembershipPlanID,
			&i.CollectionAttemptID,
			&i.Status,
			pq.Array(&i.SentVia),
			&i.SentToEmail,
			&i.SentToPhone,
			&i.CreatedAt,
			&i.SentAt,
			&i.OpenedAt,
			&i.CompletedAt,
			&i.ExpiresAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPendingPaymentLinks = `-- name: ListPendingPaymentLinks :many
SELECT id, customer_id, admin_id, stripe_payment_link_id, stripe_payment_link_url, amount, description, membership_plan_id, collection_attempt_id, status, sent_via, sent_to_email, sent_to_phone, created_at, sent_at, opened_at, completed_at, expires_at FROM payments.payment_links
WHERE status IN ('pending', 'sent')
    AND (expires_at IS NULL OR expires_at > CURRENT_TIMESTAMP)
ORDER BY created_at DESC
`

func (q *Queries) ListPendingPaymentLinks(ctx context.Context) ([]PaymentsPaymentLink, error) {
	rows, err := q.db.QueryContext(ctx, listPendingPaymentLinks)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PaymentsPaymentLink
	for rows.Next() {
		var i PaymentsPaymentLink
		if err := rows.Scan(
			&i.ID,
			&i.CustomerID,
			&i.AdminID,
			&i.StripePaymentLinkID,
			&i.StripePaymentLinkUrl,
			&i.Amount,
			&i.Description,
			&i.MembershipPlanID,
			&i.CollectionAttemptID,
			&i.Status,
			pq.Array(&i.SentVia),
			&i.SentToEmail,
			&i.SentToPhone,
			&i.CreatedAt,
			&i.SentAt,
			&i.OpenedAt,
			&i.CompletedAt,
			&i.ExpiresAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateCollectionAttemptStatus = `-- name: UpdateCollectionAttemptStatus :one
UPDATE payments.collection_attempts
SET status = $2,
    amount_collected = COALESCE($3, amount_collected),
    failure_reason = $4,
    new_balance = $5,
    completed_at = CASE WHEN $2 IN ('success', 'failed') THEN CURRENT_TIMESTAMP ELSE completed_at END,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1
RETURNING id, customer_id, admin_id, amount_attempted, amount_collected, collection_method, payment_method_details, status, failure_reason, stripe_payment_intent_id, stripe_payment_link_id, stripe_customer_id, membership_plan_id, stripe_subscription_id, notes, previous_balance, new_balance, created_at, updated_at, completed_at
`

type UpdateCollectionAttemptStatusParams struct {
	ID              uuid.UUID      `json:"id"`
	Status          string         `json:"status"`
	AmountCollected sql.NullString `json:"amount_collected"`
	FailureReason   sql.NullString `json:"failure_reason"`
	NewBalance      sql.NullString `json:"new_balance"`
}

func (q *Queries) UpdateCollectionAttemptStatus(ctx context.Context, arg UpdateCollectionAttemptStatusParams) (PaymentsCollectionAttempt, error) {
	row := q.db.QueryRowContext(ctx, updateCollectionAttemptStatus,
		arg.ID,
		arg.Status,
		arg.AmountCollected,
		arg.FailureReason,
		arg.NewBalance,
	)
	var i PaymentsCollectionAttempt
	err := row.Scan(
		&i.ID,
		&i.CustomerID,
		&i.AdminID,
		&i.AmountAttempted,
		&i.AmountCollected,
		&i.CollectionMethod,
		&i.PaymentMethodDetails,
		&i.Status,
		&i.FailureReason,
		&i.StripePaymentIntentID,
		&i.StripePaymentLinkID,
		&i.StripeCustomerID,
		&i.MembershipPlanID,
		&i.StripeSubscriptionID,
		&i.Notes,
		&i.PreviousBalance,
		&i.NewBalance,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CompletedAt,
	)
	return i, err
}

const updatePaymentLinkStatus = `-- name: UpdatePaymentLinkStatus :one
UPDATE payments.payment_links
SET status = $2,
    sent_at = CASE WHEN $2 = 'sent' AND sent_at IS NULL THEN CURRENT_TIMESTAMP ELSE sent_at END,
    opened_at = CASE WHEN $2 = 'opened' AND opened_at IS NULL THEN CURRENT_TIMESTAMP ELSE opened_at END,
    completed_at = CASE WHEN $2 = 'completed' AND completed_at IS NULL THEN CURRENT_TIMESTAMP ELSE completed_at END
WHERE id = $1
RETURNING id, customer_id, admin_id, stripe_payment_link_id, stripe_payment_link_url, amount, description, membership_plan_id, collection_attempt_id, status, sent_via, sent_to_email, sent_to_phone, created_at, sent_at, opened_at, completed_at, expires_at
`

type UpdatePaymentLinkStatusParams struct {
	ID     uuid.UUID `json:"id"`
	Status string    `json:"status"`
}

func (q *Queries) UpdatePaymentLinkStatus(ctx context.Context, arg UpdatePaymentLinkStatusParams) (PaymentsPaymentLink, error) {
	row := q.db.QueryRowContext(ctx, updatePaymentLinkStatus, arg.ID, arg.Status)
	var i PaymentsPaymentLink
	err := row.Scan(
		&i.ID,
		&i.CustomerID,
		&i.AdminID,
		&i.StripePaymentLinkID,
		&i.StripePaymentLinkUrl,
		&i.Amount,
		&i.Description,
		&i.MembershipPlanID,
		&i.CollectionAttemptID,
		&i.Status,
		pq.Array(&i.SentVia),
		&i.SentToEmail,
		&i.SentToPhone,
		&i.CreatedAt,
		&i.SentAt,
		&i.OpenedAt,
		&i.CompletedAt,
		&i.ExpiresAt,
	)
	return i, err
}
