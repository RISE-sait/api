// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: purchases.sql

package db_payment

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
	"github.com/shopspring/decimal"
)

const createCustomerMembershipPlan = `-- name: CreateCustomerMembershipPlan :exec
INSERT INTO customer_membership_plans (customer_id, membership_plan_id, status, start_date, renewal_date)
VALUES ($1, $2, $3, $4, $5)
`

type CreateCustomerMembershipPlanParams struct {
	CustomerID       uuid.UUID        `json:"customer_id"`
	MembershipPlanID uuid.UUID        `json:"membership_plan_id"`
	Status           MembershipStatus `json:"status"`
	StartDate        time.Time        `json:"start_date"`
	RenewalDate      sql.NullTime     `json:"renewal_date"`
}

func (q *Queries) CreateCustomerMembershipPlan(ctx context.Context, arg CreateCustomerMembershipPlanParams) error {
	_, err := q.db.ExecContext(ctx, createCustomerMembershipPlan,
		arg.CustomerID,
		arg.MembershipPlanID,
		arg.Status,
		arg.StartDate,
		arg.RenewalDate,
	)
	return err
}

const getMembershipPlanJoiningRequirements = `-- name: GetMembershipPlanJoiningRequirements :one
SELECT id, name, price, joining_fee, auto_renew, membership_id, payment_frequency, amt_periods, created_at, updated_at
FROM membership.membership_plans
WHERE id = $1
`

func (q *Queries) GetMembershipPlanJoiningRequirements(ctx context.Context, id uuid.UUID) (MembershipMembershipPlan, error) {
	row := q.db.QueryRowContext(ctx, getMembershipPlanJoiningRequirements, id)
	var i MembershipMembershipPlan
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Price,
		&i.JoiningFee,
		&i.AutoRenew,
		&i.MembershipID,
		&i.PaymentFrequency,
		&i.AmtPeriods,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getProgramRegisterInfoForCustomer = `-- name: GetProgramRegisterInfoForCustomer :one
SELECT
    pm.is_eligible,
    pm.price_per_booking,
    p2.name AS program_name,
    EXISTS (SELECT 1 FROM users.users u WHERE u.id = $1) AS customer_exists,
    EXISTS (SELECT 1 FROM program.programs p WHERE p.id = $2) AS program_exists,
    EXISTS (
        SELECT 1 FROM public.customer_membership_plans
        WHERE customer_id = $1 AND status = 'active'
    ) AS customer_has_active_membership
FROM
    program.programs p2
        LEFT JOIN public.program_membership pm ON pm.program_id = p2.id
        LEFT JOIN membership.membership_plans mp ON mp.membership_id = pm.membership_id
        LEFT JOIN public.customer_membership_plans cmp_active
            ON cmp_active.membership_plan_id = mp.id
WHERE
    p2.id = $2
  AND cmp_active.customer_id = $1
  AND cmp_active.status = 'active'
GROUP BY pm.is_eligible, pm.price_per_booking, p2.name
`

type GetProgramRegisterInfoForCustomerParams struct {
	CustomerID uuid.UUID `json:"customer_id"`
	ProgramID  uuid.UUID `json:"program_id"`
}

type GetProgramRegisterInfoForCustomerRow struct {
	IsEligible                  sql.NullBool        `json:"is_eligible"`
	PricePerBooking             decimal.NullDecimal `json:"price_per_booking"`
	ProgramName                 string              `json:"program_name"`
	CustomerExists              bool                `json:"customer_exists"`
	ProgramExists               bool                `json:"program_exists"`
	CustomerHasActiveMembership bool                `json:"customer_has_active_membership"`
}

func (q *Queries) GetProgramRegisterInfoForCustomer(ctx context.Context, arg GetProgramRegisterInfoForCustomerParams) (GetProgramRegisterInfoForCustomerRow, error) {
	row := q.db.QueryRowContext(ctx, getProgramRegisterInfoForCustomer, arg.CustomerID, arg.ProgramID)
	var i GetProgramRegisterInfoForCustomerRow
	err := row.Scan(
		&i.IsEligible,
		&i.PricePerBooking,
		&i.ProgramName,
		&i.CustomerExists,
		&i.ProgramExists,
		&i.CustomerHasActiveMembership,
	)
	return i, err
}
