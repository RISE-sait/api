// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: customer.sql

package db_user

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
)

const archiveCustomer = `-- name: ArchiveCustomer :execrows
UPDATE users.users
SET is_archived = TRUE,
    updated_at = current_timestamp
WHERE id = $1
`

func (q *Queries) ArchiveCustomer(ctx context.Context, id uuid.UUID) (int64, error) {
	result, err := q.db.ExecContext(ctx, archiveCustomer, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const countCustomers = `-- name: CountCustomers :one
SELECT COUNT(*)
FROM users.users u
         LEFT JOIN users.customer_membership_plans cmp ON (
    cmp.customer_id = u.id AND
    cmp.start_date = (SELECT MAX(start_date)
                      FROM users.customer_membership_plans
                      WHERE customer_id = u.id)
    )
         LEFT JOIN membership.membership_plans mp ON mp.id = cmp.membership_plan_id
         LEFT JOIN membership.memberships m ON m.id = mp.membership_id
         LEFT JOIN athletic.athletes a ON u.id = a.id
WHERE u.is_archived = FALSE
  AND (u.parent_id = $1 OR $1 IS NULL)
  AND ($2::varchar IS NULL
  OR u.first_name ILIKE $2 || '%'
  OR u.last_name ILIKE $2 || '%'
  OR u.email ILIKE $2 || '%'
  OR u.phone ILIKE $2 || '%'
  OR u.notes ILIKE $2 || '%')
  AND NOT EXISTS (SELECT 1 FROM staff.staff s WHERE s.id = u.id)
`

type CountCustomersParams struct {
	ParentID uuid.NullUUID  `json:"parent_id"`
	Search   sql.NullString `json:"search"`
}

func (q *Queries) CountCustomers(ctx context.Context, arg CountCustomersParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, countCustomers, arg.ParentID, arg.Search)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createAthleteInfo = `-- name: CreateAthleteInfo :execrows
INSERT INTO athletic.athletes (id, rebounds, assists, losses, wins, points)
VALUES ($1, $2, $3, $4, $5, $6)
`

type CreateAthleteInfoParams struct {
	ID       uuid.UUID `json:"id"`
	Rebounds int32     `json:"rebounds"`
	Assists  int32     `json:"assists"`
	Losses   int32     `json:"losses"`
	Wins     int32     `json:"wins"`
	Points   int32     `json:"points"`
}

func (q *Queries) CreateAthleteInfo(ctx context.Context, arg CreateAthleteInfoParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, createAthleteInfo,
		arg.ID,
		arg.Rebounds,
		arg.Assists,
		arg.Losses,
		arg.Wins,
		arg.Points,
	)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const deleteAthleteData = `-- name: DeleteAthleteData :execrows

DELETE FROM athletic.athletes WHERE id = $1
`

// Note: credit_transactions has ON DELETE CASCADE, so it will be cleaned automatically
func (q *Queries) DeleteAthleteData(ctx context.Context, id uuid.UUID) (int64, error) {
	result, err := q.db.ExecContext(ctx, deleteAthleteData, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const deleteCustomerAccount = `-- name: DeleteCustomerAccount :execrows
DELETE FROM users.users WHERE id = $1
`

func (q *Queries) DeleteCustomerAccount(ctx context.Context, id uuid.UUID) (int64, error) {
	result, err := q.db.ExecContext(ctx, deleteCustomerAccount, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const deleteCustomerEnrollments = `-- name: DeleteCustomerEnrollments :execrows
DELETE FROM program.customer_enrollment WHERE customer_id = $1
`

func (q *Queries) DeleteCustomerEnrollments(ctx context.Context, customerID uuid.UUID) (int64, error) {
	result, err := q.db.ExecContext(ctx, deleteCustomerEnrollments, customerID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const deleteCustomerEventEnrollments = `-- name: DeleteCustomerEventEnrollments :execrows
DELETE FROM events.customer_enrollment WHERE customer_id = $1
`

func (q *Queries) DeleteCustomerEventEnrollments(ctx context.Context, customerID uuid.UUID) (int64, error) {
	result, err := q.db.ExecContext(ctx, deleteCustomerEventEnrollments, customerID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const deleteCustomerMemberships = `-- name: DeleteCustomerMemberships :execrows
DELETE FROM users.customer_membership_plans WHERE customer_id = $1
`

func (q *Queries) DeleteCustomerMemberships(ctx context.Context, customerID uuid.UUID) (int64, error) {
	result, err := q.db.ExecContext(ctx, deleteCustomerMemberships, customerID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const extendMembershipRenewalDate = `-- name: ExtendMembershipRenewalDate :execrows
UPDATE users.customer_membership_plans
SET renewal_date = $1,
    updated_at = current_timestamp
WHERE customer_id = $2
  AND suspended_at IS NOT NULL
`

type ExtendMembershipRenewalDateParams struct {
	NewRenewalDate sql.NullTime `json:"new_renewal_date"`
	UserID         uuid.UUID    `json:"user_id"`
}

func (q *Queries) ExtendMembershipRenewalDate(ctx context.Context, arg ExtendMembershipRenewalDateParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, extendMembershipRenewalDate, arg.NewRenewalDate, arg.UserID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const getActiveMembershipInfo = `-- name: GetActiveMembershipInfo :one
SELECT
    cmp.id,
    cmp.customer_id,
    cmp.start_date,
    cmp.renewal_date,
    cmp.status,
    cmp.created_at,
    cmp.updated_at,
    cmp.photo_url,
    mp.membership_id,
    cmp.membership_plan_id,
    m.name AS membership_name,
    mp.name AS membership_plan_name
FROM users.customer_membership_plans cmp
    JOIN membership.membership_plans mp ON mp.id = cmp.membership_plan_id
    JOIN membership.memberships m ON m.id = mp.membership_id
WHERE cmp.customer_id = $1
  AND cmp.status = 'active'
ORDER BY cmp.start_date DESC
LIMIT 1
`

type GetActiveMembershipInfoRow struct {
	ID                 uuid.UUID                  `json:"id"`
	CustomerID         uuid.UUID                  `json:"customer_id"`
	StartDate          time.Time                  `json:"start_date"`
	RenewalDate        sql.NullTime               `json:"renewal_date"`
	Status             MembershipMembershipStatus `json:"status"`
	CreatedAt          time.Time                  `json:"created_at"`
	UpdatedAt          time.Time                  `json:"updated_at"`
	PhotoUrl           sql.NullString             `json:"photo_url"`
	MembershipID       uuid.UUID                  `json:"membership_id"`
	MembershipPlanID   uuid.UUID                  `json:"membership_plan_id"`
	MembershipName     string                     `json:"membership_name"`
	MembershipPlanName string                     `json:"membership_plan_name"`
}

func (q *Queries) GetActiveMembershipInfo(ctx context.Context, customerID uuid.UUID) (GetActiveMembershipInfoRow, error) {
	row := q.db.QueryRowContext(ctx, getActiveMembershipInfo, customerID)
	var i GetActiveMembershipInfoRow
	err := row.Scan(
		&i.ID,
		&i.CustomerID,
		&i.StartDate,
		&i.RenewalDate,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.PhotoUrl,
		&i.MembershipID,
		&i.MembershipPlanID,
		&i.MembershipName,
		&i.MembershipPlanName,
	)
	return i, err
}

const getAthletes = `-- name: GetAthletes :many
SELECT
  u.id,
  u.first_name,
  u.last_name,
  a.points,
  a.wins,
  a.losses,
  a.assists,
  a.rebounds,
  a.steals,
  a.photo_url,
  a.team_id
FROM athletic.athletes a
JOIN users.users u ON u.id = a.id
ORDER BY a.points DESC
LIMIT $2 OFFSET $1
`

type GetAthletesParams struct {
	Offset int32 `json:"offset"`
	Limit  int32 `json:"limit"`
}

type GetAthletesRow struct {
	ID        uuid.UUID      `json:"id"`
	FirstName string         `json:"first_name"`
	LastName  string         `json:"last_name"`
	Points    int32          `json:"points"`
	Wins      int32          `json:"wins"`
	Losses    int32          `json:"losses"`
	Assists   int32          `json:"assists"`
	Rebounds  int32          `json:"rebounds"`
	Steals    int32          `json:"steals"`
	PhotoUrl  sql.NullString `json:"photo_url"`
	TeamID    uuid.NullUUID  `json:"team_id"`
}

func (q *Queries) GetAthletes(ctx context.Context, arg GetAthletesParams) ([]GetAthletesRow, error) {
	rows, err := q.db.QueryContext(ctx, getAthletes, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAthletesRow
	for rows.Next() {
		var i GetAthletesRow
		if err := rows.Scan(
			&i.ID,
			&i.FirstName,
			&i.LastName,
			&i.Points,
			&i.Wins,
			&i.Losses,
			&i.Assists,
			&i.Rebounds,
			&i.Steals,
			&i.PhotoUrl,
			&i.TeamID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCustomer = `-- name: GetCustomer :one
SELECT u.id, u.hubspot_id, u.country_alpha2_code, u.gender, u.first_name, u.last_name, u.parent_id, u.phone, u.email, u.has_marketing_email_consent, u.has_sms_consent, u.created_at, u.updated_at, u.dob, u.is_archived, u.square_customer_id, u.stripe_customer_id, u.notes, u.deleted_at, u.scheduled_deletion_at, u.email_verified, u.email_verification_token, u.email_verification_token_expires_at, u.email_verified_at, u.suspended_at, u.suspension_reason, u.suspended_by, u.suspension_expires_at, u.emergency_contact_name, u.emergency_contact_phone, u.emergency_contact_relationship,
       m.name           AS membership_name,
       mp.id            AS membership_plan_id,
       mp.name          AS membership_plan_name,
       cmp.start_date   AS membership_start_date,
       cmp.renewal_date AS membership_plan_renewal_date,
       a.points,
       a.wins,
       a.losses,
       a.assists,
       a.rebounds,
       a.steals,
       a.photo_url
FROM users.users u
         LEFT JOIN users.customer_membership_plans cmp ON (
    cmp.customer_id = u.id AND
    cmp.start_date = (SELECT MAX(start_date)
                      FROM users.customer_membership_plans
                      WHERE customer_id = u.id)
    )
         LEFT JOIN membership.membership_plans mp ON mp.id = cmp.membership_plan_id
         LEFT JOIN membership.memberships m ON m.id = mp.membership_id
         LEFT JOIN athletic.athletes a ON u.id = a.id
WHERE u.is_archived = FALSE
  AND (u.id = $1 OR $1 IS NULL)
  AND (u.email = $2 OR $2 IS NULL)
  AND NOT EXISTS (SELECT 1
                  FROM staff.staff s
                  WHERE s.id = u.id)
`

type GetCustomerParams struct {
	ID    uuid.NullUUID  `json:"id"`
	Email sql.NullString `json:"email"`
}

type GetCustomerRow struct {
	ID                              uuid.UUID      `json:"id"`
	HubspotID                       sql.NullString `json:"hubspot_id"`
	CountryAlpha2Code               string         `json:"country_alpha2_code"`
	Gender                          sql.NullString `json:"gender"`
	FirstName                       string         `json:"first_name"`
	LastName                        string         `json:"last_name"`
	ParentID                        uuid.NullUUID  `json:"parent_id"`
	Phone                           sql.NullString `json:"phone"`
	Email                           sql.NullString `json:"email"`
	HasMarketingEmailConsent        bool           `json:"has_marketing_email_consent"`
	HasSmsConsent                   bool           `json:"has_sms_consent"`
	CreatedAt                       time.Time      `json:"created_at"`
	UpdatedAt                       time.Time      `json:"updated_at"`
	Dob                             time.Time      `json:"dob"`
	IsArchived                      bool           `json:"is_archived"`
	SquareCustomerID                sql.NullString `json:"square_customer_id"`
	StripeCustomerID                sql.NullString `json:"stripe_customer_id"`
	Notes                           sql.NullString `json:"notes"`
	DeletedAt                       sql.NullTime   `json:"deleted_at"`
	ScheduledDeletionAt             sql.NullTime   `json:"scheduled_deletion_at"`
	EmailVerified                   bool           `json:"email_verified"`
	EmailVerificationToken          sql.NullString `json:"email_verification_token"`
	EmailVerificationTokenExpiresAt sql.NullTime   `json:"email_verification_token_expires_at"`
	EmailVerifiedAt                 sql.NullTime   `json:"email_verified_at"`
	SuspendedAt                     sql.NullTime   `json:"suspended_at"`
	SuspensionReason                sql.NullString `json:"suspension_reason"`
	SuspendedBy                     uuid.NullUUID  `json:"suspended_by"`
	SuspensionExpiresAt             sql.NullTime   `json:"suspension_expires_at"`
	EmergencyContactName            sql.NullString `json:"emergency_contact_name"`
	EmergencyContactPhone           sql.NullString `json:"emergency_contact_phone"`
	EmergencyContactRelationship    sql.NullString `json:"emergency_contact_relationship"`
	MembershipName                  sql.NullString `json:"membership_name"`
	MembershipPlanID                uuid.NullUUID  `json:"membership_plan_id"`
	MembershipPlanName              sql.NullString `json:"membership_plan_name"`
	MembershipStartDate             sql.NullTime   `json:"membership_start_date"`
	MembershipPlanRenewalDate       sql.NullTime   `json:"membership_plan_renewal_date"`
	Points                          sql.NullInt32  `json:"points"`
	Wins                            sql.NullInt32  `json:"wins"`
	Losses                          sql.NullInt32  `json:"losses"`
	Assists                         sql.NullInt32  `json:"assists"`
	Rebounds                        sql.NullInt32  `json:"rebounds"`
	Steals                          sql.NullInt32  `json:"steals"`
	PhotoUrl                        sql.NullString `json:"photo_url"`
}

func (q *Queries) GetCustomer(ctx context.Context, arg GetCustomerParams) (GetCustomerRow, error) {
	row := q.db.QueryRowContext(ctx, getCustomer, arg.ID, arg.Email)
	var i GetCustomerRow
	err := row.Scan(
		&i.ID,
		&i.HubspotID,
		&i.CountryAlpha2Code,
		&i.Gender,
		&i.FirstName,
		&i.LastName,
		&i.ParentID,
		&i.Phone,
		&i.Email,
		&i.HasMarketingEmailConsent,
		&i.HasSmsConsent,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Dob,
		&i.IsArchived,
		&i.SquareCustomerID,
		&i.StripeCustomerID,
		&i.Notes,
		&i.DeletedAt,
		&i.ScheduledDeletionAt,
		&i.EmailVerified,
		&i.EmailVerificationToken,
		&i.EmailVerificationTokenExpiresAt,
		&i.EmailVerifiedAt,
		&i.SuspendedAt,
		&i.SuspensionReason,
		&i.SuspendedBy,
		&i.SuspensionExpiresAt,
		&i.EmergencyContactName,
		&i.EmergencyContactPhone,
		&i.EmergencyContactRelationship,
		&i.MembershipName,
		&i.MembershipPlanID,
		&i.MembershipPlanName,
		&i.MembershipStartDate,
		&i.MembershipPlanRenewalDate,
		&i.Points,
		&i.Wins,
		&i.Losses,
		&i.Assists,
		&i.Rebounds,
		&i.Steals,
		&i.PhotoUrl,
	)
	return i, err
}

const getCustomers = `-- name: GetCustomers :many
SELECT u.id, u.hubspot_id, u.country_alpha2_code, u.gender, u.first_name, u.last_name, u.parent_id, u.phone, u.email, u.has_marketing_email_consent, u.has_sms_consent, u.created_at, u.updated_at, u.dob, u.is_archived, u.square_customer_id, u.stripe_customer_id, u.notes, u.deleted_at, u.scheduled_deletion_at, u.email_verified, u.email_verification_token, u.email_verification_token_expires_at, u.email_verified_at, u.suspended_at, u.suspension_reason, u.suspended_by, u.suspension_expires_at, u.emergency_contact_name, u.emergency_contact_phone, u.emergency_contact_relationship,
       m.name           AS membership_name,
       mp.id            AS membership_plan_id,
       mp.name          AS membership_plan_name,
       cmp.start_date   AS membership_start_date,
       cmp.renewal_date AS membership_plan_renewal_date,
       a.points,
       a.wins,
       a.losses,
       a.assists,
       a.rebounds,
       a.steals,
       a.photo_url
FROM users.users u
         LEFT JOIN users.customer_membership_plans cmp ON (
    cmp.customer_id = u.id AND
    cmp.start_date = (SELECT MAX(start_date)
                      FROM users.customer_membership_plans
                      WHERE customer_id = u.id)
    )
         LEFT JOIN membership.membership_plans mp ON mp.id = cmp.membership_plan_id
         LEFT JOIN membership.memberships m ON m.id = mp.membership_id
         LEFT JOIN athletic.athletes a ON u.id = a.id
WHERE u.is_archived = FALSE
  AND (u.parent_id = $1 OR $1 IS NULL)
  AND ($2::varchar IS NULL
  OR u.first_name ILIKE $2 || '%'
  OR u.last_name ILIKE $2 || '%'
  OR u.email ILIKE $2 || '%'
  OR u.phone ILIKE $2 || '%'
  OR u.notes ILIKE $2 || '%')
  AND NOT EXISTS (SELECT 1
                  FROM staff.staff s
                  WHERE s.id = u.id)
ORDER BY CASE WHEN cmp.status = 'active' THEN 0 ELSE 1 END, u.created_at DESC
LIMIT $4 OFFSET $3
`

type GetCustomersParams struct {
	ParentID uuid.NullUUID  `json:"parent_id"`
	Search   sql.NullString `json:"search"`
	Offset   int32          `json:"offset"`
	Limit    int32          `json:"limit"`
}

type GetCustomersRow struct {
	ID                              uuid.UUID      `json:"id"`
	HubspotID                       sql.NullString `json:"hubspot_id"`
	CountryAlpha2Code               string         `json:"country_alpha2_code"`
	Gender                          sql.NullString `json:"gender"`
	FirstName                       string         `json:"first_name"`
	LastName                        string         `json:"last_name"`
	ParentID                        uuid.NullUUID  `json:"parent_id"`
	Phone                           sql.NullString `json:"phone"`
	Email                           sql.NullString `json:"email"`
	HasMarketingEmailConsent        bool           `json:"has_marketing_email_consent"`
	HasSmsConsent                   bool           `json:"has_sms_consent"`
	CreatedAt                       time.Time      `json:"created_at"`
	UpdatedAt                       time.Time      `json:"updated_at"`
	Dob                             time.Time      `json:"dob"`
	IsArchived                      bool           `json:"is_archived"`
	SquareCustomerID                sql.NullString `json:"square_customer_id"`
	StripeCustomerID                sql.NullString `json:"stripe_customer_id"`
	Notes                           sql.NullString `json:"notes"`
	DeletedAt                       sql.NullTime   `json:"deleted_at"`
	ScheduledDeletionAt             sql.NullTime   `json:"scheduled_deletion_at"`
	EmailVerified                   bool           `json:"email_verified"`
	EmailVerificationToken          sql.NullString `json:"email_verification_token"`
	EmailVerificationTokenExpiresAt sql.NullTime   `json:"email_verification_token_expires_at"`
	EmailVerifiedAt                 sql.NullTime   `json:"email_verified_at"`
	SuspendedAt                     sql.NullTime   `json:"suspended_at"`
	SuspensionReason                sql.NullString `json:"suspension_reason"`
	SuspendedBy                     uuid.NullUUID  `json:"suspended_by"`
	SuspensionExpiresAt             sql.NullTime   `json:"suspension_expires_at"`
	EmergencyContactName            sql.NullString `json:"emergency_contact_name"`
	EmergencyContactPhone           sql.NullString `json:"emergency_contact_phone"`
	EmergencyContactRelationship    sql.NullString `json:"emergency_contact_relationship"`
	MembershipName                  sql.NullString `json:"membership_name"`
	MembershipPlanID                uuid.NullUUID  `json:"membership_plan_id"`
	MembershipPlanName              sql.NullString `json:"membership_plan_name"`
	MembershipStartDate             sql.NullTime   `json:"membership_start_date"`
	MembershipPlanRenewalDate       sql.NullTime   `json:"membership_plan_renewal_date"`
	Points                          sql.NullInt32  `json:"points"`
	Wins                            sql.NullInt32  `json:"wins"`
	Losses                          sql.NullInt32  `json:"losses"`
	Assists                         sql.NullInt32  `json:"assists"`
	Rebounds                        sql.NullInt32  `json:"rebounds"`
	Steals                          sql.NullInt32  `json:"steals"`
	PhotoUrl                        sql.NullString `json:"photo_url"`
}

func (q *Queries) GetCustomers(ctx context.Context, arg GetCustomersParams) ([]GetCustomersRow, error) {
	rows, err := q.db.QueryContext(ctx, getCustomers,
		arg.ParentID,
		arg.Search,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCustomersRow
	for rows.Next() {
		var i GetCustomersRow
		if err := rows.Scan(
			&i.ID,
			&i.HubspotID,
			&i.CountryAlpha2Code,
			&i.Gender,
			&i.FirstName,
			&i.LastName,
			&i.ParentID,
			&i.Phone,
			&i.Email,
			&i.HasMarketingEmailConsent,
			&i.HasSmsConsent,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Dob,
			&i.IsArchived,
			&i.SquareCustomerID,
			&i.StripeCustomerID,
			&i.Notes,
			&i.DeletedAt,
			&i.ScheduledDeletionAt,
			&i.EmailVerified,
			&i.EmailVerificationToken,
			&i.EmailVerificationTokenExpiresAt,
			&i.EmailVerifiedAt,
			&i.SuspendedAt,
			&i.SuspensionReason,
			&i.SuspendedBy,
			&i.SuspensionExpiresAt,
			&i.EmergencyContactName,
			&i.EmergencyContactPhone,
			&i.EmergencyContactRelationship,
			&i.MembershipName,
			&i.MembershipPlanID,
			&i.MembershipPlanName,
			&i.MembershipStartDate,
			&i.MembershipPlanRenewalDate,
			&i.Points,
			&i.Wins,
			&i.Losses,
			&i.Assists,
			&i.Rebounds,
			&i.Steals,
			&i.PhotoUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMembershipByStripeSubscriptionID = `-- name: GetMembershipByStripeSubscriptionID :one
SELECT id, customer_id, membership_plan_id, start_date, renewal_date, status, created_at, updated_at, photo_url, square_subscription_id, subscription_status, next_billing_date, subscription_created_at, subscription_source, suspended_at, suspension_billing_paused, stripe_subscription_id
FROM users.customer_membership_plans
WHERE square_subscription_id = $1
LIMIT 1
`

func (q *Queries) GetMembershipByStripeSubscriptionID(ctx context.Context, subscriptionID sql.NullString) (UsersCustomerMembershipPlan, error) {
	row := q.db.QueryRowContext(ctx, getMembershipByStripeSubscriptionID, subscriptionID)
	var i UsersCustomerMembershipPlan
	err := row.Scan(
		&i.ID,
		&i.CustomerID,
		&i.MembershipPlanID,
		&i.StartDate,
		&i.RenewalDate,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.PhotoUrl,
		&i.SquareSubscriptionID,
		&i.SubscriptionStatus,
		&i.NextBillingDate,
		&i.SubscriptionCreatedAt,
		&i.SubscriptionSource,
		&i.SuspendedAt,
		&i.SuspensionBillingPaused,
		&i.StripeSubscriptionID,
	)
	return i, err
}

const getSuspensionInfo = `-- name: GetSuspensionInfo :one
SELECT
    u.suspended_at,
    u.suspension_reason,
    suspender.first_name || ' ' || suspender.last_name as suspended_by,
    u.suspension_expires_at
FROM users.users u
LEFT JOIN users.users suspender ON suspender.id = u.suspended_by
WHERE u.id = $1
`

type GetSuspensionInfoRow struct {
	SuspendedAt         sql.NullTime   `json:"suspended_at"`
	SuspensionReason    sql.NullString `json:"suspension_reason"`
	SuspendedBy         interface{}    `json:"suspended_by"`
	SuspensionExpiresAt sql.NullTime   `json:"suspension_expires_at"`
}

func (q *Queries) GetSuspensionInfo(ctx context.Context, userID uuid.UUID) (GetSuspensionInfoRow, error) {
	row := q.db.QueryRowContext(ctx, getSuspensionInfo, userID)
	var i GetSuspensionInfoRow
	err := row.Scan(
		&i.SuspendedAt,
		&i.SuspensionReason,
		&i.SuspendedBy,
		&i.SuspensionExpiresAt,
	)
	return i, err
}

const getUserActiveMemberships = `-- name: GetUserActiveMemberships :many
SELECT id, customer_id, membership_plan_id, start_date, renewal_date, status, created_at, updated_at, photo_url, square_subscription_id, subscription_status, next_billing_date, subscription_created_at, subscription_source, suspended_at, suspension_billing_paused, stripe_subscription_id
FROM users.customer_membership_plans
WHERE customer_id = $1
  AND status = 'active'
`

func (q *Queries) GetUserActiveMemberships(ctx context.Context, userID uuid.UUID) ([]UsersCustomerMembershipPlan, error) {
	rows, err := q.db.QueryContext(ctx, getUserActiveMemberships, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UsersCustomerMembershipPlan
	for rows.Next() {
		var i UsersCustomerMembershipPlan
		if err := rows.Scan(
			&i.ID,
			&i.CustomerID,
			&i.MembershipPlanID,
			&i.StartDate,
			&i.RenewalDate,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.PhotoUrl,
			&i.SquareSubscriptionID,
			&i.SubscriptionStatus,
			&i.NextBillingDate,
			&i.SubscriptionCreatedAt,
			&i.SubscriptionSource,
			&i.SuspendedAt,
			&i.SuspensionBillingPaused,
			&i.StripeSubscriptionID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserSuspendedMemberships = `-- name: GetUserSuspendedMemberships :many
SELECT id, customer_id, membership_plan_id, start_date, renewal_date, status, created_at, updated_at, photo_url, square_subscription_id, subscription_status, next_billing_date, subscription_created_at, subscription_source, suspended_at, suspension_billing_paused, stripe_subscription_id
FROM users.customer_membership_plans
WHERE customer_id = $1
  AND suspended_at IS NOT NULL
`

func (q *Queries) GetUserSuspendedMemberships(ctx context.Context, userID uuid.UUID) ([]UsersCustomerMembershipPlan, error) {
	rows, err := q.db.QueryContext(ctx, getUserSuspendedMemberships, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UsersCustomerMembershipPlan
	for rows.Next() {
		var i UsersCustomerMembershipPlan
		if err := rows.Scan(
			&i.ID,
			&i.CustomerID,
			&i.MembershipPlanID,
			&i.StartDate,
			&i.RenewalDate,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.PhotoUrl,
			&i.SquareSubscriptionID,
			&i.SubscriptionStatus,
			&i.NextBillingDate,
			&i.SubscriptionCreatedAt,
			&i.SubscriptionSource,
			&i.SuspendedAt,
			&i.SuspensionBillingPaused,
			&i.StripeSubscriptionID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listArchivedCustomers = `-- name: ListArchivedCustomers :many
SELECT u.id, u.hubspot_id, u.country_alpha2_code, u.gender, u.first_name, u.last_name, u.parent_id, u.phone, u.email, u.has_marketing_email_consent, u.has_sms_consent, u.created_at, u.updated_at, u.dob, u.is_archived, u.square_customer_id, u.stripe_customer_id, u.notes, u.deleted_at, u.scheduled_deletion_at, u.email_verified, u.email_verification_token, u.email_verification_token_expires_at, u.email_verified_at, u.suspended_at, u.suspension_reason, u.suspended_by, u.suspension_expires_at, u.emergency_contact_name, u.emergency_contact_phone, u.emergency_contact_relationship
FROM users.users u
WHERE u.is_archived = TRUE
LIMIT $2 OFFSET $1
`

type ListArchivedCustomersParams struct {
	Offset int32 `json:"offset"`
	Limit  int32 `json:"limit"`
}

func (q *Queries) ListArchivedCustomers(ctx context.Context, arg ListArchivedCustomersParams) ([]UsersUser, error) {
	rows, err := q.db.QueryContext(ctx, listArchivedCustomers, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UsersUser
	for rows.Next() {
		var i UsersUser
		if err := rows.Scan(
			&i.ID,
			&i.HubspotID,
			&i.CountryAlpha2Code,
			&i.Gender,
			&i.FirstName,
			&i.LastName,
			&i.ParentID,
			&i.Phone,
			&i.Email,
			&i.HasMarketingEmailConsent,
			&i.HasSmsConsent,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Dob,
			&i.IsArchived,
			&i.SquareCustomerID,
			&i.StripeCustomerID,
			&i.Notes,
			&i.DeletedAt,
			&i.ScheduledDeletionAt,
			&i.EmailVerified,
			&i.EmailVerificationToken,
			&i.EmailVerificationTokenExpiresAt,
			&i.EmailVerifiedAt,
			&i.SuspendedAt,
			&i.SuspensionReason,
			&i.SuspendedBy,
			&i.SuspensionExpiresAt,
			&i.EmergencyContactName,
			&i.EmergencyContactPhone,
			&i.EmergencyContactRelationship,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMembershipHistory = `-- name: ListMembershipHistory :many
SELECT
    cmp.id,
    cmp.customer_id,
    cmp.start_date,
    cmp.renewal_date,
    cmp.status,
    cmp.created_at,
    cmp.updated_at,
    mp.membership_id,
    m.name AS membership_name,
    m.description AS membership_description,
    m.benefits AS membership_benefits,
    mp.id AS membership_plan_id,
    mp.name AS membership_plan_name,
    mp.unit_amount,
    mp.currency,
    mp.interval,
    mp.stripe_price_id
FROM users.customer_membership_plans cmp
    JOIN membership.membership_plans mp ON mp.id = cmp.membership_plan_id
    JOIN membership.memberships m ON m.id = mp.membership_id
WHERE cmp.customer_id = $1
ORDER BY cmp.start_date DESC
`

type ListMembershipHistoryRow struct {
	ID                    uuid.UUID                  `json:"id"`
	CustomerID            uuid.UUID                  `json:"customer_id"`
	StartDate             time.Time                  `json:"start_date"`
	RenewalDate           sql.NullTime               `json:"renewal_date"`
	Status                MembershipMembershipStatus `json:"status"`
	CreatedAt             time.Time                  `json:"created_at"`
	UpdatedAt             time.Time                  `json:"updated_at"`
	MembershipID          uuid.UUID                  `json:"membership_id"`
	MembershipName        string                     `json:"membership_name"`
	MembershipDescription string                     `json:"membership_description"`
	MembershipBenefits    string                     `json:"membership_benefits"`
	MembershipPlanID      uuid.UUID                  `json:"membership_plan_id"`
	MembershipPlanName    string                     `json:"membership_plan_name"`
	UnitAmount            sql.NullInt32              `json:"unit_amount"`
	Currency              sql.NullString             `json:"currency"`
	Interval              sql.NullString             `json:"interval"`
	StripePriceID         string                     `json:"stripe_price_id"`
}

func (q *Queries) ListMembershipHistory(ctx context.Context, customerID uuid.UUID) ([]ListMembershipHistoryRow, error) {
	rows, err := q.db.QueryContext(ctx, listMembershipHistory, customerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListMembershipHistoryRow
	for rows.Next() {
		var i ListMembershipHistoryRow
		if err := rows.Scan(
			&i.ID,
			&i.CustomerID,
			&i.StartDate,
			&i.RenewalDate,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.MembershipID,
			&i.MembershipName,
			&i.MembershipDescription,
			&i.MembershipBenefits,
			&i.MembershipPlanID,
			&i.MembershipPlanName,
			&i.UnitAmount,
			&i.Currency,
			&i.Interval,
			&i.StripePriceID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const suspendUser = `-- name: SuspendUser :execrows
UPDATE users.users
SET suspended_at = $1,
    suspension_reason = $2,
    suspended_by = $3,
    suspension_expires_at = $4,
    updated_at = current_timestamp
WHERE id = $5
`

type SuspendUserParams struct {
	SuspendedAt         sql.NullTime   `json:"suspended_at"`
	SuspensionReason    sql.NullString `json:"suspension_reason"`
	SuspendedBy         uuid.NullUUID  `json:"suspended_by"`
	SuspensionExpiresAt sql.NullTime   `json:"suspension_expires_at"`
	UserID              uuid.UUID      `json:"user_id"`
}

func (q *Queries) SuspendUser(ctx context.Context, arg SuspendUserParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, suspendUser,
		arg.SuspendedAt,
		arg.SuspensionReason,
		arg.SuspendedBy,
		arg.SuspensionExpiresAt,
		arg.UserID,
	)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const suspendUserMemberships = `-- name: SuspendUserMemberships :execrows
UPDATE users.customer_membership_plans
SET suspended_at = $1,
    suspension_billing_paused = TRUE,
    updated_at = current_timestamp
WHERE customer_id = $2
  AND status = 'active'
`

type SuspendUserMembershipsParams struct {
	SuspendedAt sql.NullTime `json:"suspended_at"`
	UserID      uuid.UUID    `json:"user_id"`
}

func (q *Queries) SuspendUserMemberships(ctx context.Context, arg SuspendUserMembershipsParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, suspendUserMemberships, arg.SuspendedAt, arg.UserID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const unarchiveCustomer = `-- name: UnarchiveCustomer :execrows
UPDATE users.users
SET is_archived = FALSE,
    updated_at = current_timestamp
WHERE id = $1
`

func (q *Queries) UnarchiveCustomer(ctx context.Context, id uuid.UUID) (int64, error) {
	result, err := q.db.ExecContext(ctx, unarchiveCustomer, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const unsuspendUser = `-- name: UnsuspendUser :execrows
UPDATE users.users
SET suspended_at = NULL,
    suspension_reason = NULL,
    suspended_by = NULL,
    suspension_expires_at = NULL,
    updated_at = current_timestamp
WHERE id = $1
`

func (q *Queries) UnsuspendUser(ctx context.Context, userID uuid.UUID) (int64, error) {
	result, err := q.db.ExecContext(ctx, unsuspendUser, userID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const unsuspendUserMemberships = `-- name: UnsuspendUserMemberships :execrows
UPDATE users.customer_membership_plans
SET suspended_at = NULL,
    suspension_billing_paused = FALSE,
    updated_at = current_timestamp
WHERE customer_id = $1
  AND suspended_at IS NOT NULL
`

func (q *Queries) UnsuspendUserMemberships(ctx context.Context, userID uuid.UUID) (int64, error) {
	result, err := q.db.ExecContext(ctx, unsuspendUserMemberships, userID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const updateAthleteProfile = `-- name: UpdateAthleteProfile :execrows
UPDATE athletic.athletes
SET photo_url  = $2,
    updated_at = current_timestamp
WHERE id = $1
`

type UpdateAthleteProfileParams struct {
	ID       uuid.UUID      `json:"id"`
	PhotoUrl sql.NullString `json:"photo_url"`
}

func (q *Queries) UpdateAthleteProfile(ctx context.Context, arg UpdateAthleteProfileParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, updateAthleteProfile, arg.ID, arg.PhotoUrl)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const updateAthleteStats = `-- name: UpdateAthleteStats :execrows
UPDATE athletic.athletes
SET wins       = COALESCE($1, wins),
    losses     = COALESCE($2, losses),
    points     = COALESCE($3, points),
    steals     = COALESCE($4, steals),
    assists    = COALESCE($5, assists),
    rebounds   = COALESCE($6, rebounds),
    updated_at = current_timestamp
WHERE id = $7
`

type UpdateAthleteStatsParams struct {
	Wins     sql.NullInt32 `json:"wins"`
	Losses   sql.NullInt32 `json:"losses"`
	Points   sql.NullInt32 `json:"points"`
	Steals   sql.NullInt32 `json:"steals"`
	Assists  sql.NullInt32 `json:"assists"`
	Rebounds sql.NullInt32 `json:"rebounds"`
	ID       uuid.UUID     `json:"id"`
}

func (q *Queries) UpdateAthleteStats(ctx context.Context, arg UpdateAthleteStatsParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, updateAthleteStats,
		arg.Wins,
		arg.Losses,
		arg.Points,
		arg.Steals,
		arg.Assists,
		arg.Rebounds,
		arg.ID,
	)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const updateAthleteTeam = `-- name: UpdateAthleteTeam :execrows
UPDATE athletic.athletes
SET team_id = $1
WHERE id = $2
`

type UpdateAthleteTeamParams struct {
	TeamID    uuid.NullUUID `json:"team_id"`
	AthleteID uuid.UUID     `json:"athlete_id"`
}

func (q *Queries) UpdateAthleteTeam(ctx context.Context, arg UpdateAthleteTeamParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, updateAthleteTeam, arg.TeamID, arg.AthleteID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const updateCustomerNotes = `-- name: UpdateCustomerNotes :execrows
UPDATE users.users
SET notes = $1,
    updated_at = current_timestamp
WHERE id = $2
`

type UpdateCustomerNotesParams struct {
	Notes      sql.NullString `json:"notes"`
	CustomerID uuid.UUID      `json:"customer_id"`
}

func (q *Queries) UpdateCustomerNotes(ctx context.Context, arg UpdateCustomerNotesParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, updateCustomerNotes, arg.Notes, arg.CustomerID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}
