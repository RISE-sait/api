// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: recurrence_queries.sql

package db_event

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
)

const deleteUnmodifiedEventsByRecurrenceID = `-- name: DeleteUnmodifiedEventsByRecurrenceID :exec
DELETE
FROM events.events
WHERE recurrence_id = $1
  AND is_date_time_modified = false
  AND start_at >= CURRENT_TIMESTAMP
  AND NOT EXISTS (SELECT 1
                  FROM events.customer_enrollment ce
                  WHERE ce.event_id = events.events.id
                    AND ce.is_cancelled = false)
`

func (q *Queries) DeleteUnmodifiedEventsByRecurrenceID(ctx context.Context, recurrenceID uuid.NullUUID) error {
	_, err := q.db.ExecContext(ctx, deleteUnmodifiedEventsByRecurrenceID, recurrenceID)
	return err
}

const getEventsRecurrence = `-- name: GetEventsRecurrence :many
SELECT trim(to_char(start_at, 'Day')) AS day_of_week, -- More readable
       to_char(start_at, 'HH24:MI')   AS start_time,
       to_char(end_at, 'HH24:MI')     AS end_time,
       recurrence_id,
       p.id                           AS program_id,
       p.name                         AS program_name,
       p.description                  AS program_description,
       p.type                         AS program_type,

       location_id,
       l.name                         AS location_name,
       l.address                      AS location_address,

       t.id                           AS team_id,
       t.name                         AS team_name,

       COUNT(*)                       AS event_count,
       MIN(start_at)::timestamp       AS first_occurrence,
       MAX(end_at)::timestamp         AS last_occurrence
FROM events.events e
         LEFT JOIN events.staff es ON e.id = es.event_id
         LEFT JOIN events.customer_enrollment ce ON e.id = ce.event_id
         JOIN program.programs p ON e.program_id = p.id
         LEFT JOIN athletic.teams t ON e.team_id = t.id
         JOIN location.locations l ON e.location_id = l.id
WHERE ($1::uuid IS NULL OR program_id = $1::uuid)
  AND ($2::uuid IS NULL OR e.team_id = $2)
  AND ($3::uuid IS NULL OR location_id = $3::uuid)
  AND ($4::uuid IS NULL OR e.created_by = $4)
  AND ($5::uuid IS NULL OR e.updated_by = $5)
  AND ($6::timestamp IS NULL OR start_at >= $6::timestamp)
  AND ($7::timestamp IS NULL OR end_at <= $7::timestamp)
  AND ($8 = p.type OR $8 IS NULL)
  AND ($9::uuid IS NULL OR ce.customer_id = $9::uuid OR
       es.staff_id = $9::uuid)
GROUP BY to_char(start_at, 'Day'),
         to_char(start_at, 'HH24:MI'),
         to_char(end_at, 'HH24:MI'),
         p.id,
         p.name,
         p.description,
         p.type,
         t.id,
         t.name,
         location_id,
         l.name,
         l.address,
        recurrence_id
`

type GetEventsRecurrenceParams struct {
	ProgramID  uuid.NullUUID          `json:"program_id"`
	TeamID     uuid.NullUUID          `json:"team_id"`
	LocationID uuid.NullUUID          `json:"location_id"`
	CreatedBy  uuid.NullUUID          `json:"created_by"`
	UpdatedBy  uuid.NullUUID          `json:"updated_by"`
	After      sql.NullTime           `json:"after"`
	Before     sql.NullTime           `json:"before"`
	Type       NullProgramProgramType `json:"type"`
	UserID     uuid.NullUUID          `json:"user_id"`
}

type GetEventsRecurrenceRow struct {
	DayOfWeek          string             `json:"day_of_week"`
	StartTime          string             `json:"start_time"`
	EndTime            string             `json:"end_time"`
	RecurrenceID       uuid.NullUUID      `json:"recurrence_id"`
	ProgramID          uuid.UUID          `json:"program_id"`
	ProgramName        string             `json:"program_name"`
	ProgramDescription string             `json:"program_description"`
	ProgramType        ProgramProgramType `json:"program_type"`
	LocationID         uuid.UUID          `json:"location_id"`
	LocationName       string             `json:"location_name"`
	LocationAddress    string             `json:"location_address"`
	TeamID             uuid.NullUUID      `json:"team_id"`
	TeamName           sql.NullString     `json:"team_name"`
	EventCount         int64              `json:"event_count"`
	FirstOccurrence    time.Time          `json:"first_occurrence"`
	LastOccurrence     time.Time          `json:"last_occurrence"`
}

func (q *Queries) GetEventsRecurrence(ctx context.Context, arg GetEventsRecurrenceParams) ([]GetEventsRecurrenceRow, error) {
	rows, err := q.db.QueryContext(ctx, getEventsRecurrence,
		arg.ProgramID,
		arg.TeamID,
		arg.LocationID,
		arg.CreatedBy,
		arg.UpdatedBy,
		arg.After,
		arg.Before,
		arg.Type,
		arg.UserID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetEventsRecurrenceRow
	for rows.Next() {
		var i GetEventsRecurrenceRow
		if err := rows.Scan(
			&i.DayOfWeek,
			&i.StartTime,
			&i.EndTime,
			&i.RecurrenceID,
			&i.ProgramID,
			&i.ProgramName,
			&i.ProgramDescription,
			&i.ProgramType,
			&i.LocationID,
			&i.LocationName,
			&i.LocationAddress,
			&i.TeamID,
			&i.TeamName,
			&i.EventCount,
			&i.FirstOccurrence,
			&i.LastOccurrence,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
