// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: push_tokens.sql

package generated

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
)

const deletePushToken = `-- name: DeletePushToken :exec
DELETE FROM notifications.push_tokens 
WHERE user_id = $1 AND device_type = $2
`

type DeletePushTokenParams struct {
	UserID     uuid.UUID      `json:"user_id"`
	DeviceType sql.NullString `json:"device_type"`
}

func (q *Queries) DeletePushToken(ctx context.Context, arg DeletePushTokenParams) error {
	_, err := q.db.ExecContext(ctx, deletePushToken, arg.UserID, arg.DeviceType)
	return err
}

const getPushTokensByTeamID = `-- name: GetPushTokensByTeamID :many
SELECT DISTINCT pt.id, pt.user_id, pt.expo_push_token, pt.device_type, pt.created_at, pt.updated_at FROM notifications.push_tokens pt
JOIN users.users u ON pt.user_id = u.id
WHERE u.id IN (
    -- Team athletes (id column references users.users.id)
    SELECT a.id FROM athletic.athletes a WHERE a.team_id = $1
    UNION
    -- Team coach
    SELECT t.coach_id FROM athletic.teams t WHERE t.id = $1
)
`

func (q *Queries) GetPushTokensByTeamID(ctx context.Context, teamID uuid.NullUUID) ([]NotificationsPushToken, error) {
	rows, err := q.db.QueryContext(ctx, getPushTokensByTeamID, teamID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []NotificationsPushToken
	for rows.Next() {
		var i NotificationsPushToken
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.ExpoPushToken,
			&i.DeviceType,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPushTokensByUserID = `-- name: GetPushTokensByUserID :many
SELECT id, user_id, expo_push_token, device_type, created_at, updated_at FROM notifications.push_tokens 
WHERE user_id = $1
`

func (q *Queries) GetPushTokensByUserID(ctx context.Context, userID uuid.UUID) ([]NotificationsPushToken, error) {
	rows, err := q.db.QueryContext(ctx, getPushTokensByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []NotificationsPushToken
	for rows.Next() {
		var i NotificationsPushToken
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.ExpoPushToken,
			&i.DeviceType,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertPushToken = `-- name: UpsertPushToken :one
INSERT INTO notifications.push_tokens (user_id, expo_push_token, device_type)
VALUES ($1, $2, $3)
ON CONFLICT (user_id, device_type)
DO UPDATE SET 
    expo_push_token = EXCLUDED.expo_push_token,
    updated_at = CURRENT_TIMESTAMP
RETURNING id, user_id, expo_push_token, device_type, created_at, updated_at
`

type UpsertPushTokenParams struct {
	UserID        uuid.UUID      `json:"user_id"`
	ExpoPushToken string         `json:"expo_push_token"`
	DeviceType    sql.NullString `json:"device_type"`
}

func (q *Queries) UpsertPushToken(ctx context.Context, arg UpsertPushTokenParams) (NotificationsPushToken, error) {
	row := q.db.QueryRowContext(ctx, upsertPushToken, arg.UserID, arg.ExpoPushToken, arg.DeviceType)
	var i NotificationsPushToken
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ExpoPushToken,
		&i.DeviceType,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
