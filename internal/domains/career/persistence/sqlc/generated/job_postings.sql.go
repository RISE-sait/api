// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: job_postings.sql

package db_career

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
	"github.com/lib/pq"
)

const createJobPosting = `-- name: CreateJobPosting :one
INSERT INTO careers.job_postings (
    title, position, employment_type, location_type, description,
    responsibilities, requirements, nice_to_have,
    salary_min, salary_max, show_salary, status, closing_date, created_by
) VALUES (
    $1, $2, $3, $4, $5,
    $6, $7, $8,
    $9, $10, $11, $12, $13, $14
)
RETURNING id, title, position, employment_type, location_type, description, responsibilities, requirements, nice_to_have, salary_min, salary_max, show_salary, status, closing_date, created_by, published_at, created_at, updated_at
`

type CreateJobPostingParams struct {
	Title            string         `json:"title"`
	Position         string         `json:"position"`
	EmploymentType   string         `json:"employment_type"`
	LocationType     string         `json:"location_type"`
	Description      string         `json:"description"`
	Responsibilities []string       `json:"responsibilities"`
	Requirements     []string       `json:"requirements"`
	NiceToHave       []string       `json:"nice_to_have"`
	SalaryMin        sql.NullString `json:"salary_min"`
	SalaryMax        sql.NullString `json:"salary_max"`
	ShowSalary       bool           `json:"show_salary"`
	Status           string         `json:"status"`
	ClosingDate      sql.NullTime   `json:"closing_date"`
	CreatedBy        uuid.NullUUID  `json:"created_by"`
}

func (q *Queries) CreateJobPosting(ctx context.Context, arg CreateJobPostingParams) (CareersJobPosting, error) {
	row := q.db.QueryRowContext(ctx, createJobPosting,
		arg.Title,
		arg.Position,
		arg.EmploymentType,
		arg.LocationType,
		arg.Description,
		pq.Array(arg.Responsibilities),
		pq.Array(arg.Requirements),
		pq.Array(arg.NiceToHave),
		arg.SalaryMin,
		arg.SalaryMax,
		arg.ShowSalary,
		arg.Status,
		arg.ClosingDate,
		arg.CreatedBy,
	)
	var i CareersJobPosting
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Position,
		&i.EmploymentType,
		&i.LocationType,
		&i.Description,
		pq.Array(&i.Responsibilities),
		pq.Array(&i.Requirements),
		pq.Array(&i.NiceToHave),
		&i.SalaryMin,
		&i.SalaryMax,
		&i.ShowSalary,
		&i.Status,
		&i.ClosingDate,
		&i.CreatedBy,
		&i.PublishedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteJobPosting = `-- name: DeleteJobPosting :execrows
DELETE FROM careers.job_postings WHERE id = $1
`

func (q *Queries) DeleteJobPosting(ctx context.Context, id uuid.UUID) (int64, error) {
	result, err := q.db.ExecContext(ctx, deleteJobPosting, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const getJobPostingById = `-- name: GetJobPostingById :one
SELECT id, title, position, employment_type, location_type, description, responsibilities, requirements, nice_to_have, salary_min, salary_max, show_salary, status, closing_date, created_by, published_at, created_at, updated_at FROM careers.job_postings WHERE id = $1
`

func (q *Queries) GetJobPostingById(ctx context.Context, id uuid.UUID) (CareersJobPosting, error) {
	row := q.db.QueryRowContext(ctx, getJobPostingById, id)
	var i CareersJobPosting
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Position,
		&i.EmploymentType,
		&i.LocationType,
		&i.Description,
		pq.Array(&i.Responsibilities),
		pq.Array(&i.Requirements),
		pq.Array(&i.NiceToHave),
		&i.SalaryMin,
		&i.SalaryMax,
		&i.ShowSalary,
		&i.Status,
		&i.ClosingDate,
		&i.CreatedBy,
		&i.PublishedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getPublishedJobPostingById = `-- name: GetPublishedJobPostingById :one
SELECT id, title, position, employment_type, location_type, description, responsibilities, requirements, nice_to_have, salary_min, salary_max, show_salary, status, closing_date, created_by, published_at, created_at, updated_at FROM careers.job_postings
WHERE id = $1 AND status = 'published'
`

func (q *Queries) GetPublishedJobPostingById(ctx context.Context, id uuid.UUID) (CareersJobPosting, error) {
	row := q.db.QueryRowContext(ctx, getPublishedJobPostingById, id)
	var i CareersJobPosting
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Position,
		&i.EmploymentType,
		&i.LocationType,
		&i.Description,
		pq.Array(&i.Responsibilities),
		pq.Array(&i.Requirements),
		pq.Array(&i.NiceToHave),
		&i.SalaryMin,
		&i.SalaryMax,
		&i.ShowSalary,
		&i.Status,
		&i.ClosingDate,
		&i.CreatedBy,
		&i.PublishedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listAllJobPostings = `-- name: ListAllJobPostings :many
SELECT id, title, position, employment_type, location_type, description, responsibilities, requirements, nice_to_have, salary_min, salary_max, show_salary, status, closing_date, created_by, published_at, created_at, updated_at FROM careers.job_postings
ORDER BY created_at DESC
`

func (q *Queries) ListAllJobPostings(ctx context.Context) ([]CareersJobPosting, error) {
	rows, err := q.db.QueryContext(ctx, listAllJobPostings)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CareersJobPosting
	for rows.Next() {
		var i CareersJobPosting
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Position,
			&i.EmploymentType,
			&i.LocationType,
			&i.Description,
			pq.Array(&i.Responsibilities),
			pq.Array(&i.Requirements),
			pq.Array(&i.NiceToHave),
			&i.SalaryMin,
			&i.SalaryMax,
			&i.ShowSalary,
			&i.Status,
			&i.ClosingDate,
			&i.CreatedBy,
			&i.PublishedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPublishedJobPostings = `-- name: ListPublishedJobPostings :many
SELECT id, title, position, employment_type, location_type, description, responsibilities, requirements, nice_to_have, salary_min, salary_max, show_salary, status, closing_date, created_by, published_at, created_at, updated_at FROM careers.job_postings
WHERE status = 'published'
  AND (closing_date IS NULL OR closing_date > NOW())
ORDER BY published_at DESC
`

func (q *Queries) ListPublishedJobPostings(ctx context.Context) ([]CareersJobPosting, error) {
	rows, err := q.db.QueryContext(ctx, listPublishedJobPostings)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CareersJobPosting
	for rows.Next() {
		var i CareersJobPosting
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Position,
			&i.EmploymentType,
			&i.LocationType,
			&i.Description,
			pq.Array(&i.Responsibilities),
			pq.Array(&i.Requirements),
			pq.Array(&i.NiceToHave),
			&i.SalaryMin,
			&i.SalaryMax,
			&i.ShowSalary,
			&i.Status,
			&i.ClosingDate,
			&i.CreatedBy,
			&i.PublishedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateJobPosting = `-- name: UpdateJobPosting :one
UPDATE careers.job_postings SET
    title = $2,
    position = $3,
    employment_type = $4,
    location_type = $5,
    description = $6,
    responsibilities = $7,
    requirements = $8,
    nice_to_have = $9,
    salary_min = $10,
    salary_max = $11,
    show_salary = $12,
    closing_date = $13
WHERE id = $1
RETURNING id, title, position, employment_type, location_type, description, responsibilities, requirements, nice_to_have, salary_min, salary_max, show_salary, status, closing_date, created_by, published_at, created_at, updated_at
`

type UpdateJobPostingParams struct {
	ID               uuid.UUID      `json:"id"`
	Title            string         `json:"title"`
	Position         string         `json:"position"`
	EmploymentType   string         `json:"employment_type"`
	LocationType     string         `json:"location_type"`
	Description      string         `json:"description"`
	Responsibilities []string       `json:"responsibilities"`
	Requirements     []string       `json:"requirements"`
	NiceToHave       []string       `json:"nice_to_have"`
	SalaryMin        sql.NullString `json:"salary_min"`
	SalaryMax        sql.NullString `json:"salary_max"`
	ShowSalary       bool           `json:"show_salary"`
	ClosingDate      sql.NullTime   `json:"closing_date"`
}

func (q *Queries) UpdateJobPosting(ctx context.Context, arg UpdateJobPostingParams) (CareersJobPosting, error) {
	row := q.db.QueryRowContext(ctx, updateJobPosting,
		arg.ID,
		arg.Title,
		arg.Position,
		arg.EmploymentType,
		arg.LocationType,
		arg.Description,
		pq.Array(arg.Responsibilities),
		pq.Array(arg.Requirements),
		pq.Array(arg.NiceToHave),
		arg.SalaryMin,
		arg.SalaryMax,
		arg.ShowSalary,
		arg.ClosingDate,
	)
	var i CareersJobPosting
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Position,
		&i.EmploymentType,
		&i.LocationType,
		&i.Description,
		pq.Array(&i.Responsibilities),
		pq.Array(&i.Requirements),
		pq.Array(&i.NiceToHave),
		&i.SalaryMin,
		&i.SalaryMax,
		&i.ShowSalary,
		&i.Status,
		&i.ClosingDate,
		&i.CreatedBy,
		&i.PublishedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateJobPostingStatus = `-- name: UpdateJobPostingStatus :one
UPDATE careers.job_postings SET
    status = $2,
    published_at = CASE WHEN $3 = 'published' AND published_at IS NULL THEN NOW() ELSE published_at END
WHERE id = $1
RETURNING id, title, position, employment_type, location_type, description, responsibilities, requirements, nice_to_have, salary_min, salary_max, show_salary, status, closing_date, created_by, published_at, created_at, updated_at
`

type UpdateJobPostingStatusParams struct {
	ID     uuid.UUID `json:"id"`
	Status string    `json:"status"`
}

func (q *Queries) UpdateJobPostingStatus(ctx context.Context, arg UpdateJobPostingStatusParams) (CareersJobPosting, error) {
	row := q.db.QueryRowContext(ctx, updateJobPostingStatus, arg.ID, arg.Status, arg.Status)
	var i CareersJobPosting
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Position,
		&i.EmploymentType,
		&i.LocationType,
		&i.Description,
		pq.Array(&i.Responsibilities),
		pq.Array(&i.Requirements),
		pq.Array(&i.NiceToHave),
		&i.SalaryMin,
		&i.SalaryMax,
		&i.ShowSalary,
		&i.Status,
		&i.ClosingDate,
		&i.CreatedBy,
		&i.PublishedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
