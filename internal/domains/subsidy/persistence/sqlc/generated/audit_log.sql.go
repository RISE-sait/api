// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: audit_log.sql

package db

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
)

const countAuditLogs = `-- name: CountAuditLogs :one
SELECT COUNT(*) FROM subsidies.audit_log
WHERE ($1::uuid IS NULL OR customer_subsidy_id = $1)
  AND ($2::text IS NULL OR action = $2)
`

type CountAuditLogsParams struct {
	SubsidyID uuid.NullUUID  `json:"subsidy_id"`
	Action    sql.NullString `json:"action"`
}

func (q *Queries) CountAuditLogs(ctx context.Context, arg CountAuditLogsParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, countAuditLogs, arg.SubsidyID, arg.Action)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createAuditLog = `-- name: CreateAuditLog :one
INSERT INTO subsidies.audit_log (
    customer_subsidy_id,
    action,
    performed_by,
    previous_status,
    new_status,
    amount_changed,
    notes,
    ip_address
)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
RETURNING id, customer_subsidy_id, action, performed_by, previous_status, new_status, amount_changed, notes, ip_address, created_at
`

type CreateAuditLogParams struct {
	CustomerSubsidyID uuid.NullUUID  `json:"customer_subsidy_id"`
	Action            string         `json:"action"`
	PerformedBy       uuid.NullUUID  `json:"performed_by"`
	PreviousStatus    sql.NullString `json:"previous_status"`
	NewStatus         sql.NullString `json:"new_status"`
	AmountChanged     sql.NullString `json:"amount_changed"`
	Notes             sql.NullString `json:"notes"`
	IpAddress         sql.NullString `json:"ip_address"`
}

func (q *Queries) CreateAuditLog(ctx context.Context, arg CreateAuditLogParams) (SubsidiesAuditLog, error) {
	row := q.db.QueryRowContext(ctx, createAuditLog,
		arg.CustomerSubsidyID,
		arg.Action,
		arg.PerformedBy,
		arg.PreviousStatus,
		arg.NewStatus,
		arg.AmountChanged,
		arg.Notes,
		arg.IpAddress,
	)
	var i SubsidiesAuditLog
	err := row.Scan(
		&i.ID,
		&i.CustomerSubsidyID,
		&i.Action,
		&i.PerformedBy,
		&i.PreviousStatus,
		&i.NewStatus,
		&i.AmountChanged,
		&i.Notes,
		&i.IpAddress,
		&i.CreatedAt,
	)
	return i, err
}

const getAuditLog = `-- name: GetAuditLog :one
SELECT
    al.id, al.customer_subsidy_id, al.action, al.performed_by, al.previous_status, al.new_status, al.amount_changed, al.notes, al.ip_address, al.created_at,
    u.first_name || ' ' || u.last_name as performed_by_name
FROM subsidies.audit_log al
LEFT JOIN users.users u ON u.id = al.performed_by
WHERE al.id = $1
`

type GetAuditLogRow struct {
	ID                uuid.UUID      `json:"id"`
	CustomerSubsidyID uuid.NullUUID  `json:"customer_subsidy_id"`
	Action            string         `json:"action"`
	PerformedBy       uuid.NullUUID  `json:"performed_by"`
	PreviousStatus    sql.NullString `json:"previous_status"`
	NewStatus         sql.NullString `json:"new_status"`
	AmountChanged     sql.NullString `json:"amount_changed"`
	Notes             sql.NullString `json:"notes"`
	IpAddress         sql.NullString `json:"ip_address"`
	CreatedAt         sql.NullTime   `json:"created_at"`
	PerformedByName   interface{}    `json:"performed_by_name"`
}

func (q *Queries) GetAuditLog(ctx context.Context, id uuid.UUID) (GetAuditLogRow, error) {
	row := q.db.QueryRowContext(ctx, getAuditLog, id)
	var i GetAuditLogRow
	err := row.Scan(
		&i.ID,
		&i.CustomerSubsidyID,
		&i.Action,
		&i.PerformedBy,
		&i.PreviousStatus,
		&i.NewStatus,
		&i.AmountChanged,
		&i.Notes,
		&i.IpAddress,
		&i.CreatedAt,
		&i.PerformedByName,
	)
	return i, err
}

const listAuditLogs = `-- name: ListAuditLogs :many
SELECT
    al.id, al.customer_subsidy_id, al.action, al.performed_by, al.previous_status, al.new_status, al.amount_changed, al.notes, al.ip_address, al.created_at,
    u.first_name || ' ' || u.last_name as performed_by_name,
    cs.customer_id
FROM subsidies.audit_log al
LEFT JOIN users.users u ON u.id = al.performed_by
LEFT JOIN subsidies.customer_subsidies cs ON cs.id = al.customer_subsidy_id
WHERE ($1::uuid IS NULL OR al.customer_subsidy_id = $1)
  AND ($2::text IS NULL OR al.action = $2)
ORDER BY al.created_at DESC
LIMIT $4 OFFSET $3
`

type ListAuditLogsParams struct {
	SubsidyID uuid.NullUUID  `json:"subsidy_id"`
	Action    sql.NullString `json:"action"`
	Offset    int32          `json:"offset"`
	Limit     int32          `json:"limit"`
}

type ListAuditLogsRow struct {
	ID                uuid.UUID      `json:"id"`
	CustomerSubsidyID uuid.NullUUID  `json:"customer_subsidy_id"`
	Action            string         `json:"action"`
	PerformedBy       uuid.NullUUID  `json:"performed_by"`
	PreviousStatus    sql.NullString `json:"previous_status"`
	NewStatus         sql.NullString `json:"new_status"`
	AmountChanged     sql.NullString `json:"amount_changed"`
	Notes             sql.NullString `json:"notes"`
	IpAddress         sql.NullString `json:"ip_address"`
	CreatedAt         sql.NullTime   `json:"created_at"`
	PerformedByName   interface{}    `json:"performed_by_name"`
	CustomerID        uuid.NullUUID  `json:"customer_id"`
}

func (q *Queries) ListAuditLogs(ctx context.Context, arg ListAuditLogsParams) ([]ListAuditLogsRow, error) {
	rows, err := q.db.QueryContext(ctx, listAuditLogs,
		arg.SubsidyID,
		arg.Action,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListAuditLogsRow
	for rows.Next() {
		var i ListAuditLogsRow
		if err := rows.Scan(
			&i.ID,
			&i.CustomerSubsidyID,
			&i.Action,
			&i.PerformedBy,
			&i.PreviousStatus,
			&i.NewStatus,
			&i.AmountChanged,
			&i.Notes,
			&i.IpAddress,
			&i.CreatedAt,
			&i.PerformedByName,
			&i.CustomerID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAuditLogsBySubsidy = `-- name: ListAuditLogsBySubsidy :many
SELECT
    al.id, al.customer_subsidy_id, al.action, al.performed_by, al.previous_status, al.new_status, al.amount_changed, al.notes, al.ip_address, al.created_at,
    u.first_name || ' ' || u.last_name as performed_by_name
FROM subsidies.audit_log al
LEFT JOIN users.users u ON u.id = al.performed_by
WHERE al.customer_subsidy_id = $1
ORDER BY al.created_at DESC
`

type ListAuditLogsBySubsidyRow struct {
	ID                uuid.UUID      `json:"id"`
	CustomerSubsidyID uuid.NullUUID  `json:"customer_subsidy_id"`
	Action            string         `json:"action"`
	PerformedBy       uuid.NullUUID  `json:"performed_by"`
	PreviousStatus    sql.NullString `json:"previous_status"`
	NewStatus         sql.NullString `json:"new_status"`
	AmountChanged     sql.NullString `json:"amount_changed"`
	Notes             sql.NullString `json:"notes"`
	IpAddress         sql.NullString `json:"ip_address"`
	CreatedAt         sql.NullTime   `json:"created_at"`
	PerformedByName   interface{}    `json:"performed_by_name"`
}

func (q *Queries) ListAuditLogsBySubsidy(ctx context.Context, customerSubsidyID uuid.NullUUID) ([]ListAuditLogsBySubsidyRow, error) {
	rows, err := q.db.QueryContext(ctx, listAuditLogsBySubsidy, customerSubsidyID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListAuditLogsBySubsidyRow
	for rows.Next() {
		var i ListAuditLogsBySubsidyRow
		if err := rows.Scan(
			&i.ID,
			&i.CustomerSubsidyID,
			&i.Action,
			&i.PerformedBy,
			&i.PreviousStatus,
			&i.NewStatus,
			&i.AmountChanged,
			&i.Notes,
			&i.IpAddress,
			&i.CreatedAt,
			&i.PerformedByName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
