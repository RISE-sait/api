// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: customer_subsidies.sql

package db

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
	"github.com/shopspring/decimal"
)

const countCustomerSubsidies = `-- name: CountCustomerSubsidies :one
SELECT COUNT(*) FROM subsidies.customer_subsidies cs
WHERE ($1::uuid IS NULL OR cs.customer_id = $1)
  AND ($2::uuid IS NULL OR cs.provider_id = $2)
  AND ($3::text IS NULL OR cs.status = $3)
`

type CountCustomerSubsidiesParams struct {
	CustomerID uuid.NullUUID  `json:"customer_id"`
	ProviderID uuid.NullUUID  `json:"provider_id"`
	Status     sql.NullString `json:"status"`
}

func (q *Queries) CountCustomerSubsidies(ctx context.Context, arg CountCustomerSubsidiesParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, countCustomerSubsidies, arg.CustomerID, arg.ProviderID, arg.Status)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createCustomerSubsidy = `-- name: CreateCustomerSubsidy :one
INSERT INTO subsidies.customer_subsidies (
    customer_id,
    provider_id,
    approved_amount,
    status,
    approved_by,
    approved_at,
    valid_from,
    valid_until,
    reason,
    admin_notes
)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)
RETURNING id, customer_id, provider_id, approved_amount, total_amount_used, remaining_balance, status, approved_by, approved_at, rejected_by, rejected_at, rejection_reason, valid_from, valid_until, reason, application_notes, admin_notes, created_at, updated_at
`

type CreateCustomerSubsidyParams struct {
	CustomerID     uuid.UUID       `json:"customer_id"`
	ProviderID     uuid.NullUUID   `json:"provider_id"`
	ApprovedAmount decimal.Decimal `json:"approved_amount"`
	Status         string          `json:"status"`
	ApprovedBy     uuid.NullUUID   `json:"approved_by"`
	ApprovedAt     sql.NullTime    `json:"approved_at"`
	ValidFrom      time.Time       `json:"valid_from"`
	ValidUntil     sql.NullTime    `json:"valid_until"`
	Reason         sql.NullString  `json:"reason"`
	AdminNotes     sql.NullString  `json:"admin_notes"`
}

func (q *Queries) CreateCustomerSubsidy(ctx context.Context, arg CreateCustomerSubsidyParams) (SubsidiesCustomerSubsidy, error) {
	row := q.db.QueryRowContext(ctx, createCustomerSubsidy,
		arg.CustomerID,
		arg.ProviderID,
		arg.ApprovedAmount,
		arg.Status,
		arg.ApprovedBy,
		arg.ApprovedAt,
		arg.ValidFrom,
		arg.ValidUntil,
		arg.Reason,
		arg.AdminNotes,
	)
	var i SubsidiesCustomerSubsidy
	err := row.Scan(
		&i.ID,
		&i.CustomerID,
		&i.ProviderID,
		&i.ApprovedAmount,
		&i.TotalAmountUsed,
		&i.RemainingBalance,
		&i.Status,
		&i.ApprovedBy,
		&i.ApprovedAt,
		&i.RejectedBy,
		&i.RejectedAt,
		&i.RejectionReason,
		&i.ValidFrom,
		&i.ValidUntil,
		&i.Reason,
		&i.ApplicationNotes,
		&i.AdminNotes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deactivateSubsidy = `-- name: DeactivateSubsidy :one
UPDATE subsidies.customer_subsidies
SET
    status = 'expired',
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1
RETURNING id, customer_id, provider_id, approved_amount, total_amount_used, remaining_balance, status, approved_by, approved_at, rejected_by, rejected_at, rejection_reason, valid_from, valid_until, reason, application_notes, admin_notes, created_at, updated_at
`

func (q *Queries) DeactivateSubsidy(ctx context.Context, id uuid.UUID) (SubsidiesCustomerSubsidy, error) {
	row := q.db.QueryRowContext(ctx, deactivateSubsidy, id)
	var i SubsidiesCustomerSubsidy
	err := row.Scan(
		&i.ID,
		&i.CustomerID,
		&i.ProviderID,
		&i.ApprovedAmount,
		&i.TotalAmountUsed,
		&i.RemainingBalance,
		&i.Status,
		&i.ApprovedBy,
		&i.ApprovedAt,
		&i.RejectedBy,
		&i.RejectedAt,
		&i.RejectionReason,
		&i.ValidFrom,
		&i.ValidUntil,
		&i.Reason,
		&i.ApplicationNotes,
		&i.AdminNotes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const expireExpiredSubsidies = `-- name: ExpireExpiredSubsidies :exec
UPDATE subsidies.customer_subsidies
SET
    status = 'expired',
    updated_at = CURRENT_TIMESTAMP
WHERE status IN ('approved', 'active')
  AND valid_until IS NOT NULL
  AND valid_until < CURRENT_TIMESTAMP
`

func (q *Queries) ExpireExpiredSubsidies(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, expireExpiredSubsidies)
	return err
}

const getActiveSubsidyForCustomer = `-- name: GetActiveSubsidyForCustomer :one
SELECT
    cs.id, cs.customer_id, cs.provider_id, cs.approved_amount, cs.total_amount_used, cs.remaining_balance, cs.status, cs.approved_by, cs.approved_at, cs.rejected_by, cs.rejected_at, cs.rejection_reason, cs.valid_from, cs.valid_until, cs.reason, cs.application_notes, cs.admin_notes, cs.created_at, cs.updated_at,
    p.name as provider_name
FROM subsidies.customer_subsidies cs
LEFT JOIN subsidies.providers p ON p.id = cs.provider_id
WHERE cs.customer_id = $1
  AND cs.status IN ('approved', 'active')
  AND cs.remaining_balance > 0
  AND cs.valid_from <= CURRENT_TIMESTAMP
  AND (cs.valid_until IS NULL OR cs.valid_until >= CURRENT_TIMESTAMP)
ORDER BY cs.created_at ASC
LIMIT 1
`

type GetActiveSubsidyForCustomerRow struct {
	ID               uuid.UUID       `json:"id"`
	CustomerID       uuid.UUID       `json:"customer_id"`
	ProviderID       uuid.NullUUID   `json:"provider_id"`
	ApprovedAmount   decimal.Decimal `json:"approved_amount"`
	TotalAmountUsed  decimal.Decimal `json:"total_amount_used"`
	RemainingBalance sql.NullString  `json:"remaining_balance"`
	Status           string          `json:"status"`
	ApprovedBy       uuid.NullUUID   `json:"approved_by"`
	ApprovedAt       sql.NullTime    `json:"approved_at"`
	RejectedBy       uuid.NullUUID   `json:"rejected_by"`
	RejectedAt       sql.NullTime    `json:"rejected_at"`
	RejectionReason  sql.NullString  `json:"rejection_reason"`
	ValidFrom        time.Time       `json:"valid_from"`
	ValidUntil       sql.NullTime    `json:"valid_until"`
	Reason           sql.NullString  `json:"reason"`
	ApplicationNotes sql.NullString  `json:"application_notes"`
	AdminNotes       sql.NullString  `json:"admin_notes"`
	CreatedAt        sql.NullTime    `json:"created_at"`
	UpdatedAt        sql.NullTime    `json:"updated_at"`
	ProviderName     sql.NullString  `json:"provider_name"`
}

func (q *Queries) GetActiveSubsidyForCustomer(ctx context.Context, customerID uuid.UUID) (GetActiveSubsidyForCustomerRow, error) {
	row := q.db.QueryRowContext(ctx, getActiveSubsidyForCustomer, customerID)
	var i GetActiveSubsidyForCustomerRow
	err := row.Scan(
		&i.ID,
		&i.CustomerID,
		&i.ProviderID,
		&i.ApprovedAmount,
		&i.TotalAmountUsed,
		&i.RemainingBalance,
		&i.Status,
		&i.ApprovedBy,
		&i.ApprovedAt,
		&i.RejectedBy,
		&i.RejectedAt,
		&i.RejectionReason,
		&i.ValidFrom,
		&i.ValidUntil,
		&i.Reason,
		&i.ApplicationNotes,
		&i.AdminNotes,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ProviderName,
	)
	return i, err
}

const getCustomerSubsidiesByCustomerID = `-- name: GetCustomerSubsidiesByCustomerID :many
SELECT
    cs.id, cs.customer_id, cs.provider_id, cs.approved_amount, cs.total_amount_used, cs.remaining_balance, cs.status, cs.approved_by, cs.approved_at, cs.rejected_by, cs.rejected_at, cs.rejection_reason, cs.valid_from, cs.valid_until, cs.reason, cs.application_notes, cs.admin_notes, cs.created_at, cs.updated_at,
    p.name as provider_name
FROM subsidies.customer_subsidies cs
LEFT JOIN subsidies.providers p ON p.id = cs.provider_id
WHERE cs.customer_id = $1
ORDER BY cs.created_at DESC
`

type GetCustomerSubsidiesByCustomerIDRow struct {
	ID               uuid.UUID       `json:"id"`
	CustomerID       uuid.UUID       `json:"customer_id"`
	ProviderID       uuid.NullUUID   `json:"provider_id"`
	ApprovedAmount   decimal.Decimal `json:"approved_amount"`
	TotalAmountUsed  decimal.Decimal `json:"total_amount_used"`
	RemainingBalance sql.NullString  `json:"remaining_balance"`
	Status           string          `json:"status"`
	ApprovedBy       uuid.NullUUID   `json:"approved_by"`
	ApprovedAt       sql.NullTime    `json:"approved_at"`
	RejectedBy       uuid.NullUUID   `json:"rejected_by"`
	RejectedAt       sql.NullTime    `json:"rejected_at"`
	RejectionReason  sql.NullString  `json:"rejection_reason"`
	ValidFrom        time.Time       `json:"valid_from"`
	ValidUntil       sql.NullTime    `json:"valid_until"`
	Reason           sql.NullString  `json:"reason"`
	ApplicationNotes sql.NullString  `json:"application_notes"`
	AdminNotes       sql.NullString  `json:"admin_notes"`
	CreatedAt        sql.NullTime    `json:"created_at"`
	UpdatedAt        sql.NullTime    `json:"updated_at"`
	ProviderName     sql.NullString  `json:"provider_name"`
}

func (q *Queries) GetCustomerSubsidiesByCustomerID(ctx context.Context, customerID uuid.UUID) ([]GetCustomerSubsidiesByCustomerIDRow, error) {
	rows, err := q.db.QueryContext(ctx, getCustomerSubsidiesByCustomerID, customerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCustomerSubsidiesByCustomerIDRow
	for rows.Next() {
		var i GetCustomerSubsidiesByCustomerIDRow
		if err := rows.Scan(
			&i.ID,
			&i.CustomerID,
			&i.ProviderID,
			&i.ApprovedAmount,
			&i.TotalAmountUsed,
			&i.RemainingBalance,
			&i.Status,
			&i.ApprovedBy,
			&i.ApprovedAt,
			&i.RejectedBy,
			&i.RejectedAt,
			&i.RejectionReason,
			&i.ValidFrom,
			&i.ValidUntil,
			&i.Reason,
			&i.ApplicationNotes,
			&i.AdminNotes,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ProviderName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCustomerSubsidy = `-- name: GetCustomerSubsidy :one
SELECT
    cs.id, cs.customer_id, cs.provider_id, cs.approved_amount, cs.total_amount_used, cs.remaining_balance, cs.status, cs.approved_by, cs.approved_at, cs.rejected_by, cs.rejected_at, cs.rejection_reason, cs.valid_from, cs.valid_until, cs.reason, cs.application_notes, cs.admin_notes, cs.created_at, cs.updated_at,
    p.name as provider_name,
    u.first_name || ' ' || u.last_name as customer_name,
    u.email as customer_email,
    approver.first_name || ' ' || approver.last_name as approved_by_name
FROM subsidies.customer_subsidies cs
LEFT JOIN subsidies.providers p ON p.id = cs.provider_id
LEFT JOIN users.users u ON u.id = cs.customer_id
LEFT JOIN users.users approver ON approver.id = cs.approved_by
WHERE cs.id = $1
`

type GetCustomerSubsidyRow struct {
	ID               uuid.UUID       `json:"id"`
	CustomerID       uuid.UUID       `json:"customer_id"`
	ProviderID       uuid.NullUUID   `json:"provider_id"`
	ApprovedAmount   decimal.Decimal `json:"approved_amount"`
	TotalAmountUsed  decimal.Decimal `json:"total_amount_used"`
	RemainingBalance sql.NullString  `json:"remaining_balance"`
	Status           string          `json:"status"`
	ApprovedBy       uuid.NullUUID   `json:"approved_by"`
	ApprovedAt       sql.NullTime    `json:"approved_at"`
	RejectedBy       uuid.NullUUID   `json:"rejected_by"`
	RejectedAt       sql.NullTime    `json:"rejected_at"`
	RejectionReason  sql.NullString  `json:"rejection_reason"`
	ValidFrom        time.Time       `json:"valid_from"`
	ValidUntil       sql.NullTime    `json:"valid_until"`
	Reason           sql.NullString  `json:"reason"`
	ApplicationNotes sql.NullString  `json:"application_notes"`
	AdminNotes       sql.NullString  `json:"admin_notes"`
	CreatedAt        sql.NullTime    `json:"created_at"`
	UpdatedAt        sql.NullTime    `json:"updated_at"`
	ProviderName     sql.NullString  `json:"provider_name"`
	CustomerName     interface{}     `json:"customer_name"`
	CustomerEmail    sql.NullString  `json:"customer_email"`
	ApprovedByName   interface{}     `json:"approved_by_name"`
}

func (q *Queries) GetCustomerSubsidy(ctx context.Context, id uuid.UUID) (GetCustomerSubsidyRow, error) {
	row := q.db.QueryRowContext(ctx, getCustomerSubsidy, id)
	var i GetCustomerSubsidyRow
	err := row.Scan(
		&i.ID,
		&i.CustomerID,
		&i.ProviderID,
		&i.ApprovedAmount,
		&i.TotalAmountUsed,
		&i.RemainingBalance,
		&i.Status,
		&i.ApprovedBy,
		&i.ApprovedAt,
		&i.RejectedBy,
		&i.RejectedAt,
		&i.RejectionReason,
		&i.ValidFrom,
		&i.ValidUntil,
		&i.Reason,
		&i.ApplicationNotes,
		&i.AdminNotes,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ProviderName,
		&i.CustomerName,
		&i.CustomerEmail,
		&i.ApprovedByName,
	)
	return i, err
}

const getSubsidySummary = `-- name: GetSubsidySummary :one
SELECT
    COUNT(*) FILTER (WHERE status = 'active') as active_count,
    COUNT(*) FILTER (WHERE status = 'pending') as pending_count,
    COUNT(*) FILTER (WHERE status = 'depleted') as depleted_count,
    COALESCE(SUM(approved_amount) FILTER (WHERE status IN ('approved', 'active')), 0) as total_approved,
    COALESCE(SUM(total_amount_used), 0) as total_used,
    COALESCE(SUM(remaining_balance) FILTER (WHERE status IN ('approved', 'active')), 0) as total_remaining
FROM subsidies.customer_subsidies
`

type GetSubsidySummaryRow struct {
	ActiveCount    int64       `json:"active_count"`
	PendingCount   int64       `json:"pending_count"`
	DepletedCount  int64       `json:"depleted_count"`
	TotalApproved  interface{} `json:"total_approved"`
	TotalUsed      interface{} `json:"total_used"`
	TotalRemaining interface{} `json:"total_remaining"`
}

func (q *Queries) GetSubsidySummary(ctx context.Context) (GetSubsidySummaryRow, error) {
	row := q.db.QueryRowContext(ctx, getSubsidySummary)
	var i GetSubsidySummaryRow
	err := row.Scan(
		&i.ActiveCount,
		&i.PendingCount,
		&i.DepletedCount,
		&i.TotalApproved,
		&i.TotalUsed,
		&i.TotalRemaining,
	)
	return i, err
}

const listCustomerSubsidies = `-- name: ListCustomerSubsidies :many
SELECT
    cs.id, cs.customer_id, cs.provider_id, cs.approved_amount, cs.total_amount_used, cs.remaining_balance, cs.status, cs.approved_by, cs.approved_at, cs.rejected_by, cs.rejected_at, cs.rejection_reason, cs.valid_from, cs.valid_until, cs.reason, cs.application_notes, cs.admin_notes, cs.created_at, cs.updated_at,
    p.name as provider_name,
    u.first_name || ' ' || u.last_name as customer_name,
    u.email as customer_email,
    approver.first_name || ' ' || approver.last_name as approved_by_name
FROM subsidies.customer_subsidies cs
LEFT JOIN subsidies.providers p ON p.id = cs.provider_id
LEFT JOIN users.users u ON u.id = cs.customer_id
LEFT JOIN users.users approver ON approver.id = cs.approved_by
WHERE ($1::uuid IS NULL OR cs.customer_id = $1)
  AND ($2::uuid IS NULL OR cs.provider_id = $2)
  AND ($3::text IS NULL OR cs.status = $3)
ORDER BY cs.created_at DESC
LIMIT $5 OFFSET $4
`

type ListCustomerSubsidiesParams struct {
	CustomerID uuid.NullUUID  `json:"customer_id"`
	ProviderID uuid.NullUUID  `json:"provider_id"`
	Status     sql.NullString `json:"status"`
	Offset     int32          `json:"offset"`
	Limit      int32          `json:"limit"`
}

type ListCustomerSubsidiesRow struct {
	ID               uuid.UUID       `json:"id"`
	CustomerID       uuid.UUID       `json:"customer_id"`
	ProviderID       uuid.NullUUID   `json:"provider_id"`
	ApprovedAmount   decimal.Decimal `json:"approved_amount"`
	TotalAmountUsed  decimal.Decimal `json:"total_amount_used"`
	RemainingBalance sql.NullString  `json:"remaining_balance"`
	Status           string          `json:"status"`
	ApprovedBy       uuid.NullUUID   `json:"approved_by"`
	ApprovedAt       sql.NullTime    `json:"approved_at"`
	RejectedBy       uuid.NullUUID   `json:"rejected_by"`
	RejectedAt       sql.NullTime    `json:"rejected_at"`
	RejectionReason  sql.NullString  `json:"rejection_reason"`
	ValidFrom        time.Time       `json:"valid_from"`
	ValidUntil       sql.NullTime    `json:"valid_until"`
	Reason           sql.NullString  `json:"reason"`
	ApplicationNotes sql.NullString  `json:"application_notes"`
	AdminNotes       sql.NullString  `json:"admin_notes"`
	CreatedAt        sql.NullTime    `json:"created_at"`
	UpdatedAt        sql.NullTime    `json:"updated_at"`
	ProviderName     sql.NullString  `json:"provider_name"`
	CustomerName     interface{}     `json:"customer_name"`
	CustomerEmail    sql.NullString  `json:"customer_email"`
	ApprovedByName   interface{}     `json:"approved_by_name"`
}

func (q *Queries) ListCustomerSubsidies(ctx context.Context, arg ListCustomerSubsidiesParams) ([]ListCustomerSubsidiesRow, error) {
	rows, err := q.db.QueryContext(ctx, listCustomerSubsidies,
		arg.CustomerID,
		arg.ProviderID,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListCustomerSubsidiesRow
	for rows.Next() {
		var i ListCustomerSubsidiesRow
		if err := rows.Scan(
			&i.ID,
			&i.CustomerID,
			&i.ProviderID,
			&i.ApprovedAmount,
			&i.TotalAmountUsed,
			&i.RemainingBalance,
			&i.Status,
			&i.ApprovedBy,
			&i.ApprovedAt,
			&i.RejectedBy,
			&i.RejectedAt,
			&i.RejectionReason,
			&i.ValidFrom,
			&i.ValidUntil,
			&i.Reason,
			&i.ApplicationNotes,
			&i.AdminNotes,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ProviderName,
			&i.CustomerName,
			&i.CustomerEmail,
			&i.ApprovedByName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markSubsidyAsDepleted = `-- name: MarkSubsidyAsDepleted :one
UPDATE subsidies.customer_subsidies
SET
    status = 'depleted',
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1
RETURNING id, customer_id, provider_id, approved_amount, total_amount_used, remaining_balance, status, approved_by, approved_at, rejected_by, rejected_at, rejection_reason, valid_from, valid_until, reason, application_notes, admin_notes, created_at, updated_at
`

func (q *Queries) MarkSubsidyAsDepleted(ctx context.Context, id uuid.UUID) (SubsidiesCustomerSubsidy, error) {
	row := q.db.QueryRowContext(ctx, markSubsidyAsDepleted, id)
	var i SubsidiesCustomerSubsidy
	err := row.Scan(
		&i.ID,
		&i.CustomerID,
		&i.ProviderID,
		&i.ApprovedAmount,
		&i.TotalAmountUsed,
		&i.RemainingBalance,
		&i.Status,
		&i.ApprovedBy,
		&i.ApprovedAt,
		&i.RejectedBy,
		&i.RejectedAt,
		&i.RejectionReason,
		&i.ValidFrom,
		&i.ValidUntil,
		&i.Reason,
		&i.ApplicationNotes,
		&i.AdminNotes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateSubsidyStatus = `-- name: UpdateSubsidyStatus :one
UPDATE subsidies.customer_subsidies
SET
    status = $2,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1
RETURNING id, customer_id, provider_id, approved_amount, total_amount_used, remaining_balance, status, approved_by, approved_at, rejected_by, rejected_at, rejection_reason, valid_from, valid_until, reason, application_notes, admin_notes, created_at, updated_at
`

type UpdateSubsidyStatusParams struct {
	ID     uuid.UUID `json:"id"`
	Status string    `json:"status"`
}

func (q *Queries) UpdateSubsidyStatus(ctx context.Context, arg UpdateSubsidyStatusParams) (SubsidiesCustomerSubsidy, error) {
	row := q.db.QueryRowContext(ctx, updateSubsidyStatus, arg.ID, arg.Status)
	var i SubsidiesCustomerSubsidy
	err := row.Scan(
		&i.ID,
		&i.CustomerID,
		&i.ProviderID,
		&i.ApprovedAmount,
		&i.TotalAmountUsed,
		&i.RemainingBalance,
		&i.Status,
		&i.ApprovedBy,
		&i.ApprovedAt,
		&i.RejectedBy,
		&i.RejectedAt,
		&i.RejectionReason,
		&i.ValidFrom,
		&i.ValidUntil,
		&i.Reason,
		&i.ApplicationNotes,
		&i.AdminNotes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateSubsidyUsage = `-- name: UpdateSubsidyUsage :one
UPDATE subsidies.customer_subsidies
SET
    total_amount_used = total_amount_used + $2,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1
RETURNING id, customer_id, provider_id, approved_amount, total_amount_used, remaining_balance, status, approved_by, approved_at, rejected_by, rejected_at, rejection_reason, valid_from, valid_until, reason, application_notes, admin_notes, created_at, updated_at
`

type UpdateSubsidyUsageParams struct {
	ID              uuid.UUID       `json:"id"`
	TotalAmountUsed decimal.Decimal `json:"total_amount_used"`
}

func (q *Queries) UpdateSubsidyUsage(ctx context.Context, arg UpdateSubsidyUsageParams) (SubsidiesCustomerSubsidy, error) {
	row := q.db.QueryRowContext(ctx, updateSubsidyUsage, arg.ID, arg.TotalAmountUsed)
	var i SubsidiesCustomerSubsidy
	err := row.Scan(
		&i.ID,
		&i.CustomerID,
		&i.ProviderID,
		&i.ApprovedAmount,
		&i.TotalAmountUsed,
		&i.RemainingBalance,
		&i.Status,
		&i.ApprovedBy,
		&i.ApprovedAt,
		&i.RejectedBy,
		&i.RejectedAt,
		&i.RejectionReason,
		&i.ValidFrom,
		&i.ValidUntil,
		&i.Reason,
		&i.ApplicationNotes,
		&i.AdminNotes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
