// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: email_change.sql

package db_identity

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
)

const cancelPendingEmailChange = `-- name: CancelPendingEmailChange :execrows
UPDATE users.users
SET pending_email = NULL,
    pending_email_token = NULL,
    pending_email_token_expires_at = NULL,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1 AND deleted_at IS NULL
`

func (q *Queries) CancelPendingEmailChange(ctx context.Context, id uuid.UUID) (int64, error) {
	result, err := q.db.ExecContext(ctx, cancelPendingEmailChange, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const checkEmailExists = `-- name: CheckEmailExists :one
SELECT EXISTS(
    SELECT 1 FROM users.users
    WHERE email = $1 AND deleted_at IS NULL
) AS exists
`

func (q *Queries) CheckEmailExists(ctx context.Context, email sql.NullString) (bool, error) {
	row := q.db.QueryRowContext(ctx, checkEmailExists, email)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const completePendingEmailChange = `-- name: CompletePendingEmailChange :execrows
UPDATE users.users
SET email = pending_email,
    pending_email = NULL,
    pending_email_token = NULL,
    pending_email_token_expires_at = NULL,
    email_changed_at = CURRENT_TIMESTAMP,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1 AND pending_email IS NOT NULL AND deleted_at IS NULL
`

func (q *Queries) CompletePendingEmailChange(ctx context.Context, id uuid.UUID) (int64, error) {
	result, err := q.db.ExecContext(ctx, completePendingEmailChange, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const getUserByPendingEmailToken = `-- name: GetUserByPendingEmailToken :one
SELECT id, email, pending_email, first_name, pending_email_token_expires_at
FROM users.users
WHERE pending_email_token = $1 AND deleted_at IS NULL
`

type GetUserByPendingEmailTokenRow struct {
	ID                         uuid.UUID      `json:"id"`
	Email                      sql.NullString `json:"email"`
	PendingEmail               sql.NullString `json:"pending_email"`
	FirstName                  string         `json:"first_name"`
	PendingEmailTokenExpiresAt sql.NullTime   `json:"pending_email_token_expires_at"`
}

func (q *Queries) GetUserByPendingEmailToken(ctx context.Context, pendingEmailToken sql.NullString) (GetUserByPendingEmailTokenRow, error) {
	row := q.db.QueryRowContext(ctx, getUserByPendingEmailToken, pendingEmailToken)
	var i GetUserByPendingEmailTokenRow
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.PendingEmail,
		&i.FirstName,
		&i.PendingEmailTokenExpiresAt,
	)
	return i, err
}

const getUserPendingEmailInfo = `-- name: GetUserPendingEmailInfo :one
SELECT id, email, pending_email, first_name, pending_email_token, pending_email_token_expires_at
FROM users.users
WHERE id = $1 AND deleted_at IS NULL
`

type GetUserPendingEmailInfoRow struct {
	ID                         uuid.UUID      `json:"id"`
	Email                      sql.NullString `json:"email"`
	PendingEmail               sql.NullString `json:"pending_email"`
	FirstName                  string         `json:"first_name"`
	PendingEmailToken          sql.NullString `json:"pending_email_token"`
	PendingEmailTokenExpiresAt sql.NullTime   `json:"pending_email_token_expires_at"`
}

func (q *Queries) GetUserPendingEmailInfo(ctx context.Context, id uuid.UUID) (GetUserPendingEmailInfoRow, error) {
	row := q.db.QueryRowContext(ctx, getUserPendingEmailInfo, id)
	var i GetUserPendingEmailInfoRow
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.PendingEmail,
		&i.FirstName,
		&i.PendingEmailToken,
		&i.PendingEmailTokenExpiresAt,
	)
	return i, err
}

const initiatePendingEmailChange = `-- name: InitiatePendingEmailChange :execrows
UPDATE users.users
SET pending_email = $2,
    pending_email_token = $3,
    pending_email_token_expires_at = $4,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1 AND deleted_at IS NULL
`

type InitiatePendingEmailChangeParams struct {
	ID                         uuid.UUID      `json:"id"`
	PendingEmail               sql.NullString `json:"pending_email"`
	PendingEmailToken          sql.NullString `json:"pending_email_token"`
	PendingEmailTokenExpiresAt sql.NullTime   `json:"pending_email_token_expires_at"`
}

func (q *Queries) InitiatePendingEmailChange(ctx context.Context, arg InitiatePendingEmailChangeParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, initiatePendingEmailChange,
		arg.ID,
		arg.PendingEmail,
		arg.PendingEmailToken,
		arg.PendingEmailTokenExpiresAt,
	)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}
