// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: enrollment_queries.sql

package db_enrollment

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
)

const enrollCustomer = `-- name: EnrollCustomer :one
INSERT INTO events.customer_enrollment (customer_id, event_id, checked_in_at, is_cancelled)
VALUES ($1, $2, $3, $4)
RETURNING id, customer_id, event_id, created_at, updated_at, checked_in_at, is_cancelled
`

type EnrollCustomerParams struct {
	CustomerID  uuid.UUID    `json:"customer_id"`
	EventID     uuid.UUID    `json:"event_id"`
	CheckedInAt sql.NullTime `json:"checked_in_at"`
	IsCancelled bool         `json:"is_cancelled"`
}

func (q *Queries) EnrollCustomer(ctx context.Context, arg EnrollCustomerParams) (EventsCustomerEnrollment, error) {
	row := q.db.QueryRowContext(ctx, enrollCustomer,
		arg.CustomerID,
		arg.EventID,
		arg.CheckedInAt,
		arg.IsCancelled,
	)
	var i EventsCustomerEnrollment
	err := row.Scan(
		&i.ID,
		&i.CustomerID,
		&i.EventID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CheckedInAt,
		&i.IsCancelled,
	)
	return i, err
}

const getCustomerEnrollments = `-- name: GetCustomerEnrollments :many
SELECT customer_enrollment.id, customer_enrollment.customer_id, customer_enrollment.event_id, customer_enrollment.created_at, customer_enrollment.updated_at, customer_enrollment.checked_in_at, customer_enrollment.is_cancelled
FROM events.customer_enrollment
         JOIN users.users ON customer_enrollment.customer_id = users.id
WHERE (
          (customer_id = $1 OR $1 IS NULL)
              AND
          (event_id = $2 OR $2 IS NULL))
`

type GetCustomerEnrollmentsParams struct {
	CustomerID uuid.NullUUID `json:"customer_id"`
	EventID    uuid.NullUUID `json:"event_id"`
}

func (q *Queries) GetCustomerEnrollments(ctx context.Context, arg GetCustomerEnrollmentsParams) ([]EventsCustomerEnrollment, error) {
	rows, err := q.db.QueryContext(ctx, getCustomerEnrollments, arg.CustomerID, arg.EventID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []EventsCustomerEnrollment
	for rows.Next() {
		var i EventsCustomerEnrollment
		if err := rows.Scan(
			&i.ID,
			&i.CustomerID,
			&i.EventID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CheckedInAt,
			&i.IsCancelled,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEventIsFull = `-- name: GetEventIsFull :one
SELECT 
    (CASE 
        WHEN COALESCE(e.capacity, t.capacity) IS NULL THEN false
        ELSE COUNT(ce.customer_id) >= COALESCE(e.capacity, t.capacity)
    END)::boolean AS is_full
FROM events.events e 
LEFT JOIN athletic.teams t ON e.team_id = t.id
LEFT JOIN events.customer_enrollment ce ON e.id = ce.event_id
WHERE e.id = $1
GROUP BY e.id, e.capacity, t.capacity
`

func (q *Queries) GetEventIsFull(ctx context.Context, eventID uuid.UUID) (bool, error) {
	row := q.db.QueryRowContext(ctx, getEventIsFull, eventID)
	var is_full bool
	err := row.Scan(&is_full)
	return is_full, err
}

const unEnrollCustomer = `-- name: UnEnrollCustomer :execrows
DELETE
FROM events.customer_enrollment
WHERE id = $1
`

func (q *Queries) UnEnrollCustomer(ctx context.Context, id uuid.UUID) (int64, error) {
	result, err := q.db.ExecContext(ctx, unEnrollCustomer, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}
